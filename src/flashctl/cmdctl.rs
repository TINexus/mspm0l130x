# [doc = "Register `CMDCTL` reader"] pub type R = crate :: R < CMDCTL_SPEC > ; # [doc = "Register `CMDCTL` writer"] pub type W = crate :: W < CMDCTL_SPEC > ; # [doc = "Field `CMDCTL_MODESEL` reader - Mode This field is only used for the Mode Change command type. Otherwise, bank and pump modes are set automaticlly via the NW hardware."] pub type CMDCTL_MODESEL_R = crate :: FieldReader < CMDCTL_MODESEL_A > ; # [doc = "Mode This field is only used for the Mode Change command type. Otherwise, bank and pump modes are set automaticlly via the NW hardware.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CMDCTL_MODESEL_A { # [doc = "0: READ"] CMDCTL_MODESEL_READ = 0 , # [doc = "2: RDMARG0"] CMDCTL_MODESEL_RDMARG0 = 2 , # [doc = "4: RDMARG1"] CMDCTL_MODESEL_RDMARG1 = 4 , # [doc = "6: RDMARG0B"] CMDCTL_MODESEL_RDMARG0B = 6 , # [doc = "7: RDMARG1B"] CMDCTL_MODESEL_RDMARG1B = 7 , # [doc = "9: PGMVER"] CMDCTL_MODESEL_PGMVER = 9 , # [doc = "10: PGMSW"] CMDCTL_MODESEL_PGMSW = 10 , # [doc = "11: ERASEVER"] CMDCTL_MODESEL_ERASEVER = 11 , # [doc = "12: ERASESECT"] CMDCTL_MODESEL_ERASESECT = 12 , # [doc = "14: PGMMW"] CMDCTL_MODESEL_PGMMW = 14 , # [doc = "15: ERASEBNK"] CMDCTL_MODESEL_ERASEBNK = 15 , } impl From < CMDCTL_MODESEL_A > for u8 { # [inline (always)] fn from (variant : CMDCTL_MODESEL_A) -> Self { variant as _ } } impl crate :: FieldSpec for CMDCTL_MODESEL_A { type Ux = u8 ; } impl CMDCTL_MODESEL_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CMDCTL_MODESEL_A > { match self . bits { 0 => Some (CMDCTL_MODESEL_A :: CMDCTL_MODESEL_READ) , 2 => Some (CMDCTL_MODESEL_A :: CMDCTL_MODESEL_RDMARG0) , 4 => Some (CMDCTL_MODESEL_A :: CMDCTL_MODESEL_RDMARG1) , 6 => Some (CMDCTL_MODESEL_A :: CMDCTL_MODESEL_RDMARG0B) , 7 => Some (CMDCTL_MODESEL_A :: CMDCTL_MODESEL_RDMARG1B) , 9 => Some (CMDCTL_MODESEL_A :: CMDCTL_MODESEL_PGMVER) , 10 => Some (CMDCTL_MODESEL_A :: CMDCTL_MODESEL_PGMSW) , 11 => Some (CMDCTL_MODESEL_A :: CMDCTL_MODESEL_ERASEVER) , 12 => Some (CMDCTL_MODESEL_A :: CMDCTL_MODESEL_ERASESECT) , 14 => Some (CMDCTL_MODESEL_A :: CMDCTL_MODESEL_PGMMW) , 15 => Some (CMDCTL_MODESEL_A :: CMDCTL_MODESEL_ERASEBNK) , _ => None , } } # [doc = "READ"] # [inline (always)] pub fn is_cmdctl_modesel_read (& self) -> bool { * self == CMDCTL_MODESEL_A :: CMDCTL_MODESEL_READ } # [doc = "RDMARG0"] # [inline (always)] pub fn is_cmdctl_modesel_rdmarg0 (& self) -> bool { * self == CMDCTL_MODESEL_A :: CMDCTL_MODESEL_RDMARG0 } # [doc = "RDMARG1"] # [inline (always)] pub fn is_cmdctl_modesel_rdmarg1 (& self) -> bool { * self == CMDCTL_MODESEL_A :: CMDCTL_MODESEL_RDMARG1 } # [doc = "RDMARG0B"] # [inline (always)] pub fn is_cmdctl_modesel_rdmarg0b (& self) -> bool { * self == CMDCTL_MODESEL_A :: CMDCTL_MODESEL_RDMARG0B } # [doc = "RDMARG1B"] # [inline (always)] pub fn is_cmdctl_modesel_rdmarg1b (& self) -> bool { * self == CMDCTL_MODESEL_A :: CMDCTL_MODESEL_RDMARG1B } # [doc = "PGMVER"] # [inline (always)] pub fn is_cmdctl_modesel_pgmver (& self) -> bool { * self == CMDCTL_MODESEL_A :: CMDCTL_MODESEL_PGMVER } # [doc = "PGMSW"] # [inline (always)] pub fn is_cmdctl_modesel_pgmsw (& self) -> bool { * self == CMDCTL_MODESEL_A :: CMDCTL_MODESEL_PGMSW } # [doc = "ERASEVER"] # [inline (always)] pub fn is_cmdctl_modesel_erasever (& self) -> bool { * self == CMDCTL_MODESEL_A :: CMDCTL_MODESEL_ERASEVER } # [doc = "ERASESECT"] # [inline (always)] pub fn is_cmdctl_modesel_erasesect (& self) -> bool { * self == CMDCTL_MODESEL_A :: CMDCTL_MODESEL_ERASESECT } # [doc = "PGMMW"] # [inline (always)] pub fn is_cmdctl_modesel_pgmmw (& self) -> bool { * self == CMDCTL_MODESEL_A :: CMDCTL_MODESEL_PGMMW } # [doc = "ERASEBNK"] # [inline (always)] pub fn is_cmdctl_modesel_erasebnk (& self) -> bool { * self == CMDCTL_MODESEL_A :: CMDCTL_MODESEL_ERASEBNK } } # [doc = "Field `CMDCTL_MODESEL` writer - Mode This field is only used for the Mode Change command type. Otherwise, bank and pump modes are set automaticlly via the NW hardware."] pub type CMDCTL_MODESEL_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 4 , O , CMDCTL_MODESEL_A > ; impl < 'a , REG , const O : u8 > CMDCTL_MODESEL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "READ"] # [inline (always)] pub fn cmdctl_modesel_read (self) -> & 'a mut crate :: W < REG > { self . variant (CMDCTL_MODESEL_A :: CMDCTL_MODESEL_READ) } # [doc = "RDMARG0"] # [inline (always)] pub fn cmdctl_modesel_rdmarg0 (self) -> & 'a mut crate :: W < REG > { self . variant (CMDCTL_MODESEL_A :: CMDCTL_MODESEL_RDMARG0) } # [doc = "RDMARG1"] # [inline (always)] pub fn cmdctl_modesel_rdmarg1 (self) -> & 'a mut crate :: W < REG > { self . variant (CMDCTL_MODESEL_A :: CMDCTL_MODESEL_RDMARG1) } # [doc = "RDMARG0B"] # [inline (always)] pub fn cmdctl_modesel_rdmarg0b (self) -> & 'a mut crate :: W < REG > { self . variant (CMDCTL_MODESEL_A :: CMDCTL_MODESEL_RDMARG0B) } # [doc = "RDMARG1B"] # [inline (always)] pub fn cmdctl_modesel_rdmarg1b (self) -> & 'a mut crate :: W < REG > { self . variant (CMDCTL_MODESEL_A :: CMDCTL_MODESEL_RDMARG1B) } # [doc = "PGMVER"] # [inline (always)] pub fn cmdctl_modesel_pgmver (self) -> & 'a mut crate :: W < REG > { self . variant (CMDCTL_MODESEL_A :: CMDCTL_MODESEL_PGMVER) } # [doc = "PGMSW"] # [inline (always)] pub fn cmdctl_modesel_pgmsw (self) -> & 'a mut crate :: W < REG > { self . variant (CMDCTL_MODESEL_A :: CMDCTL_MODESEL_PGMSW) } # [doc = "ERASEVER"] # [inline (always)] pub fn cmdctl_modesel_erasever (self) -> & 'a mut crate :: W < REG > { self . variant (CMDCTL_MODESEL_A :: CMDCTL_MODESEL_ERASEVER) } # [doc = "ERASESECT"] # [inline (always)] pub fn cmdctl_modesel_erasesect (self) -> & 'a mut crate :: W < REG > { self . variant (CMDCTL_MODESEL_A :: CMDCTL_MODESEL_ERASESECT) } # [doc = "PGMMW"] # [inline (always)] pub fn cmdctl_modesel_pgmmw (self) -> & 'a mut crate :: W < REG > { self . variant (CMDCTL_MODESEL_A :: CMDCTL_MODESEL_PGMMW) } # [doc = "ERASEBNK"] # [inline (always)] pub fn cmdctl_modesel_erasebnk (self) -> & 'a mut crate :: W < REG > { self . variant (CMDCTL_MODESEL_A :: CMDCTL_MODESEL_ERASEBNK) } } # [doc = "Field `CMDCTL_REGIONSEL` reader - Bank Region A specific region ID can be written to this field to indicate to which region an operation should be applied if CMDCTL.ADDRXLATEOVR is set."] pub type CMDCTL_REGIONSEL_R = crate :: FieldReader < CMDCTL_REGIONSEL_A > ; # [doc = "Bank Region A specific region ID can be written to this field to indicate to which region an operation should be applied if CMDCTL.ADDRXLATEOVR is set.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CMDCTL_REGIONSEL_A { # [doc = "1: MAIN"] CMDCTL_REGIONSEL_MAIN = 1 , # [doc = "2: NONMAIN"] CMDCTL_REGIONSEL_NONMAIN = 2 , # [doc = "4: TRIM"] CMDCTL_REGIONSEL_TRIM = 4 , # [doc = "8: ENGR"] CMDCTL_REGIONSEL_ENGR = 8 , } impl From < CMDCTL_REGIONSEL_A > for u8 { # [inline (always)] fn from (variant : CMDCTL_REGIONSEL_A) -> Self { variant as _ } } impl crate :: FieldSpec for CMDCTL_REGIONSEL_A { type Ux = u8 ; } impl CMDCTL_REGIONSEL_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CMDCTL_REGIONSEL_A > { match self . bits { 1 => Some (CMDCTL_REGIONSEL_A :: CMDCTL_REGIONSEL_MAIN) , 2 => Some (CMDCTL_REGIONSEL_A :: CMDCTL_REGIONSEL_NONMAIN) , 4 => Some (CMDCTL_REGIONSEL_A :: CMDCTL_REGIONSEL_TRIM) , 8 => Some (CMDCTL_REGIONSEL_A :: CMDCTL_REGIONSEL_ENGR) , _ => None , } } # [doc = "MAIN"] # [inline (always)] pub fn is_cmdctl_regionsel_main (& self) -> bool { * self == CMDCTL_REGIONSEL_A :: CMDCTL_REGIONSEL_MAIN } # [doc = "NONMAIN"] # [inline (always)] pub fn is_cmdctl_regionsel_nonmain (& self) -> bool { * self == CMDCTL_REGIONSEL_A :: CMDCTL_REGIONSEL_NONMAIN } # [doc = "TRIM"] # [inline (always)] pub fn is_cmdctl_regionsel_trim (& self) -> bool { * self == CMDCTL_REGIONSEL_A :: CMDCTL_REGIONSEL_TRIM } # [doc = "ENGR"] # [inline (always)] pub fn is_cmdctl_regionsel_engr (& self) -> bool { * self == CMDCTL_REGIONSEL_A :: CMDCTL_REGIONSEL_ENGR } } # [doc = "Field `CMDCTL_REGIONSEL` writer - Bank Region A specific region ID can be written to this field to indicate to which region an operation should be applied if CMDCTL.ADDRXLATEOVR is set."] pub type CMDCTL_REGIONSEL_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 4 , O , CMDCTL_REGIONSEL_A > ; impl < 'a , REG , const O : u8 > CMDCTL_REGIONSEL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "MAIN"] # [inline (always)] pub fn cmdctl_regionsel_main (self) -> & 'a mut crate :: W < REG > { self . variant (CMDCTL_REGIONSEL_A :: CMDCTL_REGIONSEL_MAIN) } # [doc = "NONMAIN"] # [inline (always)] pub fn cmdctl_regionsel_nonmain (self) -> & 'a mut crate :: W < REG > { self . variant (CMDCTL_REGIONSEL_A :: CMDCTL_REGIONSEL_NONMAIN) } # [doc = "TRIM"] # [inline (always)] pub fn cmdctl_regionsel_trim (self) -> & 'a mut crate :: W < REG > { self . variant (CMDCTL_REGIONSEL_A :: CMDCTL_REGIONSEL_TRIM) } # [doc = "ENGR"] # [inline (always)] pub fn cmdctl_regionsel_engr (self) -> & 'a mut crate :: W < REG > { self . variant (CMDCTL_REGIONSEL_A :: CMDCTL_REGIONSEL_ENGR) } } # [doc = "Field `CMDCTL_ADDRXLATEOVR` reader - Override hardware address translation of address in CMDADDR from a system address to a bank address and bank ID. Use data written to CMDADDR directly as the bank address. Use the value written to CMDCTL.BANKSEL directly as the bank ID. Use the value written to CMDCTL.REGIONSEL directly as the region ID."] pub type CMDCTL_ADDRXLATEOVR_R = crate :: BitReader < CMDCTL_ADDRXLATEOVR_A > ; # [doc = "Override hardware address translation of address in CMDADDR from a system address to a bank address and bank ID. Use data written to CMDADDR directly as the bank address. Use the value written to CMDCTL.BANKSEL directly as the bank ID. Use the value written to CMDCTL.REGIONSEL directly as the region ID.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CMDCTL_ADDRXLATEOVR_A { # [doc = "0: NOOVERRIDE"] CMDCTL_ADDRXLATEOVR_NOOVERRIDE = 0 , # [doc = "1: OVERRIDE"] CMDCTL_ADDRXLATEOVR_OVERRIDE = 1 , } impl From < CMDCTL_ADDRXLATEOVR_A > for bool { # [inline (always)] fn from (variant : CMDCTL_ADDRXLATEOVR_A) -> Self { variant as u8 != 0 } } impl CMDCTL_ADDRXLATEOVR_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CMDCTL_ADDRXLATEOVR_A { match self . bits { false => CMDCTL_ADDRXLATEOVR_A :: CMDCTL_ADDRXLATEOVR_NOOVERRIDE , true => CMDCTL_ADDRXLATEOVR_A :: CMDCTL_ADDRXLATEOVR_OVERRIDE , } } # [doc = "NOOVERRIDE"] # [inline (always)] pub fn is_cmdctl_addrxlateovr_nooverride (& self) -> bool { * self == CMDCTL_ADDRXLATEOVR_A :: CMDCTL_ADDRXLATEOVR_NOOVERRIDE } # [doc = "OVERRIDE"] # [inline (always)] pub fn is_cmdctl_addrxlateovr_override (& self) -> bool { * self == CMDCTL_ADDRXLATEOVR_A :: CMDCTL_ADDRXLATEOVR_OVERRIDE } } # [doc = "Field `CMDCTL_ADDRXLATEOVR` writer - Override hardware address translation of address in CMDADDR from a system address to a bank address and bank ID. Use data written to CMDADDR directly as the bank address. Use the value written to CMDCTL.BANKSEL directly as the bank ID. Use the value written to CMDCTL.REGIONSEL directly as the region ID."] pub type CMDCTL_ADDRXLATEOVR_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CMDCTL_ADDRXLATEOVR_A > ; impl < 'a , REG , const O : u8 > CMDCTL_ADDRXLATEOVR_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NOOVERRIDE"] # [inline (always)] pub fn cmdctl_addrxlateovr_nooverride (self) -> & 'a mut crate :: W < REG > { self . variant (CMDCTL_ADDRXLATEOVR_A :: CMDCTL_ADDRXLATEOVR_NOOVERRIDE) } # [doc = "OVERRIDE"] # [inline (always)] pub fn cmdctl_addrxlateovr_override (self) -> & 'a mut crate :: W < REG > { self . variant (CMDCTL_ADDRXLATEOVR_A :: CMDCTL_ADDRXLATEOVR_OVERRIDE) } } # [doc = "Field `CMDCTL_SSERASEDIS` reader - Disable Stair-Step Erase. If set, the default VHV trim voltage setting will be used for all erase pulses. By default, this bit is reset, meaning that the VHV voltage will be stepped during successive erase pulses. The step count, step voltage, begin and end voltages are all hard-wired."] pub type CMDCTL_SSERASEDIS_R = crate :: BitReader < CMDCTL_SSERASEDIS_A > ; # [doc = "Disable Stair-Step Erase. If set, the default VHV trim voltage setting will be used for all erase pulses. By default, this bit is reset, meaning that the VHV voltage will be stepped during successive erase pulses. The step count, step voltage, begin and end voltages are all hard-wired.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CMDCTL_SSERASEDIS_A { # [doc = "0: ENABLE"] CMDCTL_SSERASEDIS_ENABLE = 0 , # [doc = "1: DISABLE"] CMDCTL_SSERASEDIS_DISABLE = 1 , } impl From < CMDCTL_SSERASEDIS_A > for bool { # [inline (always)] fn from (variant : CMDCTL_SSERASEDIS_A) -> Self { variant as u8 != 0 } } impl CMDCTL_SSERASEDIS_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CMDCTL_SSERASEDIS_A { match self . bits { false => CMDCTL_SSERASEDIS_A :: CMDCTL_SSERASEDIS_ENABLE , true => CMDCTL_SSERASEDIS_A :: CMDCTL_SSERASEDIS_DISABLE , } } # [doc = "ENABLE"] # [inline (always)] pub fn is_cmdctl_sserasedis_enable (& self) -> bool { * self == CMDCTL_SSERASEDIS_A :: CMDCTL_SSERASEDIS_ENABLE } # [doc = "DISABLE"] # [inline (always)] pub fn is_cmdctl_sserasedis_disable (& self) -> bool { * self == CMDCTL_SSERASEDIS_A :: CMDCTL_SSERASEDIS_DISABLE } } # [doc = "Field `CMDCTL_SSERASEDIS` writer - Disable Stair-Step Erase. If set, the default VHV trim voltage setting will be used for all erase pulses. By default, this bit is reset, meaning that the VHV voltage will be stepped during successive erase pulses. The step count, step voltage, begin and end voltages are all hard-wired."] pub type CMDCTL_SSERASEDIS_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CMDCTL_SSERASEDIS_A > ; impl < 'a , REG , const O : u8 > CMDCTL_SSERASEDIS_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "ENABLE"] # [inline (always)] pub fn cmdctl_sserasedis_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CMDCTL_SSERASEDIS_A :: CMDCTL_SSERASEDIS_ENABLE) } # [doc = "DISABLE"] # [inline (always)] pub fn cmdctl_sserasedis_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CMDCTL_SSERASEDIS_A :: CMDCTL_SSERASEDIS_DISABLE) } } # [doc = "Field `CMDCTL_DATAVEREN` reader - Enable invalid data verify. This checks for 0-&amp;gt;1 transitions in the memory when a program operation is initiated. If such a transition is found, the program will fail with an error without doing any programming."] pub type CMDCTL_DATAVEREN_R = crate :: BitReader < CMDCTL_DATAVEREN_A > ; # [doc = "Enable invalid data verify. This checks for 0-&amp;gt;1 transitions in the memory when a program operation is initiated. If such a transition is found, the program will fail with an error without doing any programming.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CMDCTL_DATAVEREN_A { # [doc = "0: DISABLE"] CMDCTL_DATAVEREN_DISABLE = 0 , # [doc = "1: ENABLE"] CMDCTL_DATAVEREN_ENABLE = 1 , } impl From < CMDCTL_DATAVEREN_A > for bool { # [inline (always)] fn from (variant : CMDCTL_DATAVEREN_A) -> Self { variant as u8 != 0 } } impl CMDCTL_DATAVEREN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CMDCTL_DATAVEREN_A { match self . bits { false => CMDCTL_DATAVEREN_A :: CMDCTL_DATAVEREN_DISABLE , true => CMDCTL_DATAVEREN_A :: CMDCTL_DATAVEREN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_cmdctl_dataveren_disable (& self) -> bool { * self == CMDCTL_DATAVEREN_A :: CMDCTL_DATAVEREN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_cmdctl_dataveren_enable (& self) -> bool { * self == CMDCTL_DATAVEREN_A :: CMDCTL_DATAVEREN_ENABLE } } # [doc = "Field `CMDCTL_DATAVEREN` writer - Enable invalid data verify. This checks for 0-&amp;gt;1 transitions in the memory when a program operation is initiated. If such a transition is found, the program will fail with an error without doing any programming."] pub type CMDCTL_DATAVEREN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CMDCTL_DATAVEREN_A > ; impl < 'a , REG , const O : u8 > CMDCTL_DATAVEREN_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn cmdctl_dataveren_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CMDCTL_DATAVEREN_A :: CMDCTL_DATAVEREN_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn cmdctl_dataveren_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CMDCTL_DATAVEREN_A :: CMDCTL_DATAVEREN_ENABLE) } } impl R { # [doc = "Bits 0:3 - Mode This field is only used for the Mode Change command type. Otherwise, bank and pump modes are set automaticlly via the NW hardware."] # [inline (always)] pub fn cmdctl_modesel (& self) -> CMDCTL_MODESEL_R { CMDCTL_MODESEL_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bits 9:12 - Bank Region A specific region ID can be written to this field to indicate to which region an operation should be applied if CMDCTL.ADDRXLATEOVR is set."] # [inline (always)] pub fn cmdctl_regionsel (& self) -> CMDCTL_REGIONSEL_R { CMDCTL_REGIONSEL_R :: new (((self . bits >> 9) & 0x0f) as u8) } # [doc = "Bit 16 - Override hardware address translation of address in CMDADDR from a system address to a bank address and bank ID. Use data written to CMDADDR directly as the bank address. Use the value written to CMDCTL.BANKSEL directly as the bank ID. Use the value written to CMDCTL.REGIONSEL directly as the region ID."] # [inline (always)] pub fn cmdctl_addrxlateovr (& self) -> CMDCTL_ADDRXLATEOVR_R { CMDCTL_ADDRXLATEOVR_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 20 - Disable Stair-Step Erase. If set, the default VHV trim voltage setting will be used for all erase pulses. By default, this bit is reset, meaning that the VHV voltage will be stepped during successive erase pulses. The step count, step voltage, begin and end voltages are all hard-wired."] # [inline (always)] pub fn cmdctl_sserasedis (& self) -> CMDCTL_SSERASEDIS_R { CMDCTL_SSERASEDIS_R :: new (((self . bits >> 20) & 1) != 0) } # [doc = "Bit 21 - Enable invalid data verify. This checks for 0-&amp;gt;1 transitions in the memory when a program operation is initiated. If such a transition is found, the program will fail with an error without doing any programming."] # [inline (always)] pub fn cmdctl_dataveren (& self) -> CMDCTL_DATAVEREN_R { CMDCTL_DATAVEREN_R :: new (((self . bits >> 21) & 1) != 0) } } impl W { # [doc = "Bits 0:3 - Mode This field is only used for the Mode Change command type. Otherwise, bank and pump modes are set automaticlly via the NW hardware."] # [inline (always)] # [must_use] pub fn cmdctl_modesel (& mut self) -> CMDCTL_MODESEL_W < CMDCTL_SPEC , 0 > { CMDCTL_MODESEL_W :: new (self) } # [doc = "Bits 9:12 - Bank Region A specific region ID can be written to this field to indicate to which region an operation should be applied if CMDCTL.ADDRXLATEOVR is set."] # [inline (always)] # [must_use] pub fn cmdctl_regionsel (& mut self) -> CMDCTL_REGIONSEL_W < CMDCTL_SPEC , 9 > { CMDCTL_REGIONSEL_W :: new (self) } # [doc = "Bit 16 - Override hardware address translation of address in CMDADDR from a system address to a bank address and bank ID. Use data written to CMDADDR directly as the bank address. Use the value written to CMDCTL.BANKSEL directly as the bank ID. Use the value written to CMDCTL.REGIONSEL directly as the region ID."] # [inline (always)] # [must_use] pub fn cmdctl_addrxlateovr (& mut self) -> CMDCTL_ADDRXLATEOVR_W < CMDCTL_SPEC , 16 > { CMDCTL_ADDRXLATEOVR_W :: new (self) } # [doc = "Bit 20 - Disable Stair-Step Erase. If set, the default VHV trim voltage setting will be used for all erase pulses. By default, this bit is reset, meaning that the VHV voltage will be stepped during successive erase pulses. The step count, step voltage, begin and end voltages are all hard-wired."] # [inline (always)] # [must_use] pub fn cmdctl_sserasedis (& mut self) -> CMDCTL_SSERASEDIS_W < CMDCTL_SPEC , 20 > { CMDCTL_SSERASEDIS_W :: new (self) } # [doc = "Bit 21 - Enable invalid data verify. This checks for 0-&amp;gt;1 transitions in the memory when a program operation is initiated. If such a transition is found, the program will fail with an error without doing any programming."] # [inline (always)] # [must_use] pub fn cmdctl_dataveren (& mut self) -> CMDCTL_DATAVEREN_W < CMDCTL_SPEC , 21 > { CMDCTL_DATAVEREN_W :: new (self) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Command Control Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cmdctl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cmdctl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CMDCTL_SPEC ; impl crate :: RegisterSpec for CMDCTL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cmdctl::R`](R) reader structure"] impl crate :: Readable for CMDCTL_SPEC { } # [doc = "`write(|w| ..)` method takes [`cmdctl::W`](W) writer structure"] impl crate :: Writable for CMDCTL_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CMDCTL to value 0"] impl crate :: Resettable for CMDCTL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }