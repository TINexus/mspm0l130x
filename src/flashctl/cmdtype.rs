# [doc = "Register `CMDTYPE` reader"] pub type R = crate :: R < CMDTYPE_SPEC > ; # [doc = "Register `CMDTYPE` writer"] pub type W = crate :: W < CMDTYPE_SPEC > ; # [doc = "Field `CMDTYPE_COMMAND` reader - Command type"] pub type CMDTYPE_COMMAND_R = crate :: FieldReader < CMDTYPE_COMMAND_A > ; # [doc = "Command type\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CMDTYPE_COMMAND_A { # [doc = "0: NOOP"] CMDTYPE_COMMAND_NOOP = 0 , # [doc = "1: PROGRAM"] CMDTYPE_COMMAND_PROGRAM = 1 , # [doc = "2: ERASE"] CMDTYPE_COMMAND_ERASE = 2 , # [doc = "3: READVERIFY"] CMDTYPE_COMMAND_READVERIFY = 3 , # [doc = "4: MODECHANGE"] CMDTYPE_COMMAND_MODECHANGE = 4 , # [doc = "5: CLEARSTATUS"] CMDTYPE_COMMAND_CLEARSTATUS = 5 , # [doc = "6: BLANKVERIFY"] CMDTYPE_COMMAND_BLANKVERIFY = 6 , } impl From < CMDTYPE_COMMAND_A > for u8 { # [inline (always)] fn from (variant : CMDTYPE_COMMAND_A) -> Self { variant as _ } } impl crate :: FieldSpec for CMDTYPE_COMMAND_A { type Ux = u8 ; } impl CMDTYPE_COMMAND_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CMDTYPE_COMMAND_A > { match self . bits { 0 => Some (CMDTYPE_COMMAND_A :: CMDTYPE_COMMAND_NOOP) , 1 => Some (CMDTYPE_COMMAND_A :: CMDTYPE_COMMAND_PROGRAM) , 2 => Some (CMDTYPE_COMMAND_A :: CMDTYPE_COMMAND_ERASE) , 3 => Some (CMDTYPE_COMMAND_A :: CMDTYPE_COMMAND_READVERIFY) , 4 => Some (CMDTYPE_COMMAND_A :: CMDTYPE_COMMAND_MODECHANGE) , 5 => Some (CMDTYPE_COMMAND_A :: CMDTYPE_COMMAND_CLEARSTATUS) , 6 => Some (CMDTYPE_COMMAND_A :: CMDTYPE_COMMAND_BLANKVERIFY) , _ => None , } } # [doc = "NOOP"] # [inline (always)] pub fn is_cmdtype_command_noop (& self) -> bool { * self == CMDTYPE_COMMAND_A :: CMDTYPE_COMMAND_NOOP } # [doc = "PROGRAM"] # [inline (always)] pub fn is_cmdtype_command_program (& self) -> bool { * self == CMDTYPE_COMMAND_A :: CMDTYPE_COMMAND_PROGRAM } # [doc = "ERASE"] # [inline (always)] pub fn is_cmdtype_command_erase (& self) -> bool { * self == CMDTYPE_COMMAND_A :: CMDTYPE_COMMAND_ERASE } # [doc = "READVERIFY"] # [inline (always)] pub fn is_cmdtype_command_readverify (& self) -> bool { * self == CMDTYPE_COMMAND_A :: CMDTYPE_COMMAND_READVERIFY } # [doc = "MODECHANGE"] # [inline (always)] pub fn is_cmdtype_command_modechange (& self) -> bool { * self == CMDTYPE_COMMAND_A :: CMDTYPE_COMMAND_MODECHANGE } # [doc = "CLEARSTATUS"] # [inline (always)] pub fn is_cmdtype_command_clearstatus (& self) -> bool { * self == CMDTYPE_COMMAND_A :: CMDTYPE_COMMAND_CLEARSTATUS } # [doc = "BLANKVERIFY"] # [inline (always)] pub fn is_cmdtype_command_blankverify (& self) -> bool { * self == CMDTYPE_COMMAND_A :: CMDTYPE_COMMAND_BLANKVERIFY } } # [doc = "Field `CMDTYPE_COMMAND` writer - Command type"] pub type CMDTYPE_COMMAND_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 3 , O , CMDTYPE_COMMAND_A > ; impl < 'a , REG , const O : u8 > CMDTYPE_COMMAND_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "NOOP"] # [inline (always)] pub fn cmdtype_command_noop (self) -> & 'a mut crate :: W < REG > { self . variant (CMDTYPE_COMMAND_A :: CMDTYPE_COMMAND_NOOP) } # [doc = "PROGRAM"] # [inline (always)] pub fn cmdtype_command_program (self) -> & 'a mut crate :: W < REG > { self . variant (CMDTYPE_COMMAND_A :: CMDTYPE_COMMAND_PROGRAM) } # [doc = "ERASE"] # [inline (always)] pub fn cmdtype_command_erase (self) -> & 'a mut crate :: W < REG > { self . variant (CMDTYPE_COMMAND_A :: CMDTYPE_COMMAND_ERASE) } # [doc = "READVERIFY"] # [inline (always)] pub fn cmdtype_command_readverify (self) -> & 'a mut crate :: W < REG > { self . variant (CMDTYPE_COMMAND_A :: CMDTYPE_COMMAND_READVERIFY) } # [doc = "MODECHANGE"] # [inline (always)] pub fn cmdtype_command_modechange (self) -> & 'a mut crate :: W < REG > { self . variant (CMDTYPE_COMMAND_A :: CMDTYPE_COMMAND_MODECHANGE) } # [doc = "CLEARSTATUS"] # [inline (always)] pub fn cmdtype_command_clearstatus (self) -> & 'a mut crate :: W < REG > { self . variant (CMDTYPE_COMMAND_A :: CMDTYPE_COMMAND_CLEARSTATUS) } # [doc = "BLANKVERIFY"] # [inline (always)] pub fn cmdtype_command_blankverify (self) -> & 'a mut crate :: W < REG > { self . variant (CMDTYPE_COMMAND_A :: CMDTYPE_COMMAND_BLANKVERIFY) } } # [doc = "Field `CMDTYPE_SIZE` reader - Command size"] pub type CMDTYPE_SIZE_R = crate :: FieldReader < CMDTYPE_SIZE_A > ; # [doc = "Command size\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CMDTYPE_SIZE_A { # [doc = "0: ONEWORD"] CMDTYPE_SIZE_ONEWORD = 0 , # [doc = "1: TWOWORD"] CMDTYPE_SIZE_TWOWORD = 1 , # [doc = "2: FOURWORD"] CMDTYPE_SIZE_FOURWORD = 2 , # [doc = "3: EIGHTWORD"] CMDTYPE_SIZE_EIGHTWORD = 3 , # [doc = "4: SECTOR"] CMDTYPE_SIZE_SECTOR = 4 , # [doc = "5: BANK"] CMDTYPE_SIZE_BANK = 5 , } impl From < CMDTYPE_SIZE_A > for u8 { # [inline (always)] fn from (variant : CMDTYPE_SIZE_A) -> Self { variant as _ } } impl crate :: FieldSpec for CMDTYPE_SIZE_A { type Ux = u8 ; } impl CMDTYPE_SIZE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CMDTYPE_SIZE_A > { match self . bits { 0 => Some (CMDTYPE_SIZE_A :: CMDTYPE_SIZE_ONEWORD) , 1 => Some (CMDTYPE_SIZE_A :: CMDTYPE_SIZE_TWOWORD) , 2 => Some (CMDTYPE_SIZE_A :: CMDTYPE_SIZE_FOURWORD) , 3 => Some (CMDTYPE_SIZE_A :: CMDTYPE_SIZE_EIGHTWORD) , 4 => Some (CMDTYPE_SIZE_A :: CMDTYPE_SIZE_SECTOR) , 5 => Some (CMDTYPE_SIZE_A :: CMDTYPE_SIZE_BANK) , _ => None , } } # [doc = "ONEWORD"] # [inline (always)] pub fn is_cmdtype_size_oneword (& self) -> bool { * self == CMDTYPE_SIZE_A :: CMDTYPE_SIZE_ONEWORD } # [doc = "TWOWORD"] # [inline (always)] pub fn is_cmdtype_size_twoword (& self) -> bool { * self == CMDTYPE_SIZE_A :: CMDTYPE_SIZE_TWOWORD } # [doc = "FOURWORD"] # [inline (always)] pub fn is_cmdtype_size_fourword (& self) -> bool { * self == CMDTYPE_SIZE_A :: CMDTYPE_SIZE_FOURWORD } # [doc = "EIGHTWORD"] # [inline (always)] pub fn is_cmdtype_size_eightword (& self) -> bool { * self == CMDTYPE_SIZE_A :: CMDTYPE_SIZE_EIGHTWORD } # [doc = "SECTOR"] # [inline (always)] pub fn is_cmdtype_size_sector (& self) -> bool { * self == CMDTYPE_SIZE_A :: CMDTYPE_SIZE_SECTOR } # [doc = "BANK"] # [inline (always)] pub fn is_cmdtype_size_bank (& self) -> bool { * self == CMDTYPE_SIZE_A :: CMDTYPE_SIZE_BANK } } # [doc = "Field `CMDTYPE_SIZE` writer - Command size"] pub type CMDTYPE_SIZE_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 3 , O , CMDTYPE_SIZE_A > ; impl < 'a , REG , const O : u8 > CMDTYPE_SIZE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "ONEWORD"] # [inline (always)] pub fn cmdtype_size_oneword (self) -> & 'a mut crate :: W < REG > { self . variant (CMDTYPE_SIZE_A :: CMDTYPE_SIZE_ONEWORD) } # [doc = "TWOWORD"] # [inline (always)] pub fn cmdtype_size_twoword (self) -> & 'a mut crate :: W < REG > { self . variant (CMDTYPE_SIZE_A :: CMDTYPE_SIZE_TWOWORD) } # [doc = "FOURWORD"] # [inline (always)] pub fn cmdtype_size_fourword (self) -> & 'a mut crate :: W < REG > { self . variant (CMDTYPE_SIZE_A :: CMDTYPE_SIZE_FOURWORD) } # [doc = "EIGHTWORD"] # [inline (always)] pub fn cmdtype_size_eightword (self) -> & 'a mut crate :: W < REG > { self . variant (CMDTYPE_SIZE_A :: CMDTYPE_SIZE_EIGHTWORD) } # [doc = "SECTOR"] # [inline (always)] pub fn cmdtype_size_sector (self) -> & 'a mut crate :: W < REG > { self . variant (CMDTYPE_SIZE_A :: CMDTYPE_SIZE_SECTOR) } # [doc = "BANK"] # [inline (always)] pub fn cmdtype_size_bank (self) -> & 'a mut crate :: W < REG > { self . variant (CMDTYPE_SIZE_A :: CMDTYPE_SIZE_BANK) } } impl R { # [doc = "Bits 0:2 - Command type"] # [inline (always)] pub fn cmdtype_command (& self) -> CMDTYPE_COMMAND_R { CMDTYPE_COMMAND_R :: new ((self . bits & 7) as u8) } # [doc = "Bits 4:6 - Command size"] # [inline (always)] pub fn cmdtype_size (& self) -> CMDTYPE_SIZE_R { CMDTYPE_SIZE_R :: new (((self . bits >> 4) & 7) as u8) } } impl W { # [doc = "Bits 0:2 - Command type"] # [inline (always)] # [must_use] pub fn cmdtype_command (& mut self) -> CMDTYPE_COMMAND_W < CMDTYPE_SPEC , 0 > { CMDTYPE_COMMAND_W :: new (self) } # [doc = "Bits 4:6 - Command size"] # [inline (always)] # [must_use] pub fn cmdtype_size (& mut self) -> CMDTYPE_SIZE_W < CMDTYPE_SPEC , 4 > { CMDTYPE_SIZE_W :: new (self) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Command Type Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cmdtype::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cmdtype::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CMDTYPE_SPEC ; impl crate :: RegisterSpec for CMDTYPE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cmdtype::R`](R) reader structure"] impl crate :: Readable for CMDTYPE_SPEC { } # [doc = "`write(|w| ..)` method takes [`cmdtype::W`](W) writer structure"] impl crate :: Writable for CMDTYPE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CMDTYPE to value 0"] impl crate :: Resettable for CMDTYPE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }