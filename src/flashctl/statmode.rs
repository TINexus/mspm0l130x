# [doc = "Register `STATMODE` reader"] pub type R = crate :: R < STATMODE_SPEC > ; # [doc = "Field `STATMODE_BANKNOTINRD` reader - Bank not in read mode. Indicates which banks are not in READ mode. There is 1 bit per bank."] pub type STATMODE_BANKNOTINRD_R = crate :: BitReader < STATMODE_BANKNOTINRD_A > ; # [doc = "Bank not in read mode. Indicates which banks are not in READ mode. There is 1 bit per bank.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum STATMODE_BANKNOTINRD_A { # [doc = "1: BANK0"] STATMODE_BANKNOTINRD_BANK0 = 1 , } impl From < STATMODE_BANKNOTINRD_A > for bool { # [inline (always)] fn from (variant : STATMODE_BANKNOTINRD_A) -> Self { variant as u8 != 0 } } impl STATMODE_BANKNOTINRD_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < STATMODE_BANKNOTINRD_A > { match self . bits { true => Some (STATMODE_BANKNOTINRD_A :: STATMODE_BANKNOTINRD_BANK0) , _ => None , } } # [doc = "BANK0"] # [inline (always)] pub fn is_statmode_banknotinrd_bank0 (& self) -> bool { * self == STATMODE_BANKNOTINRD_A :: STATMODE_BANKNOTINRD_BANK0 } } # [doc = "Field `STATMODE_BANKMODE` reader - Indicates mode of bank(s) that are not in READ mode"] pub type STATMODE_BANKMODE_R = crate :: FieldReader < STATMODE_BANKMODE_A > ; # [doc = "Indicates mode of bank(s) that are not in READ mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum STATMODE_BANKMODE_A { # [doc = "0: READ"] STATMODE_BANKMODE_READ = 0 , # [doc = "2: RDMARG0"] STATMODE_BANKMODE_RDMARG0 = 2 , # [doc = "4: RDMARG1"] STATMODE_BANKMODE_RDMARG1 = 4 , # [doc = "6: RDMARG0B"] STATMODE_BANKMODE_RDMARG0B = 6 , # [doc = "7: RDMARG1B"] STATMODE_BANKMODE_RDMARG1B = 7 , # [doc = "9: PGMVER"] STATMODE_BANKMODE_PGMVER = 9 , # [doc = "10: PGMSW"] STATMODE_BANKMODE_PGMSW = 10 , # [doc = "11: ERASEVER"] STATMODE_BANKMODE_ERASEVER = 11 , # [doc = "12: ERASESECT"] STATMODE_BANKMODE_ERASESECT = 12 , # [doc = "14: PGMMW"] STATMODE_BANKMODE_PGMMW = 14 , # [doc = "15: ERASEBNK"] STATMODE_BANKMODE_ERASEBNK = 15 , } impl From < STATMODE_BANKMODE_A > for u8 { # [inline (always)] fn from (variant : STATMODE_BANKMODE_A) -> Self { variant as _ } } impl crate :: FieldSpec for STATMODE_BANKMODE_A { type Ux = u8 ; } impl STATMODE_BANKMODE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < STATMODE_BANKMODE_A > { match self . bits { 0 => Some (STATMODE_BANKMODE_A :: STATMODE_BANKMODE_READ) , 2 => Some (STATMODE_BANKMODE_A :: STATMODE_BANKMODE_RDMARG0) , 4 => Some (STATMODE_BANKMODE_A :: STATMODE_BANKMODE_RDMARG1) , 6 => Some (STATMODE_BANKMODE_A :: STATMODE_BANKMODE_RDMARG0B) , 7 => Some (STATMODE_BANKMODE_A :: STATMODE_BANKMODE_RDMARG1B) , 9 => Some (STATMODE_BANKMODE_A :: STATMODE_BANKMODE_PGMVER) , 10 => Some (STATMODE_BANKMODE_A :: STATMODE_BANKMODE_PGMSW) , 11 => Some (STATMODE_BANKMODE_A :: STATMODE_BANKMODE_ERASEVER) , 12 => Some (STATMODE_BANKMODE_A :: STATMODE_BANKMODE_ERASESECT) , 14 => Some (STATMODE_BANKMODE_A :: STATMODE_BANKMODE_PGMMW) , 15 => Some (STATMODE_BANKMODE_A :: STATMODE_BANKMODE_ERASEBNK) , _ => None , } } # [doc = "READ"] # [inline (always)] pub fn is_statmode_bankmode_read (& self) -> bool { * self == STATMODE_BANKMODE_A :: STATMODE_BANKMODE_READ } # [doc = "RDMARG0"] # [inline (always)] pub fn is_statmode_bankmode_rdmarg0 (& self) -> bool { * self == STATMODE_BANKMODE_A :: STATMODE_BANKMODE_RDMARG0 } # [doc = "RDMARG1"] # [inline (always)] pub fn is_statmode_bankmode_rdmarg1 (& self) -> bool { * self == STATMODE_BANKMODE_A :: STATMODE_BANKMODE_RDMARG1 } # [doc = "RDMARG0B"] # [inline (always)] pub fn is_statmode_bankmode_rdmarg0b (& self) -> bool { * self == STATMODE_BANKMODE_A :: STATMODE_BANKMODE_RDMARG0B } # [doc = "RDMARG1B"] # [inline (always)] pub fn is_statmode_bankmode_rdmarg1b (& self) -> bool { * self == STATMODE_BANKMODE_A :: STATMODE_BANKMODE_RDMARG1B } # [doc = "PGMVER"] # [inline (always)] pub fn is_statmode_bankmode_pgmver (& self) -> bool { * self == STATMODE_BANKMODE_A :: STATMODE_BANKMODE_PGMVER } # [doc = "PGMSW"] # [inline (always)] pub fn is_statmode_bankmode_pgmsw (& self) -> bool { * self == STATMODE_BANKMODE_A :: STATMODE_BANKMODE_PGMSW } # [doc = "ERASEVER"] # [inline (always)] pub fn is_statmode_bankmode_erasever (& self) -> bool { * self == STATMODE_BANKMODE_A :: STATMODE_BANKMODE_ERASEVER } # [doc = "ERASESECT"] # [inline (always)] pub fn is_statmode_bankmode_erasesect (& self) -> bool { * self == STATMODE_BANKMODE_A :: STATMODE_BANKMODE_ERASESECT } # [doc = "PGMMW"] # [inline (always)] pub fn is_statmode_bankmode_pgmmw (& self) -> bool { * self == STATMODE_BANKMODE_A :: STATMODE_BANKMODE_PGMMW } # [doc = "ERASEBNK"] # [inline (always)] pub fn is_statmode_bankmode_erasebnk (& self) -> bool { * self == STATMODE_BANKMODE_A :: STATMODE_BANKMODE_ERASEBNK } } # [doc = "Field `STATMODE_BANK2TRDY` reader - Bank 2T Ready. Bank(s) are ready for 2T access. This is accomplished when the pump has fully driven power rails to the bank(s)."] pub type STATMODE_BANK2TRDY_R = crate :: BitReader < STATMODE_BANK2TRDY_A > ; # [doc = "Bank 2T Ready. Bank(s) are ready for 2T access. This is accomplished when the pump has fully driven power rails to the bank(s).\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum STATMODE_BANK2TRDY_A { # [doc = "0: FALSE"] STATMODE_BANK2TRDY_FALSE = 0 , # [doc = "1: TRUE"] STATMODE_BANK2TRDY_TRUE = 1 , } impl From < STATMODE_BANK2TRDY_A > for bool { # [inline (always)] fn from (variant : STATMODE_BANK2TRDY_A) -> Self { variant as u8 != 0 } } impl STATMODE_BANK2TRDY_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> STATMODE_BANK2TRDY_A { match self . bits { false => STATMODE_BANK2TRDY_A :: STATMODE_BANK2TRDY_FALSE , true => STATMODE_BANK2TRDY_A :: STATMODE_BANK2TRDY_TRUE , } } # [doc = "FALSE"] # [inline (always)] pub fn is_statmode_bank2trdy_false (& self) -> bool { * self == STATMODE_BANK2TRDY_A :: STATMODE_BANK2TRDY_FALSE } # [doc = "TRUE"] # [inline (always)] pub fn is_statmode_bank2trdy_true (& self) -> bool { * self == STATMODE_BANK2TRDY_A :: STATMODE_BANK2TRDY_TRUE } } # [doc = "Field `STATMODE_BANK1TRDY` reader - Bank 1T Ready. Bank(s) are ready for 1T access. This is accomplished when the bank and pump have been trimmed."] pub type STATMODE_BANK1TRDY_R = crate :: BitReader < STATMODE_BANK1TRDY_A > ; # [doc = "Bank 1T Ready. Bank(s) are ready for 1T access. This is accomplished when the bank and pump have been trimmed.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum STATMODE_BANK1TRDY_A { # [doc = "0: FALSE"] STATMODE_BANK1TRDY_FALSE = 0 , # [doc = "1: TRUE"] STATMODE_BANK1TRDY_TRUE = 1 , } impl From < STATMODE_BANK1TRDY_A > for bool { # [inline (always)] fn from (variant : STATMODE_BANK1TRDY_A) -> Self { variant as u8 != 0 } } impl STATMODE_BANK1TRDY_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> STATMODE_BANK1TRDY_A { match self . bits { false => STATMODE_BANK1TRDY_A :: STATMODE_BANK1TRDY_FALSE , true => STATMODE_BANK1TRDY_A :: STATMODE_BANK1TRDY_TRUE , } } # [doc = "FALSE"] # [inline (always)] pub fn is_statmode_bank1trdy_false (& self) -> bool { * self == STATMODE_BANK1TRDY_A :: STATMODE_BANK1TRDY_FALSE } # [doc = "TRUE"] # [inline (always)] pub fn is_statmode_bank1trdy_true (& self) -> bool { * self == STATMODE_BANK1TRDY_A :: STATMODE_BANK1TRDY_TRUE } } impl R { # [doc = "Bit 0 - Bank not in read mode. Indicates which banks are not in READ mode. There is 1 bit per bank."] # [inline (always)] pub fn statmode_banknotinrd (& self) -> STATMODE_BANKNOTINRD_R { STATMODE_BANKNOTINRD_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 8:11 - Indicates mode of bank(s) that are not in READ mode"] # [inline (always)] pub fn statmode_bankmode (& self) -> STATMODE_BANKMODE_R { STATMODE_BANKMODE_R :: new (((self . bits >> 8) & 0x0f) as u8) } # [doc = "Bit 16 - Bank 2T Ready. Bank(s) are ready for 2T access. This is accomplished when the pump has fully driven power rails to the bank(s)."] # [inline (always)] pub fn statmode_bank2trdy (& self) -> STATMODE_BANK2TRDY_R { STATMODE_BANK2TRDY_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Bank 1T Ready. Bank(s) are ready for 1T access. This is accomplished when the bank and pump have been trimmed."] # [inline (always)] pub fn statmode_bank1trdy (& self) -> STATMODE_BANK1TRDY_R { STATMODE_BANK1TRDY_R :: new (((self . bits >> 17) & 1) != 0) } } # [doc = "Mode Status Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`statmode::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct STATMODE_SPEC ; impl crate :: RegisterSpec for STATMODE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`statmode::R`](R) reader structure"] impl crate :: Readable for STATMODE_SPEC { } # [doc = "`reset()` method sets STATMODE to value 0"] impl crate :: Resettable for STATMODE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }