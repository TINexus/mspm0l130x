# [doc = "Register `TSEL` reader"] pub type R = crate :: R < TSEL_SPEC > ; # [doc = "Register `TSEL` writer"] pub type W = crate :: W < TSEL_SPEC > ; # [doc = "Field `TSEL_ETSEL` reader - External Trigger Select. #br# This selects which System Event is used if the input filter selects trigger. Triggers 0-15 are used to connect triggers generated by other timer modules in the same power domain. Refer to the SoC datasheet to get details. Triggers 16 and 17 are connected to event manager subscriber ports. Event lines 18-31 are reserved for future use."] pub type TSEL_ETSEL_R = crate :: FieldReader < TSEL_ETSEL_A > ; # [doc = "External Trigger Select. #br# This selects which System Event is used if the input filter selects trigger. Triggers 0-15 are used to connect triggers generated by other timer modules in the same power domain. Refer to the SoC datasheet to get details. Triggers 16 and 17 are connected to event manager subscriber ports. Event lines 18-31 are reserved for future use.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum TSEL_ETSEL_A { # [doc = "0: TRIG0"] TSEL_ETSEL_TRIG0 = 0 , # [doc = "1: TRIG1"] TSEL_ETSEL_TRIG1 = 1 , # [doc = "2: TRIG2"] TSEL_ETSEL_TRIG2 = 2 , # [doc = "3: TRIG3"] TSEL_ETSEL_TRIG3 = 3 , # [doc = "4: TRIG4"] TSEL_ETSEL_TRIG4 = 4 , # [doc = "5: TRIG5"] TSEL_ETSEL_TRIG5 = 5 , # [doc = "6: TRIG6"] TSEL_ETSEL_TRIG6 = 6 , # [doc = "7: TRIG7"] TSEL_ETSEL_TRIG7 = 7 , # [doc = "8: TRIG8"] TSEL_ETSEL_TRIG8 = 8 , # [doc = "9: TRIG9"] TSEL_ETSEL_TRIG9 = 9 , # [doc = "10: TRIG10"] TSEL_ETSEL_TRIG10 = 10 , # [doc = "11: TRIG11"] TSEL_ETSEL_TRIG11 = 11 , # [doc = "12: TRIG12"] TSEL_ETSEL_TRIG12 = 12 , # [doc = "13: TRIG13"] TSEL_ETSEL_TRIG13 = 13 , # [doc = "14: TRIG14"] TSEL_ETSEL_TRIG14 = 14 , # [doc = "15: TRIG15"] TSEL_ETSEL_TRIG15 = 15 , # [doc = "16: TRIG_SUB0"] TSEL_ETSEL_TRIG_SUB0 = 16 , # [doc = "17: TRIG_SUB1"] TSEL_ETSEL_TRIG_SUB1 = 17 , } impl From < TSEL_ETSEL_A > for u8 { # [inline (always)] fn from (variant : TSEL_ETSEL_A) -> Self { variant as _ } } impl crate :: FieldSpec for TSEL_ETSEL_A { type Ux = u8 ; } impl TSEL_ETSEL_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < TSEL_ETSEL_A > { match self . bits { 0 => Some (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG0) , 1 => Some (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG1) , 2 => Some (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG2) , 3 => Some (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG3) , 4 => Some (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG4) , 5 => Some (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG5) , 6 => Some (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG6) , 7 => Some (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG7) , 8 => Some (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG8) , 9 => Some (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG9) , 10 => Some (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG10) , 11 => Some (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG11) , 12 => Some (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG12) , 13 => Some (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG13) , 14 => Some (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG14) , 15 => Some (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG15) , 16 => Some (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG_SUB0) , 17 => Some (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG_SUB1) , _ => None , } } # [doc = "TRIG0"] # [inline (always)] pub fn is_tsel_etsel_trig0 (& self) -> bool { * self == TSEL_ETSEL_A :: TSEL_ETSEL_TRIG0 } # [doc = "TRIG1"] # [inline (always)] pub fn is_tsel_etsel_trig1 (& self) -> bool { * self == TSEL_ETSEL_A :: TSEL_ETSEL_TRIG1 } # [doc = "TRIG2"] # [inline (always)] pub fn is_tsel_etsel_trig2 (& self) -> bool { * self == TSEL_ETSEL_A :: TSEL_ETSEL_TRIG2 } # [doc = "TRIG3"] # [inline (always)] pub fn is_tsel_etsel_trig3 (& self) -> bool { * self == TSEL_ETSEL_A :: TSEL_ETSEL_TRIG3 } # [doc = "TRIG4"] # [inline (always)] pub fn is_tsel_etsel_trig4 (& self) -> bool { * self == TSEL_ETSEL_A :: TSEL_ETSEL_TRIG4 } # [doc = "TRIG5"] # [inline (always)] pub fn is_tsel_etsel_trig5 (& self) -> bool { * self == TSEL_ETSEL_A :: TSEL_ETSEL_TRIG5 } # [doc = "TRIG6"] # [inline (always)] pub fn is_tsel_etsel_trig6 (& self) -> bool { * self == TSEL_ETSEL_A :: TSEL_ETSEL_TRIG6 } # [doc = "TRIG7"] # [inline (always)] pub fn is_tsel_etsel_trig7 (& self) -> bool { * self == TSEL_ETSEL_A :: TSEL_ETSEL_TRIG7 } # [doc = "TRIG8"] # [inline (always)] pub fn is_tsel_etsel_trig8 (& self) -> bool { * self == TSEL_ETSEL_A :: TSEL_ETSEL_TRIG8 } # [doc = "TRIG9"] # [inline (always)] pub fn is_tsel_etsel_trig9 (& self) -> bool { * self == TSEL_ETSEL_A :: TSEL_ETSEL_TRIG9 } # [doc = "TRIG10"] # [inline (always)] pub fn is_tsel_etsel_trig10 (& self) -> bool { * self == TSEL_ETSEL_A :: TSEL_ETSEL_TRIG10 } # [doc = "TRIG11"] # [inline (always)] pub fn is_tsel_etsel_trig11 (& self) -> bool { * self == TSEL_ETSEL_A :: TSEL_ETSEL_TRIG11 } # [doc = "TRIG12"] # [inline (always)] pub fn is_tsel_etsel_trig12 (& self) -> bool { * self == TSEL_ETSEL_A :: TSEL_ETSEL_TRIG12 } # [doc = "TRIG13"] # [inline (always)] pub fn is_tsel_etsel_trig13 (& self) -> bool { * self == TSEL_ETSEL_A :: TSEL_ETSEL_TRIG13 } # [doc = "TRIG14"] # [inline (always)] pub fn is_tsel_etsel_trig14 (& self) -> bool { * self == TSEL_ETSEL_A :: TSEL_ETSEL_TRIG14 } # [doc = "TRIG15"] # [inline (always)] pub fn is_tsel_etsel_trig15 (& self) -> bool { * self == TSEL_ETSEL_A :: TSEL_ETSEL_TRIG15 } # [doc = "TRIG_SUB0"] # [inline (always)] pub fn is_tsel_etsel_trig_sub0 (& self) -> bool { * self == TSEL_ETSEL_A :: TSEL_ETSEL_TRIG_SUB0 } # [doc = "TRIG_SUB1"] # [inline (always)] pub fn is_tsel_etsel_trig_sub1 (& self) -> bool { * self == TSEL_ETSEL_A :: TSEL_ETSEL_TRIG_SUB1 } } # [doc = "Field `TSEL_ETSEL` writer - External Trigger Select. #br# This selects which System Event is used if the input filter selects trigger. Triggers 0-15 are used to connect triggers generated by other timer modules in the same power domain. Refer to the SoC datasheet to get details. Triggers 16 and 17 are connected to event manager subscriber ports. Event lines 18-31 are reserved for future use."] pub type TSEL_ETSEL_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 5 , O , TSEL_ETSEL_A > ; impl < 'a , REG , const O : u8 > TSEL_ETSEL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "TRIG0"] # [inline (always)] pub fn tsel_etsel_trig0 (self) -> & 'a mut crate :: W < REG > { self . variant (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG0) } # [doc = "TRIG1"] # [inline (always)] pub fn tsel_etsel_trig1 (self) -> & 'a mut crate :: W < REG > { self . variant (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG1) } # [doc = "TRIG2"] # [inline (always)] pub fn tsel_etsel_trig2 (self) -> & 'a mut crate :: W < REG > { self . variant (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG2) } # [doc = "TRIG3"] # [inline (always)] pub fn tsel_etsel_trig3 (self) -> & 'a mut crate :: W < REG > { self . variant (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG3) } # [doc = "TRIG4"] # [inline (always)] pub fn tsel_etsel_trig4 (self) -> & 'a mut crate :: W < REG > { self . variant (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG4) } # [doc = "TRIG5"] # [inline (always)] pub fn tsel_etsel_trig5 (self) -> & 'a mut crate :: W < REG > { self . variant (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG5) } # [doc = "TRIG6"] # [inline (always)] pub fn tsel_etsel_trig6 (self) -> & 'a mut crate :: W < REG > { self . variant (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG6) } # [doc = "TRIG7"] # [inline (always)] pub fn tsel_etsel_trig7 (self) -> & 'a mut crate :: W < REG > { self . variant (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG7) } # [doc = "TRIG8"] # [inline (always)] pub fn tsel_etsel_trig8 (self) -> & 'a mut crate :: W < REG > { self . variant (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG8) } # [doc = "TRIG9"] # [inline (always)] pub fn tsel_etsel_trig9 (self) -> & 'a mut crate :: W < REG > { self . variant (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG9) } # [doc = "TRIG10"] # [inline (always)] pub fn tsel_etsel_trig10 (self) -> & 'a mut crate :: W < REG > { self . variant (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG10) } # [doc = "TRIG11"] # [inline (always)] pub fn tsel_etsel_trig11 (self) -> & 'a mut crate :: W < REG > { self . variant (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG11) } # [doc = "TRIG12"] # [inline (always)] pub fn tsel_etsel_trig12 (self) -> & 'a mut crate :: W < REG > { self . variant (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG12) } # [doc = "TRIG13"] # [inline (always)] pub fn tsel_etsel_trig13 (self) -> & 'a mut crate :: W < REG > { self . variant (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG13) } # [doc = "TRIG14"] # [inline (always)] pub fn tsel_etsel_trig14 (self) -> & 'a mut crate :: W < REG > { self . variant (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG14) } # [doc = "TRIG15"] # [inline (always)] pub fn tsel_etsel_trig15 (self) -> & 'a mut crate :: W < REG > { self . variant (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG15) } # [doc = "TRIG_SUB0"] # [inline (always)] pub fn tsel_etsel_trig_sub0 (self) -> & 'a mut crate :: W < REG > { self . variant (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG_SUB0) } # [doc = "TRIG_SUB1"] # [inline (always)] pub fn tsel_etsel_trig_sub1 (self) -> & 'a mut crate :: W < REG > { self . variant (TSEL_ETSEL_A :: TSEL_ETSEL_TRIG_SUB1) } } # [doc = "Field `TSEL_TE` reader - Trigger Enable. This selects whether a trigger is enabled or not for this counter 0x0 = Triggers are not used 0x1 = Triggers are used as selected by the ETSEL field"] pub type TSEL_TE_R = crate :: BitReader < TSEL_TE_A > ; # [doc = "Trigger Enable. This selects whether a trigger is enabled or not for this counter 0x0 = Triggers are not used 0x1 = Triggers are used as selected by the ETSEL field\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum TSEL_TE_A { # [doc = "0: DISABLED"] TSEL_TE_DISABLED = 0 , # [doc = "1: ENABLED"] TSEL_TE_ENABLED = 1 , } impl From < TSEL_TE_A > for bool { # [inline (always)] fn from (variant : TSEL_TE_A) -> Self { variant as u8 != 0 } } impl TSEL_TE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> TSEL_TE_A { match self . bits { false => TSEL_TE_A :: TSEL_TE_DISABLED , true => TSEL_TE_A :: TSEL_TE_ENABLED , } } # [doc = "DISABLED"] # [inline (always)] pub fn is_tsel_te_disabled (& self) -> bool { * self == TSEL_TE_A :: TSEL_TE_DISABLED } # [doc = "ENABLED"] # [inline (always)] pub fn is_tsel_te_enabled (& self) -> bool { * self == TSEL_TE_A :: TSEL_TE_ENABLED } } # [doc = "Field `TSEL_TE` writer - Trigger Enable. This selects whether a trigger is enabled or not for this counter 0x0 = Triggers are not used 0x1 = Triggers are used as selected by the ETSEL field"] pub type TSEL_TE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , TSEL_TE_A > ; impl < 'a , REG , const O : u8 > TSEL_TE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLED"] # [inline (always)] pub fn tsel_te_disabled (self) -> & 'a mut crate :: W < REG > { self . variant (TSEL_TE_A :: TSEL_TE_DISABLED) } # [doc = "ENABLED"] # [inline (always)] pub fn tsel_te_enabled (self) -> & 'a mut crate :: W < REG > { self . variant (TSEL_TE_A :: TSEL_TE_ENABLED) } } impl R { # [doc = "Bits 0:4 - External Trigger Select. #br# This selects which System Event is used if the input filter selects trigger. Triggers 0-15 are used to connect triggers generated by other timer modules in the same power domain. Refer to the SoC datasheet to get details. Triggers 16 and 17 are connected to event manager subscriber ports. Event lines 18-31 are reserved for future use."] # [inline (always)] pub fn tsel_etsel (& self) -> TSEL_ETSEL_R { TSEL_ETSEL_R :: new ((self . bits & 0x1f) as u8) } # [doc = "Bit 9 - Trigger Enable. This selects whether a trigger is enabled or not for this counter 0x0 = Triggers are not used 0x1 = Triggers are used as selected by the ETSEL field"] # [inline (always)] pub fn tsel_te (& self) -> TSEL_TE_R { TSEL_TE_R :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bits 0:4 - External Trigger Select. #br# This selects which System Event is used if the input filter selects trigger. Triggers 0-15 are used to connect triggers generated by other timer modules in the same power domain. Refer to the SoC datasheet to get details. Triggers 16 and 17 are connected to event manager subscriber ports. Event lines 18-31 are reserved for future use."] # [inline (always)] # [must_use] pub fn tsel_etsel (& mut self) -> TSEL_ETSEL_W < TSEL_SPEC , 0 > { TSEL_ETSEL_W :: new (self) } # [doc = "Bit 9 - Trigger Enable. This selects whether a trigger is enabled or not for this counter 0x0 = Triggers are not used 0x1 = Triggers are used as selected by the ETSEL field"] # [inline (always)] # [must_use] pub fn tsel_te (& mut self) -> TSEL_TE_W < TSEL_SPEC , 9 > { TSEL_TE_W :: new (self) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Trigger Select\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`tsel::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tsel::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TSEL_SPEC ; impl crate :: RegisterSpec for TSEL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`tsel::R`](R) reader structure"] impl crate :: Readable for TSEL_SPEC { } # [doc = "`write(|w| ..)` method takes [`tsel::W`](W) writer structure"] impl crate :: Writable for TSEL_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TSEL to value 0"] impl crate :: Resettable for TSEL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }