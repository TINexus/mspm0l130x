# [doc = "Register `CTL0` reader"] pub type R = crate :: R < CTL0_SPEC > ; # [doc = "Register `CTL0` writer"] pub type W = crate :: W < CTL0_SPEC > ; # [doc = "Field `CTL0_ENABLE` reader - UART Module Enable. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping. If the ENABLE bit is not set, all registers can still be accessed and updated. It is recommended to setup and change the UART operation mode with having the ENABLE bit cleared to avoid unpredictable behavior during the setup or update. If disabled the UART module will not send or receive any data and the logic is held in reset state."] pub type CTL0_ENABLE_R = crate :: BitReader < CTL0_ENABLE_A > ; # [doc = "UART Module Enable. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping. If the ENABLE bit is not set, all registers can still be accessed and updated. It is recommended to setup and change the UART operation mode with having the ENABLE bit cleared to avoid unpredictable behavior during the setup or update. If disabled the UART module will not send or receive any data and the logic is held in reset state.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL0_ENABLE_A { # [doc = "0: DISABLE"] CTL0_ENABLE_DISABLE = 0 , # [doc = "1: ENABLE"] CTL0_ENABLE_ENABLE = 1 , } impl From < CTL0_ENABLE_A > for bool { # [inline (always)] fn from (variant : CTL0_ENABLE_A) -> Self { variant as u8 != 0 } } impl CTL0_ENABLE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL0_ENABLE_A { match self . bits { false => CTL0_ENABLE_A :: CTL0_ENABLE_DISABLE , true => CTL0_ENABLE_A :: CTL0_ENABLE_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_ctl0_enable_disable (& self) -> bool { * self == CTL0_ENABLE_A :: CTL0_ENABLE_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_ctl0_enable_enable (& self) -> bool { * self == CTL0_ENABLE_A :: CTL0_ENABLE_ENABLE } } # [doc = "Field `CTL0_ENABLE` writer - UART Module Enable. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping. If the ENABLE bit is not set, all registers can still be accessed and updated. It is recommended to setup and change the UART operation mode with having the ENABLE bit cleared to avoid unpredictable behavior during the setup or update. If disabled the UART module will not send or receive any data and the logic is held in reset state."] pub type CTL0_ENABLE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL0_ENABLE_A > ; impl < 'a , REG , const O : u8 > CTL0_ENABLE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn ctl0_enable_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_ENABLE_A :: CTL0_ENABLE_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn ctl0_enable_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_ENABLE_A :: CTL0_ENABLE_ENABLE) } } # [doc = "Field `CTL0_LBE` reader - UART Loop Back Enable"] pub type CTL0_LBE_R = crate :: BitReader < CTL0_LBE_A > ; # [doc = "UART Loop Back Enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL0_LBE_A { # [doc = "0: DISABLE"] CTL0_LBE_DISABLE = 0 , # [doc = "1: ENABLE"] CTL0_LBE_ENABLE = 1 , } impl From < CTL0_LBE_A > for bool { # [inline (always)] fn from (variant : CTL0_LBE_A) -> Self { variant as u8 != 0 } } impl CTL0_LBE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL0_LBE_A { match self . bits { false => CTL0_LBE_A :: CTL0_LBE_DISABLE , true => CTL0_LBE_A :: CTL0_LBE_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_ctl0_lbe_disable (& self) -> bool { * self == CTL0_LBE_A :: CTL0_LBE_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_ctl0_lbe_enable (& self) -> bool { * self == CTL0_LBE_A :: CTL0_LBE_ENABLE } } # [doc = "Field `CTL0_LBE` writer - UART Loop Back Enable"] pub type CTL0_LBE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL0_LBE_A > ; impl < 'a , REG , const O : u8 > CTL0_LBE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn ctl0_lbe_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_LBE_A :: CTL0_LBE_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn ctl0_lbe_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_LBE_A :: CTL0_LBE_ENABLE) } } # [doc = "Field `CTL0_RXE` reader - UART Receive Enable If the UART is disabled in the middle of a receive, it completes the current character before stopping. #b#NOTE:#/b# To enable reception, the UARTEN bit must be set."] pub type CTL0_RXE_R = crate :: BitReader < CTL0_RXE_A > ; # [doc = "UART Receive Enable If the UART is disabled in the middle of a receive, it completes the current character before stopping. #b#NOTE:#/b# To enable reception, the UARTEN bit must be set.\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL0_RXE_A { # [doc = "0: DISABLE"] CTL0_RXE_DISABLE = 0 , # [doc = "1: ENABLE"] CTL0_RXE_ENABLE = 1 , } impl From < CTL0_RXE_A > for bool { # [inline (always)] fn from (variant : CTL0_RXE_A) -> Self { variant as u8 != 0 } } impl CTL0_RXE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL0_RXE_A { match self . bits { false => CTL0_RXE_A :: CTL0_RXE_DISABLE , true => CTL0_RXE_A :: CTL0_RXE_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_ctl0_rxe_disable (& self) -> bool { * self == CTL0_RXE_A :: CTL0_RXE_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_ctl0_rxe_enable (& self) -> bool { * self == CTL0_RXE_A :: CTL0_RXE_ENABLE } } # [doc = "Field `CTL0_RXE` writer - UART Receive Enable If the UART is disabled in the middle of a receive, it completes the current character before stopping. #b#NOTE:#/b# To enable reception, the UARTEN bit must be set."] pub type CTL0_RXE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL0_RXE_A > ; impl < 'a , REG , const O : u8 > CTL0_RXE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn ctl0_rxe_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_RXE_A :: CTL0_RXE_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn ctl0_rxe_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_RXE_A :: CTL0_RXE_ENABLE) } } # [doc = "Field `CTL0_TXE` reader - UART Transmit Enable If the UART is disabled in the middle of a transmission, it completes the current character before stopping. #b#NOTE:#/b# To enable transmission, the UARTEN bit must be set."] pub type CTL0_TXE_R = crate :: BitReader < CTL0_TXE_A > ; # [doc = "UART Transmit Enable If the UART is disabled in the middle of a transmission, it completes the current character before stopping. #b#NOTE:#/b# To enable transmission, the UARTEN bit must be set.\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL0_TXE_A { # [doc = "0: DISABLE"] CTL0_TXE_DISABLE = 0 , # [doc = "1: ENABLE"] CTL0_TXE_ENABLE = 1 , } impl From < CTL0_TXE_A > for bool { # [inline (always)] fn from (variant : CTL0_TXE_A) -> Self { variant as u8 != 0 } } impl CTL0_TXE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL0_TXE_A { match self . bits { false => CTL0_TXE_A :: CTL0_TXE_DISABLE , true => CTL0_TXE_A :: CTL0_TXE_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_ctl0_txe_disable (& self) -> bool { * self == CTL0_TXE_A :: CTL0_TXE_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_ctl0_txe_enable (& self) -> bool { * self == CTL0_TXE_A :: CTL0_TXE_ENABLE } } # [doc = "Field `CTL0_TXE` writer - UART Transmit Enable If the UART is disabled in the middle of a transmission, it completes the current character before stopping. #b#NOTE:#/b# To enable transmission, the UARTEN bit must be set."] pub type CTL0_TXE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL0_TXE_A > ; impl < 'a , REG , const O : u8 > CTL0_TXE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn ctl0_txe_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_TXE_A :: CTL0_TXE_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn ctl0_txe_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_TXE_A :: CTL0_TXE_ENABLE) } } # [doc = "Field `CTL0_TXD_OUT_EN` reader - TXD Pin Control Enable. When the transmit section of the UART is disabled (TXE = 0), the TXD pin can be controlled by the TXD_OUT bit. 1 = UARTxTXD pin can be controlled by TXD_OUT, if TXE = 0"] pub type CTL0_TXD_OUT_EN_R = crate :: BitReader < CTL0_TXD_OUT_EN_A > ; # [doc = "TXD Pin Control Enable. When the transmit section of the UART is disabled (TXE = 0), the TXD pin can be controlled by the TXD_OUT bit. 1 = UARTxTXD pin can be controlled by TXD_OUT, if TXE = 0\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL0_TXD_OUT_EN_A { # [doc = "0: DISABLE"] CTL0_TXD_OUT_EN_DISABLE = 0 , # [doc = "1: ENABLE"] CTL0_TXD_OUT_EN_ENABLE = 1 , } impl From < CTL0_TXD_OUT_EN_A > for bool { # [inline (always)] fn from (variant : CTL0_TXD_OUT_EN_A) -> Self { variant as u8 != 0 } } impl CTL0_TXD_OUT_EN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL0_TXD_OUT_EN_A { match self . bits { false => CTL0_TXD_OUT_EN_A :: CTL0_TXD_OUT_EN_DISABLE , true => CTL0_TXD_OUT_EN_A :: CTL0_TXD_OUT_EN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_ctl0_txd_out_en_disable (& self) -> bool { * self == CTL0_TXD_OUT_EN_A :: CTL0_TXD_OUT_EN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_ctl0_txd_out_en_enable (& self) -> bool { * self == CTL0_TXD_OUT_EN_A :: CTL0_TXD_OUT_EN_ENABLE } } # [doc = "Field `CTL0_TXD_OUT_EN` writer - TXD Pin Control Enable. When the transmit section of the UART is disabled (TXE = 0), the TXD pin can be controlled by the TXD_OUT bit. 1 = UARTxTXD pin can be controlled by TXD_OUT, if TXE = 0"] pub type CTL0_TXD_OUT_EN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL0_TXD_OUT_EN_A > ; impl < 'a , REG , const O : u8 > CTL0_TXD_OUT_EN_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn ctl0_txd_out_en_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_TXD_OUT_EN_A :: CTL0_TXD_OUT_EN_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn ctl0_txd_out_en_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_TXD_OUT_EN_A :: CTL0_TXD_OUT_EN_ENABLE) } } # [doc = "Field `CTL0_TXD_OUT` reader - TXD Pin Control Controls the TXD pin when TXD_OUT_EN = 1 and TXE = 0."] pub type CTL0_TXD_OUT_R = crate :: BitReader < CTL0_TXD_OUT_A > ; # [doc = "TXD Pin Control Controls the TXD pin when TXD_OUT_EN = 1 and TXE = 0.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL0_TXD_OUT_A { # [doc = "0: LOW"] CTL0_TXD_OUT_LOW = 0 , # [doc = "1: HIGH"] CTL0_TXD_OUT_HIGH = 1 , } impl From < CTL0_TXD_OUT_A > for bool { # [inline (always)] fn from (variant : CTL0_TXD_OUT_A) -> Self { variant as u8 != 0 } } impl CTL0_TXD_OUT_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL0_TXD_OUT_A { match self . bits { false => CTL0_TXD_OUT_A :: CTL0_TXD_OUT_LOW , true => CTL0_TXD_OUT_A :: CTL0_TXD_OUT_HIGH , } } # [doc = "LOW"] # [inline (always)] pub fn is_ctl0_txd_out_low (& self) -> bool { * self == CTL0_TXD_OUT_A :: CTL0_TXD_OUT_LOW } # [doc = "HIGH"] # [inline (always)] pub fn is_ctl0_txd_out_high (& self) -> bool { * self == CTL0_TXD_OUT_A :: CTL0_TXD_OUT_HIGH } } # [doc = "Field `CTL0_TXD_OUT` writer - TXD Pin Control Controls the TXD pin when TXD_OUT_EN = 1 and TXE = 0."] pub type CTL0_TXD_OUT_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL0_TXD_OUT_A > ; impl < 'a , REG , const O : u8 > CTL0_TXD_OUT_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "LOW"] # [inline (always)] pub fn ctl0_txd_out_low (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_TXD_OUT_A :: CTL0_TXD_OUT_LOW) } # [doc = "HIGH"] # [inline (always)] pub fn ctl0_txd_out_high (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_TXD_OUT_A :: CTL0_TXD_OUT_HIGH) } } # [doc = "Field `CTL0_MODE` reader - Set the communication mode and protocol used. (Not defined settings uses the default setting: 0)"] pub type CTL0_MODE_R = crate :: FieldReader < CTL0_MODE_A > ; # [doc = "Set the communication mode and protocol used. (Not defined settings uses the default setting: 0)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CTL0_MODE_A { # [doc = "0: UART"] CTL0_MODE_UART = 0 , # [doc = "1: RS485"] CTL0_MODE_RS485 = 1 , # [doc = "2: IDLELINE"] CTL0_MODE_IDLELINE = 2 , # [doc = "3: ADDR9BIT"] CTL0_MODE_ADDR9BIT = 3 , # [doc = "4: SMART"] CTL0_MODE_SMART = 4 , # [doc = "5: DALI"] CTL0_MODE_DALI = 5 , } impl From < CTL0_MODE_A > for u8 { # [inline (always)] fn from (variant : CTL0_MODE_A) -> Self { variant as _ } } impl crate :: FieldSpec for CTL0_MODE_A { type Ux = u8 ; } impl CTL0_MODE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CTL0_MODE_A > { match self . bits { 0 => Some (CTL0_MODE_A :: CTL0_MODE_UART) , 1 => Some (CTL0_MODE_A :: CTL0_MODE_RS485) , 2 => Some (CTL0_MODE_A :: CTL0_MODE_IDLELINE) , 3 => Some (CTL0_MODE_A :: CTL0_MODE_ADDR9BIT) , 4 => Some (CTL0_MODE_A :: CTL0_MODE_SMART) , 5 => Some (CTL0_MODE_A :: CTL0_MODE_DALI) , _ => None , } } # [doc = "UART"] # [inline (always)] pub fn is_ctl0_mode_uart (& self) -> bool { * self == CTL0_MODE_A :: CTL0_MODE_UART } # [doc = "RS485"] # [inline (always)] pub fn is_ctl0_mode_rs485 (& self) -> bool { * self == CTL0_MODE_A :: CTL0_MODE_RS485 } # [doc = "IDLELINE"] # [inline (always)] pub fn is_ctl0_mode_idleline (& self) -> bool { * self == CTL0_MODE_A :: CTL0_MODE_IDLELINE } # [doc = "ADDR9BIT"] # [inline (always)] pub fn is_ctl0_mode_addr9bit (& self) -> bool { * self == CTL0_MODE_A :: CTL0_MODE_ADDR9BIT } # [doc = "SMART"] # [inline (always)] pub fn is_ctl0_mode_smart (& self) -> bool { * self == CTL0_MODE_A :: CTL0_MODE_SMART } # [doc = "DALI"] # [inline (always)] pub fn is_ctl0_mode_dali (& self) -> bool { * self == CTL0_MODE_A :: CTL0_MODE_DALI } } # [doc = "Field `CTL0_MODE` writer - Set the communication mode and protocol used. (Not defined settings uses the default setting: 0)"] pub type CTL0_MODE_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 3 , O , CTL0_MODE_A > ; impl < 'a , REG , const O : u8 > CTL0_MODE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "UART"] # [inline (always)] pub fn ctl0_mode_uart (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_MODE_A :: CTL0_MODE_UART) } # [doc = "RS485"] # [inline (always)] pub fn ctl0_mode_rs485 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_MODE_A :: CTL0_MODE_RS485) } # [doc = "IDLELINE"] # [inline (always)] pub fn ctl0_mode_idleline (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_MODE_A :: CTL0_MODE_IDLELINE) } # [doc = "ADDR9BIT"] # [inline (always)] pub fn ctl0_mode_addr9bit (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_MODE_A :: CTL0_MODE_ADDR9BIT) } # [doc = "SMART"] # [inline (always)] pub fn ctl0_mode_smart (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_MODE_A :: CTL0_MODE_SMART) } # [doc = "DALI"] # [inline (always)] pub fn ctl0_mode_dali (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_MODE_A :: CTL0_MODE_DALI) } } # [doc = "Field `CTL0_RTS` reader - Request to Send If RTSEN is set the RTS output signals is controlled by the hardware logic using the FIFO fill level or TXDATA buffer. If RTSEN is cleared the RTS output is controlled by the RTS bit. The bit is the complement of the UART request to send, RTS modem status output."] pub type CTL0_RTS_R = crate :: BitReader < CTL0_RTS_A > ; # [doc = "Request to Send If RTSEN is set the RTS output signals is controlled by the hardware logic using the FIFO fill level or TXDATA buffer. If RTSEN is cleared the RTS output is controlled by the RTS bit. The bit is the complement of the UART request to send, RTS modem status output.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL0_RTS_A { # [doc = "0: CLR"] CTL0_RTS_CLR = 0 , # [doc = "1: SET"] CTL0_RTS_SET = 1 , } impl From < CTL0_RTS_A > for bool { # [inline (always)] fn from (variant : CTL0_RTS_A) -> Self { variant as u8 != 0 } } impl CTL0_RTS_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL0_RTS_A { match self . bits { false => CTL0_RTS_A :: CTL0_RTS_CLR , true => CTL0_RTS_A :: CTL0_RTS_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_ctl0_rts_clr (& self) -> bool { * self == CTL0_RTS_A :: CTL0_RTS_CLR } # [doc = "SET"] # [inline (always)] pub fn is_ctl0_rts_set (& self) -> bool { * self == CTL0_RTS_A :: CTL0_RTS_SET } } # [doc = "Field `CTL0_RTS` writer - Request to Send If RTSEN is set the RTS output signals is controlled by the hardware logic using the FIFO fill level or TXDATA buffer. If RTSEN is cleared the RTS output is controlled by the RTS bit. The bit is the complement of the UART request to send, RTS modem status output."] pub type CTL0_RTS_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL0_RTS_A > ; impl < 'a , REG , const O : u8 > CTL0_RTS_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn ctl0_rts_clr (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_RTS_A :: CTL0_RTS_CLR) } # [doc = "SET"] # [inline (always)] pub fn ctl0_rts_set (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_RTS_A :: CTL0_RTS_SET) } } # [doc = "Field `CTL0_RTSEN` reader - Enable hardware controlled Request to Send"] pub type CTL0_RTSEN_R = crate :: BitReader < CTL0_RTSEN_A > ; # [doc = "Enable hardware controlled Request to Send\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL0_RTSEN_A { # [doc = "0: DISABLE"] CTL0_RTSEN_DISABLE = 0 , # [doc = "1: ENABLE"] CTL0_RTSEN_ENABLE = 1 , } impl From < CTL0_RTSEN_A > for bool { # [inline (always)] fn from (variant : CTL0_RTSEN_A) -> Self { variant as u8 != 0 } } impl CTL0_RTSEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL0_RTSEN_A { match self . bits { false => CTL0_RTSEN_A :: CTL0_RTSEN_DISABLE , true => CTL0_RTSEN_A :: CTL0_RTSEN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_ctl0_rtsen_disable (& self) -> bool { * self == CTL0_RTSEN_A :: CTL0_RTSEN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_ctl0_rtsen_enable (& self) -> bool { * self == CTL0_RTSEN_A :: CTL0_RTSEN_ENABLE } } # [doc = "Field `CTL0_RTSEN` writer - Enable hardware controlled Request to Send"] pub type CTL0_RTSEN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL0_RTSEN_A > ; impl < 'a , REG , const O : u8 > CTL0_RTSEN_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn ctl0_rtsen_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_RTSEN_A :: CTL0_RTSEN_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn ctl0_rtsen_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_RTSEN_A :: CTL0_RTSEN_ENABLE) } } # [doc = "Field `CTL0_CTSEN` reader - Enable Clear To Send"] pub type CTL0_CTSEN_R = crate :: BitReader < CTL0_CTSEN_A > ; # [doc = "Enable Clear To Send\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL0_CTSEN_A { # [doc = "0: DISABLE"] CTL0_CTSEN_DISABLE = 0 , # [doc = "1: ENABLE"] CTL0_CTSEN_ENABLE = 1 , } impl From < CTL0_CTSEN_A > for bool { # [inline (always)] fn from (variant : CTL0_CTSEN_A) -> Self { variant as u8 != 0 } } impl CTL0_CTSEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL0_CTSEN_A { match self . bits { false => CTL0_CTSEN_A :: CTL0_CTSEN_DISABLE , true => CTL0_CTSEN_A :: CTL0_CTSEN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_ctl0_ctsen_disable (& self) -> bool { * self == CTL0_CTSEN_A :: CTL0_CTSEN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_ctl0_ctsen_enable (& self) -> bool { * self == CTL0_CTSEN_A :: CTL0_CTSEN_ENABLE } } # [doc = "Field `CTL0_CTSEN` writer - Enable Clear To Send"] pub type CTL0_CTSEN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL0_CTSEN_A > ; impl < 'a , REG , const O : u8 > CTL0_CTSEN_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn ctl0_ctsen_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_CTSEN_A :: CTL0_CTSEN_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn ctl0_ctsen_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_CTSEN_A :: CTL0_CTSEN_ENABLE) } } # [doc = "Field `CTL0_HSE` reader - High-Speed Bit Oversampling Enable #b#NOTE:#/b# The bit oversampling influences the UART baud-rate configuration (see and ). The state of this bit has no effect on clock generation in ISO7816 smart card mode (the SMART bit is set)."] pub type CTL0_HSE_R = crate :: FieldReader < CTL0_HSE_A > ; # [doc = "High-Speed Bit Oversampling Enable #b#NOTE:#/b# The bit oversampling influences the UART baud-rate configuration (see and ). The state of this bit has no effect on clock generation in ISO7816 smart card mode (the SMART bit is set).\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CTL0_HSE_A { # [doc = "0: OVS16"] CTL0_HSE_OVS16 = 0 , # [doc = "1: OVS8"] CTL0_HSE_OVS8 = 1 , # [doc = "2: OVS3"] CTL0_HSE_OVS3 = 2 , } impl From < CTL0_HSE_A > for u8 { # [inline (always)] fn from (variant : CTL0_HSE_A) -> Self { variant as _ } } impl crate :: FieldSpec for CTL0_HSE_A { type Ux = u8 ; } impl CTL0_HSE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CTL0_HSE_A > { match self . bits { 0 => Some (CTL0_HSE_A :: CTL0_HSE_OVS16) , 1 => Some (CTL0_HSE_A :: CTL0_HSE_OVS8) , 2 => Some (CTL0_HSE_A :: CTL0_HSE_OVS3) , _ => None , } } # [doc = "OVS16"] # [inline (always)] pub fn is_ctl0_hse_ovs16 (& self) -> bool { * self == CTL0_HSE_A :: CTL0_HSE_OVS16 } # [doc = "OVS8"] # [inline (always)] pub fn is_ctl0_hse_ovs8 (& self) -> bool { * self == CTL0_HSE_A :: CTL0_HSE_OVS8 } # [doc = "OVS3"] # [inline (always)] pub fn is_ctl0_hse_ovs3 (& self) -> bool { * self == CTL0_HSE_A :: CTL0_HSE_OVS3 } } # [doc = "Field `CTL0_HSE` writer - High-Speed Bit Oversampling Enable #b#NOTE:#/b# The bit oversampling influences the UART baud-rate configuration (see and ). The state of this bit has no effect on clock generation in ISO7816 smart card mode (the SMART bit is set)."] pub type CTL0_HSE_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 2 , O , CTL0_HSE_A > ; impl < 'a , REG , const O : u8 > CTL0_HSE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "OVS16"] # [inline (always)] pub fn ctl0_hse_ovs16 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_HSE_A :: CTL0_HSE_OVS16) } # [doc = "OVS8"] # [inline (always)] pub fn ctl0_hse_ovs8 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_HSE_A :: CTL0_HSE_OVS8) } # [doc = "OVS3"] # [inline (always)] pub fn ctl0_hse_ovs3 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_HSE_A :: CTL0_HSE_OVS3) } } # [doc = "Field `CTL0_FEN` reader - UART Enable FIFOs"] pub type CTL0_FEN_R = crate :: BitReader < CTL0_FEN_A > ; # [doc = "UART Enable FIFOs\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL0_FEN_A { # [doc = "0: DISABLE"] CTL0_FEN_DISABLE = 0 , # [doc = "1: ENABLE"] CTL0_FEN_ENABLE = 1 , } impl From < CTL0_FEN_A > for bool { # [inline (always)] fn from (variant : CTL0_FEN_A) -> Self { variant as u8 != 0 } } impl CTL0_FEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL0_FEN_A { match self . bits { false => CTL0_FEN_A :: CTL0_FEN_DISABLE , true => CTL0_FEN_A :: CTL0_FEN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_ctl0_fen_disable (& self) -> bool { * self == CTL0_FEN_A :: CTL0_FEN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_ctl0_fen_enable (& self) -> bool { * self == CTL0_FEN_A :: CTL0_FEN_ENABLE } } # [doc = "Field `CTL0_FEN` writer - UART Enable FIFOs"] pub type CTL0_FEN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL0_FEN_A > ; impl < 'a , REG , const O : u8 > CTL0_FEN_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn ctl0_fen_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_FEN_A :: CTL0_FEN_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn ctl0_fen_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_FEN_A :: CTL0_FEN_ENABLE) } } # [doc = "Field `CTL0_MAJVOTE` reader - When enabled with oversmapling of 16, samples samples 7, 8, and 9 are majority voted to decide the sampled bit value. The value correspond to al least 2 of the 3 samples is considered to be the received value. In case the 3 values do not match, RIS.NERR bit is set along with RDR.NERR When enabled with oversmapling of 8, samples samples 3, 4, and 5 are majority voted to decide the sampled bit value. The value correspond to al least 2 of the 3 samples is considered to be the received value. In case the 3 values donot match, RIS.NERR bit is set along with RDR.NERR When disabled, only a single sample of received bit is taken."] pub type CTL0_MAJVOTE_R = crate :: BitReader < CTL0_MAJVOTE_A > ; # [doc = "When enabled with oversmapling of 16, samples samples 7, 8, and 9 are majority voted to decide the sampled bit value. The value correspond to al least 2 of the 3 samples is considered to be the received value. In case the 3 values do not match, RIS.NERR bit is set along with RDR.NERR When enabled with oversmapling of 8, samples samples 3, 4, and 5 are majority voted to decide the sampled bit value. The value correspond to al least 2 of the 3 samples is considered to be the received value. In case the 3 values donot match, RIS.NERR bit is set along with RDR.NERR When disabled, only a single sample of received bit is taken.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL0_MAJVOTE_A { # [doc = "0: DISABLE"] CTL0_MAJVOTE_DISABLE = 0 , # [doc = "1: ENABLE"] CTL0_MAJVOTE_ENABLE = 1 , } impl From < CTL0_MAJVOTE_A > for bool { # [inline (always)] fn from (variant : CTL0_MAJVOTE_A) -> Self { variant as u8 != 0 } } impl CTL0_MAJVOTE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL0_MAJVOTE_A { match self . bits { false => CTL0_MAJVOTE_A :: CTL0_MAJVOTE_DISABLE , true => CTL0_MAJVOTE_A :: CTL0_MAJVOTE_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_ctl0_majvote_disable (& self) -> bool { * self == CTL0_MAJVOTE_A :: CTL0_MAJVOTE_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_ctl0_majvote_enable (& self) -> bool { * self == CTL0_MAJVOTE_A :: CTL0_MAJVOTE_ENABLE } } # [doc = "Field `CTL0_MAJVOTE` writer - When enabled with oversmapling of 16, samples samples 7, 8, and 9 are majority voted to decide the sampled bit value. The value correspond to al least 2 of the 3 samples is considered to be the received value. In case the 3 values do not match, RIS.NERR bit is set along with RDR.NERR When enabled with oversmapling of 8, samples samples 3, 4, and 5 are majority voted to decide the sampled bit value. The value correspond to al least 2 of the 3 samples is considered to be the received value. In case the 3 values donot match, RIS.NERR bit is set along with RDR.NERR When disabled, only a single sample of received bit is taken."] pub type CTL0_MAJVOTE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL0_MAJVOTE_A > ; impl < 'a , REG , const O : u8 > CTL0_MAJVOTE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn ctl0_majvote_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_MAJVOTE_A :: CTL0_MAJVOTE_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn ctl0_majvote_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_MAJVOTE_A :: CTL0_MAJVOTE_ENABLE) } } # [doc = "Field `CTL0_MSBFIRST` reader - Most Significant Bit First This bit has effect both on the way protocol byte is transmitted and received. Notes: User needs to match the protocol to the correct value of this bit to send MSb or LSb first. The hardware engine will send the byte entirely based on this bit."] pub type CTL0_MSBFIRST_R = crate :: BitReader < CTL0_MSBFIRST_A > ; # [doc = "Most Significant Bit First This bit has effect both on the way protocol byte is transmitted and received. Notes: User needs to match the protocol to the correct value of this bit to send MSb or LSb first. The hardware engine will send the byte entirely based on this bit.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL0_MSBFIRST_A { # [doc = "0: DISABLE"] CTL0_MSBFIRST_DISABLE = 0 , # [doc = "1: ENABLE"] CTL0_MSBFIRST_ENABLE = 1 , } impl From < CTL0_MSBFIRST_A > for bool { # [inline (always)] fn from (variant : CTL0_MSBFIRST_A) -> Self { variant as u8 != 0 } } impl CTL0_MSBFIRST_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL0_MSBFIRST_A { match self . bits { false => CTL0_MSBFIRST_A :: CTL0_MSBFIRST_DISABLE , true => CTL0_MSBFIRST_A :: CTL0_MSBFIRST_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_ctl0_msbfirst_disable (& self) -> bool { * self == CTL0_MSBFIRST_A :: CTL0_MSBFIRST_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_ctl0_msbfirst_enable (& self) -> bool { * self == CTL0_MSBFIRST_A :: CTL0_MSBFIRST_ENABLE } } # [doc = "Field `CTL0_MSBFIRST` writer - Most Significant Bit First This bit has effect both on the way protocol byte is transmitted and received. Notes: User needs to match the protocol to the correct value of this bit to send MSb or LSb first. The hardware engine will send the byte entirely based on this bit."] pub type CTL0_MSBFIRST_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL0_MSBFIRST_A > ; impl < 'a , REG , const O : u8 > CTL0_MSBFIRST_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn ctl0_msbfirst_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_MSBFIRST_A :: CTL0_MSBFIRST_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn ctl0_msbfirst_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_MSBFIRST_A :: CTL0_MSBFIRST_ENABLE) } } impl R { # [doc = "Bit 0 - UART Module Enable. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping. If the ENABLE bit is not set, all registers can still be accessed and updated. It is recommended to setup and change the UART operation mode with having the ENABLE bit cleared to avoid unpredictable behavior during the setup or update. If disabled the UART module will not send or receive any data and the logic is held in reset state."] # [inline (always)] pub fn ctl0_enable (& self) -> CTL0_ENABLE_R { CTL0_ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - UART Loop Back Enable"] # [inline (always)] pub fn ctl0_lbe (& self) -> CTL0_LBE_R { CTL0_LBE_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - UART Receive Enable If the UART is disabled in the middle of a receive, it completes the current character before stopping. #b#NOTE:#/b# To enable reception, the UARTEN bit must be set."] # [inline (always)] pub fn ctl0_rxe (& self) -> CTL0_RXE_R { CTL0_RXE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - UART Transmit Enable If the UART is disabled in the middle of a transmission, it completes the current character before stopping. #b#NOTE:#/b# To enable transmission, the UARTEN bit must be set."] # [inline (always)] pub fn ctl0_txe (& self) -> CTL0_TXE_R { CTL0_TXE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - TXD Pin Control Enable. When the transmit section of the UART is disabled (TXE = 0), the TXD pin can be controlled by the TXD_OUT bit. 1 = UARTxTXD pin can be controlled by TXD_OUT, if TXE = 0"] # [inline (always)] pub fn ctl0_txd_out_en (& self) -> CTL0_TXD_OUT_EN_R { CTL0_TXD_OUT_EN_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - TXD Pin Control Controls the TXD pin when TXD_OUT_EN = 1 and TXE = 0."] # [inline (always)] pub fn ctl0_txd_out (& self) -> CTL0_TXD_OUT_R { CTL0_TXD_OUT_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bits 8:10 - Set the communication mode and protocol used. (Not defined settings uses the default setting: 0)"] # [inline (always)] pub fn ctl0_mode (& self) -> CTL0_MODE_R { CTL0_MODE_R :: new (((self . bits >> 8) & 7) as u8) } # [doc = "Bit 12 - Request to Send If RTSEN is set the RTS output signals is controlled by the hardware logic using the FIFO fill level or TXDATA buffer. If RTSEN is cleared the RTS output is controlled by the RTS bit. The bit is the complement of the UART request to send, RTS modem status output."] # [inline (always)] pub fn ctl0_rts (& self) -> CTL0_RTS_R { CTL0_RTS_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Enable hardware controlled Request to Send"] # [inline (always)] pub fn ctl0_rtsen (& self) -> CTL0_RTSEN_R { CTL0_RTSEN_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Enable Clear To Send"] # [inline (always)] pub fn ctl0_ctsen (& self) -> CTL0_CTSEN_R { CTL0_CTSEN_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bits 15:16 - High-Speed Bit Oversampling Enable #b#NOTE:#/b# The bit oversampling influences the UART baud-rate configuration (see and ). The state of this bit has no effect on clock generation in ISO7816 smart card mode (the SMART bit is set)."] # [inline (always)] pub fn ctl0_hse (& self) -> CTL0_HSE_R { CTL0_HSE_R :: new (((self . bits >> 15) & 3) as u8) } # [doc = "Bit 17 - UART Enable FIFOs"] # [inline (always)] pub fn ctl0_fen (& self) -> CTL0_FEN_R { CTL0_FEN_R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - When enabled with oversmapling of 16, samples samples 7, 8, and 9 are majority voted to decide the sampled bit value. The value correspond to al least 2 of the 3 samples is considered to be the received value. In case the 3 values do not match, RIS.NERR bit is set along with RDR.NERR When enabled with oversmapling of 8, samples samples 3, 4, and 5 are majority voted to decide the sampled bit value. The value correspond to al least 2 of the 3 samples is considered to be the received value. In case the 3 values donot match, RIS.NERR bit is set along with RDR.NERR When disabled, only a single sample of received bit is taken."] # [inline (always)] pub fn ctl0_majvote (& self) -> CTL0_MAJVOTE_R { CTL0_MAJVOTE_R :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Most Significant Bit First This bit has effect both on the way protocol byte is transmitted and received. Notes: User needs to match the protocol to the correct value of this bit to send MSb or LSb first. The hardware engine will send the byte entirely based on this bit."] # [inline (always)] pub fn ctl0_msbfirst (& self) -> CTL0_MSBFIRST_R { CTL0_MSBFIRST_R :: new (((self . bits >> 19) & 1) != 0) } } impl W { # [doc = "Bit 0 - UART Module Enable. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping. If the ENABLE bit is not set, all registers can still be accessed and updated. It is recommended to setup and change the UART operation mode with having the ENABLE bit cleared to avoid unpredictable behavior during the setup or update. If disabled the UART module will not send or receive any data and the logic is held in reset state."] # [inline (always)] # [must_use] pub fn ctl0_enable (& mut self) -> CTL0_ENABLE_W < CTL0_SPEC , 0 > { CTL0_ENABLE_W :: new (self) } # [doc = "Bit 2 - UART Loop Back Enable"] # [inline (always)] # [must_use] pub fn ctl0_lbe (& mut self) -> CTL0_LBE_W < CTL0_SPEC , 2 > { CTL0_LBE_W :: new (self) } # [doc = "Bit 3 - UART Receive Enable If the UART is disabled in the middle of a receive, it completes the current character before stopping. #b#NOTE:#/b# To enable reception, the UARTEN bit must be set."] # [inline (always)] # [must_use] pub fn ctl0_rxe (& mut self) -> CTL0_RXE_W < CTL0_SPEC , 3 > { CTL0_RXE_W :: new (self) } # [doc = "Bit 4 - UART Transmit Enable If the UART is disabled in the middle of a transmission, it completes the current character before stopping. #b#NOTE:#/b# To enable transmission, the UARTEN bit must be set."] # [inline (always)] # [must_use] pub fn ctl0_txe (& mut self) -> CTL0_TXE_W < CTL0_SPEC , 4 > { CTL0_TXE_W :: new (self) } # [doc = "Bit 5 - TXD Pin Control Enable. When the transmit section of the UART is disabled (TXE = 0), the TXD pin can be controlled by the TXD_OUT bit. 1 = UARTxTXD pin can be controlled by TXD_OUT, if TXE = 0"] # [inline (always)] # [must_use] pub fn ctl0_txd_out_en (& mut self) -> CTL0_TXD_OUT_EN_W < CTL0_SPEC , 5 > { CTL0_TXD_OUT_EN_W :: new (self) } # [doc = "Bit 6 - TXD Pin Control Controls the TXD pin when TXD_OUT_EN = 1 and TXE = 0."] # [inline (always)] # [must_use] pub fn ctl0_txd_out (& mut self) -> CTL0_TXD_OUT_W < CTL0_SPEC , 6 > { CTL0_TXD_OUT_W :: new (self) } # [doc = "Bits 8:10 - Set the communication mode and protocol used. (Not defined settings uses the default setting: 0)"] # [inline (always)] # [must_use] pub fn ctl0_mode (& mut self) -> CTL0_MODE_W < CTL0_SPEC , 8 > { CTL0_MODE_W :: new (self) } # [doc = "Bit 12 - Request to Send If RTSEN is set the RTS output signals is controlled by the hardware logic using the FIFO fill level or TXDATA buffer. If RTSEN is cleared the RTS output is controlled by the RTS bit. The bit is the complement of the UART request to send, RTS modem status output."] # [inline (always)] # [must_use] pub fn ctl0_rts (& mut self) -> CTL0_RTS_W < CTL0_SPEC , 12 > { CTL0_RTS_W :: new (self) } # [doc = "Bit 13 - Enable hardware controlled Request to Send"] # [inline (always)] # [must_use] pub fn ctl0_rtsen (& mut self) -> CTL0_RTSEN_W < CTL0_SPEC , 13 > { CTL0_RTSEN_W :: new (self) } # [doc = "Bit 14 - Enable Clear To Send"] # [inline (always)] # [must_use] pub fn ctl0_ctsen (& mut self) -> CTL0_CTSEN_W < CTL0_SPEC , 14 > { CTL0_CTSEN_W :: new (self) } # [doc = "Bits 15:16 - High-Speed Bit Oversampling Enable #b#NOTE:#/b# The bit oversampling influences the UART baud-rate configuration (see and ). The state of this bit has no effect on clock generation in ISO7816 smart card mode (the SMART bit is set)."] # [inline (always)] # [must_use] pub fn ctl0_hse (& mut self) -> CTL0_HSE_W < CTL0_SPEC , 15 > { CTL0_HSE_W :: new (self) } # [doc = "Bit 17 - UART Enable FIFOs"] # [inline (always)] # [must_use] pub fn ctl0_fen (& mut self) -> CTL0_FEN_W < CTL0_SPEC , 17 > { CTL0_FEN_W :: new (self) } # [doc = "Bit 18 - When enabled with oversmapling of 16, samples samples 7, 8, and 9 are majority voted to decide the sampled bit value. The value correspond to al least 2 of the 3 samples is considered to be the received value. In case the 3 values do not match, RIS.NERR bit is set along with RDR.NERR When enabled with oversmapling of 8, samples samples 3, 4, and 5 are majority voted to decide the sampled bit value. The value correspond to al least 2 of the 3 samples is considered to be the received value. In case the 3 values donot match, RIS.NERR bit is set along with RDR.NERR When disabled, only a single sample of received bit is taken."] # [inline (always)] # [must_use] pub fn ctl0_majvote (& mut self) -> CTL0_MAJVOTE_W < CTL0_SPEC , 18 > { CTL0_MAJVOTE_W :: new (self) } # [doc = "Bit 19 - Most Significant Bit First This bit has effect both on the way protocol byte is transmitted and received. Notes: User needs to match the protocol to the correct value of this bit to send MSb or LSb first. The hardware engine will send the byte entirely based on this bit."] # [inline (always)] # [must_use] pub fn ctl0_msbfirst (& mut self) -> CTL0_MSBFIRST_W < CTL0_SPEC , 19 > { CTL0_MSBFIRST_W :: new (self) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "UART Control Register 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ctl0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctl0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CTL0_SPEC ; impl crate :: RegisterSpec for CTL0_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`ctl0::R`](R) reader structure"] impl crate :: Readable for CTL0_SPEC { } # [doc = "`write(|w| ..)` method takes [`ctl0::W`](W) writer structure"] impl crate :: Writable for CTL0_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTL0 to value 0x38"] impl crate :: Resettable for CTL0_SPEC { const RESET_VALUE : Self :: Ux = 0x38 ; }