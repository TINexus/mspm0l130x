# [doc = "Register `INT_EVENT0_RIS` reader"] pub type R = crate :: R < INT_EVENT0_RIS_SPEC > ; # [doc = "Field `INT_EVENT0_RIS_RTOUT` reader - UARTOUT Receive Time-Out Interrupt."] pub type INT_EVENT0_RIS_RTOUT_R = crate :: BitReader < INT_EVENT0_RIS_RTOUT_A > ; # [doc = "UARTOUT Receive Time-Out Interrupt.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_RIS_RTOUT_A { # [doc = "0: CLR"] INT_EVENT0_RIS_RTOUT_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_RIS_RTOUT_SET = 1 , } impl From < INT_EVENT0_RIS_RTOUT_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_RIS_RTOUT_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_RIS_RTOUT_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_RIS_RTOUT_A { match self . bits { false => INT_EVENT0_RIS_RTOUT_A :: INT_EVENT0_RIS_RTOUT_CLR , true => INT_EVENT0_RIS_RTOUT_A :: INT_EVENT0_RIS_RTOUT_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_ris_rtout_clr (& self) -> bool { * self == INT_EVENT0_RIS_RTOUT_A :: INT_EVENT0_RIS_RTOUT_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_ris_rtout_set (& self) -> bool { * self == INT_EVENT0_RIS_RTOUT_A :: INT_EVENT0_RIS_RTOUT_SET } } # [doc = "Field `INT_EVENT0_RIS_FRMERR` reader - UART Framing Error Interrupt."] pub type INT_EVENT0_RIS_FRMERR_R = crate :: BitReader < INT_EVENT0_RIS_FRMERR_A > ; # [doc = "UART Framing Error Interrupt.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_RIS_FRMERR_A { # [doc = "0: CLR"] INT_EVENT0_RIS_FRMERR_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_RIS_FRMERR_SET = 1 , } impl From < INT_EVENT0_RIS_FRMERR_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_RIS_FRMERR_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_RIS_FRMERR_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_RIS_FRMERR_A { match self . bits { false => INT_EVENT0_RIS_FRMERR_A :: INT_EVENT0_RIS_FRMERR_CLR , true => INT_EVENT0_RIS_FRMERR_A :: INT_EVENT0_RIS_FRMERR_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_ris_frmerr_clr (& self) -> bool { * self == INT_EVENT0_RIS_FRMERR_A :: INT_EVENT0_RIS_FRMERR_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_ris_frmerr_set (& self) -> bool { * self == INT_EVENT0_RIS_FRMERR_A :: INT_EVENT0_RIS_FRMERR_SET } } # [doc = "Field `INT_EVENT0_RIS_PARERR` reader - UART Parity Error Interrupt."] pub type INT_EVENT0_RIS_PARERR_R = crate :: BitReader < INT_EVENT0_RIS_PARERR_A > ; # [doc = "UART Parity Error Interrupt.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_RIS_PARERR_A { # [doc = "0: CLR"] INT_EVENT0_RIS_PARERR_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_RIS_PARERR_SET = 1 , } impl From < INT_EVENT0_RIS_PARERR_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_RIS_PARERR_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_RIS_PARERR_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_RIS_PARERR_A { match self . bits { false => INT_EVENT0_RIS_PARERR_A :: INT_EVENT0_RIS_PARERR_CLR , true => INT_EVENT0_RIS_PARERR_A :: INT_EVENT0_RIS_PARERR_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_ris_parerr_clr (& self) -> bool { * self == INT_EVENT0_RIS_PARERR_A :: INT_EVENT0_RIS_PARERR_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_ris_parerr_set (& self) -> bool { * self == INT_EVENT0_RIS_PARERR_A :: INT_EVENT0_RIS_PARERR_SET } } # [doc = "Field `INT_EVENT0_RIS_BRKERR` reader - UART Break Error Interrupt."] pub type INT_EVENT0_RIS_BRKERR_R = crate :: BitReader < INT_EVENT0_RIS_BRKERR_A > ; # [doc = "UART Break Error Interrupt.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_RIS_BRKERR_A { # [doc = "0: CLR"] INT_EVENT0_RIS_BRKERR_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_RIS_BRKERR_SET = 1 , } impl From < INT_EVENT0_RIS_BRKERR_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_RIS_BRKERR_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_RIS_BRKERR_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_RIS_BRKERR_A { match self . bits { false => INT_EVENT0_RIS_BRKERR_A :: INT_EVENT0_RIS_BRKERR_CLR , true => INT_EVENT0_RIS_BRKERR_A :: INT_EVENT0_RIS_BRKERR_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_ris_brkerr_clr (& self) -> bool { * self == INT_EVENT0_RIS_BRKERR_A :: INT_EVENT0_RIS_BRKERR_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_ris_brkerr_set (& self) -> bool { * self == INT_EVENT0_RIS_BRKERR_A :: INT_EVENT0_RIS_BRKERR_SET } } # [doc = "Field `INT_EVENT0_RIS_OVRERR` reader - UART Receive Overrun Error Interrupt."] pub type INT_EVENT0_RIS_OVRERR_R = crate :: BitReader < INT_EVENT0_RIS_OVRERR_A > ; # [doc = "UART Receive Overrun Error Interrupt.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_RIS_OVRERR_A { # [doc = "0: CLR"] INT_EVENT0_RIS_OVRERR_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_RIS_OVRERR_SET = 1 , } impl From < INT_EVENT0_RIS_OVRERR_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_RIS_OVRERR_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_RIS_OVRERR_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_RIS_OVRERR_A { match self . bits { false => INT_EVENT0_RIS_OVRERR_A :: INT_EVENT0_RIS_OVRERR_CLR , true => INT_EVENT0_RIS_OVRERR_A :: INT_EVENT0_RIS_OVRERR_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_ris_ovrerr_clr (& self) -> bool { * self == INT_EVENT0_RIS_OVRERR_A :: INT_EVENT0_RIS_OVRERR_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_ris_ovrerr_set (& self) -> bool { * self == INT_EVENT0_RIS_OVRERR_A :: INT_EVENT0_RIS_OVRERR_SET } } # [doc = "Field `INT_EVENT0_RIS_RXNE` reader - Negative Edge on UARTxRXD Interrupt."] pub type INT_EVENT0_RIS_RXNE_R = crate :: BitReader < INT_EVENT0_RIS_RXNE_A > ; # [doc = "Negative Edge on UARTxRXD Interrupt.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_RIS_RXNE_A { # [doc = "0: CLR"] INT_EVENT0_RIS_RXNE_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_RIS_RXNE_SET = 1 , } impl From < INT_EVENT0_RIS_RXNE_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_RIS_RXNE_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_RIS_RXNE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_RIS_RXNE_A { match self . bits { false => INT_EVENT0_RIS_RXNE_A :: INT_EVENT0_RIS_RXNE_CLR , true => INT_EVENT0_RIS_RXNE_A :: INT_EVENT0_RIS_RXNE_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_ris_rxne_clr (& self) -> bool { * self == INT_EVENT0_RIS_RXNE_A :: INT_EVENT0_RIS_RXNE_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_ris_rxne_set (& self) -> bool { * self == INT_EVENT0_RIS_RXNE_A :: INT_EVENT0_RIS_RXNE_SET } } # [doc = "Field `INT_EVENT0_RIS_RXPE` reader - Positive Edge on UARTxRXD Interrupt."] pub type INT_EVENT0_RIS_RXPE_R = crate :: BitReader < INT_EVENT0_RIS_RXPE_A > ; # [doc = "Positive Edge on UARTxRXD Interrupt.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_RIS_RXPE_A { # [doc = "0: CLR"] INT_EVENT0_RIS_RXPE_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_RIS_RXPE_SET = 1 , } impl From < INT_EVENT0_RIS_RXPE_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_RIS_RXPE_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_RIS_RXPE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_RIS_RXPE_A { match self . bits { false => INT_EVENT0_RIS_RXPE_A :: INT_EVENT0_RIS_RXPE_CLR , true => INT_EVENT0_RIS_RXPE_A :: INT_EVENT0_RIS_RXPE_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_ris_rxpe_clr (& self) -> bool { * self == INT_EVENT0_RIS_RXPE_A :: INT_EVENT0_RIS_RXPE_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_ris_rxpe_set (& self) -> bool { * self == INT_EVENT0_RIS_RXPE_A :: INT_EVENT0_RIS_RXPE_SET } } # [doc = "Field `INT_EVENT0_RIS_RXINT` reader - UART Receive Interrupt."] pub type INT_EVENT0_RIS_RXINT_R = crate :: BitReader < INT_EVENT0_RIS_RXINT_A > ; # [doc = "UART Receive Interrupt.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_RIS_RXINT_A { # [doc = "0: CLR"] INT_EVENT0_RIS_RXINT_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_RIS_RXINT_SET = 1 , } impl From < INT_EVENT0_RIS_RXINT_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_RIS_RXINT_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_RIS_RXINT_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_RIS_RXINT_A { match self . bits { false => INT_EVENT0_RIS_RXINT_A :: INT_EVENT0_RIS_RXINT_CLR , true => INT_EVENT0_RIS_RXINT_A :: INT_EVENT0_RIS_RXINT_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_ris_rxint_clr (& self) -> bool { * self == INT_EVENT0_RIS_RXINT_A :: INT_EVENT0_RIS_RXINT_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_ris_rxint_set (& self) -> bool { * self == INT_EVENT0_RIS_RXINT_A :: INT_EVENT0_RIS_RXINT_SET } } # [doc = "Field `INT_EVENT0_RIS_TXINT` reader - UART Transmit Interrupt."] pub type INT_EVENT0_RIS_TXINT_R = crate :: BitReader < INT_EVENT0_RIS_TXINT_A > ; # [doc = "UART Transmit Interrupt.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_RIS_TXINT_A { # [doc = "0: CLR"] INT_EVENT0_RIS_TXINT_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_RIS_TXINT_SET = 1 , } impl From < INT_EVENT0_RIS_TXINT_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_RIS_TXINT_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_RIS_TXINT_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_RIS_TXINT_A { match self . bits { false => INT_EVENT0_RIS_TXINT_A :: INT_EVENT0_RIS_TXINT_CLR , true => INT_EVENT0_RIS_TXINT_A :: INT_EVENT0_RIS_TXINT_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_ris_txint_clr (& self) -> bool { * self == INT_EVENT0_RIS_TXINT_A :: INT_EVENT0_RIS_TXINT_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_ris_txint_set (& self) -> bool { * self == INT_EVENT0_RIS_TXINT_A :: INT_EVENT0_RIS_TXINT_SET } } # [doc = "Field `INT_EVENT0_RIS_EOT` reader - UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer."] pub type INT_EVENT0_RIS_EOT_R = crate :: BitReader < INT_EVENT0_RIS_EOT_A > ; # [doc = "UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_RIS_EOT_A { # [doc = "0: CLR"] INT_EVENT0_RIS_EOT_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_RIS_EOT_SET = 1 , } impl From < INT_EVENT0_RIS_EOT_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_RIS_EOT_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_RIS_EOT_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_RIS_EOT_A { match self . bits { false => INT_EVENT0_RIS_EOT_A :: INT_EVENT0_RIS_EOT_CLR , true => INT_EVENT0_RIS_EOT_A :: INT_EVENT0_RIS_EOT_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_ris_eot_clr (& self) -> bool { * self == INT_EVENT0_RIS_EOT_A :: INT_EVENT0_RIS_EOT_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_ris_eot_set (& self) -> bool { * self == INT_EVENT0_RIS_EOT_A :: INT_EVENT0_RIS_EOT_SET } } # [doc = "Field `INT_EVENT0_RIS_ADDR_MATCH` reader - Address Match Interrupt."] pub type INT_EVENT0_RIS_ADDR_MATCH_R = crate :: BitReader < INT_EVENT0_RIS_ADDR_MATCH_A > ; # [doc = "Address Match Interrupt.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_RIS_ADDR_MATCH_A { # [doc = "0: CLR"] INT_EVENT0_RIS_ADDR_MATCH_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_RIS_ADDR_MATCH_SET = 1 , } impl From < INT_EVENT0_RIS_ADDR_MATCH_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_RIS_ADDR_MATCH_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_RIS_ADDR_MATCH_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_RIS_ADDR_MATCH_A { match self . bits { false => INT_EVENT0_RIS_ADDR_MATCH_A :: INT_EVENT0_RIS_ADDR_MATCH_CLR , true => INT_EVENT0_RIS_ADDR_MATCH_A :: INT_EVENT0_RIS_ADDR_MATCH_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_ris_addr_match_clr (& self) -> bool { * self == INT_EVENT0_RIS_ADDR_MATCH_A :: INT_EVENT0_RIS_ADDR_MATCH_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_ris_addr_match_set (& self) -> bool { * self == INT_EVENT0_RIS_ADDR_MATCH_A :: INT_EVENT0_RIS_ADDR_MATCH_SET } } # [doc = "Field `INT_EVENT0_RIS_CTS` reader - UART Clear to Send Modem Interrupt. 0 = Interrupt disabled"] pub type INT_EVENT0_RIS_CTS_R = crate :: BitReader < INT_EVENT0_RIS_CTS_A > ; # [doc = "UART Clear to Send Modem Interrupt. 0 = Interrupt disabled\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_RIS_CTS_A { # [doc = "0: CLR"] INT_EVENT0_RIS_CTS_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_RIS_CTS_SET = 1 , } impl From < INT_EVENT0_RIS_CTS_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_RIS_CTS_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_RIS_CTS_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_RIS_CTS_A { match self . bits { false => INT_EVENT0_RIS_CTS_A :: INT_EVENT0_RIS_CTS_CLR , true => INT_EVENT0_RIS_CTS_A :: INT_EVENT0_RIS_CTS_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_ris_cts_clr (& self) -> bool { * self == INT_EVENT0_RIS_CTS_A :: INT_EVENT0_RIS_CTS_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_ris_cts_set (& self) -> bool { * self == INT_EVENT0_RIS_CTS_A :: INT_EVENT0_RIS_CTS_SET } } # [doc = "Field `INT_EVENT0_RIS_DMA_DONE_RX` reader - DMA Done on RX Event Channel"] pub type INT_EVENT0_RIS_DMA_DONE_RX_R = crate :: BitReader < INT_EVENT0_RIS_DMA_DONE_RX_A > ; # [doc = "DMA Done on RX Event Channel\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_RIS_DMA_DONE_RX_A { # [doc = "0: CLR"] INT_EVENT0_RIS_DMA_DONE_RX_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_RIS_DMA_DONE_RX_SET = 1 , } impl From < INT_EVENT0_RIS_DMA_DONE_RX_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_RIS_DMA_DONE_RX_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_RIS_DMA_DONE_RX_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_RIS_DMA_DONE_RX_A { match self . bits { false => INT_EVENT0_RIS_DMA_DONE_RX_A :: INT_EVENT0_RIS_DMA_DONE_RX_CLR , true => INT_EVENT0_RIS_DMA_DONE_RX_A :: INT_EVENT0_RIS_DMA_DONE_RX_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_ris_dma_done_rx_clr (& self) -> bool { * self == INT_EVENT0_RIS_DMA_DONE_RX_A :: INT_EVENT0_RIS_DMA_DONE_RX_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_ris_dma_done_rx_set (& self) -> bool { * self == INT_EVENT0_RIS_DMA_DONE_RX_A :: INT_EVENT0_RIS_DMA_DONE_RX_SET } } # [doc = "Field `INT_EVENT0_RIS_DMA_DONE_TX` reader - DMA Done on TX Event Channel"] pub type INT_EVENT0_RIS_DMA_DONE_TX_R = crate :: BitReader < INT_EVENT0_RIS_DMA_DONE_TX_A > ; # [doc = "DMA Done on TX Event Channel\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_RIS_DMA_DONE_TX_A { # [doc = "0: CLR"] INT_EVENT0_RIS_DMA_DONE_TX_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_RIS_DMA_DONE_TX_SET = 1 , } impl From < INT_EVENT0_RIS_DMA_DONE_TX_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_RIS_DMA_DONE_TX_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_RIS_DMA_DONE_TX_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_RIS_DMA_DONE_TX_A { match self . bits { false => INT_EVENT0_RIS_DMA_DONE_TX_A :: INT_EVENT0_RIS_DMA_DONE_TX_CLR , true => INT_EVENT0_RIS_DMA_DONE_TX_A :: INT_EVENT0_RIS_DMA_DONE_TX_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_ris_dma_done_tx_clr (& self) -> bool { * self == INT_EVENT0_RIS_DMA_DONE_TX_A :: INT_EVENT0_RIS_DMA_DONE_TX_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_ris_dma_done_tx_set (& self) -> bool { * self == INT_EVENT0_RIS_DMA_DONE_TX_A :: INT_EVENT0_RIS_DMA_DONE_TX_SET } } # [doc = "Field `INT_EVENT0_RIS_NERR` reader - Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal"] pub type INT_EVENT0_RIS_NERR_R = crate :: BitReader < INT_EVENT0_RIS_NERR_A > ; # [doc = "Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_RIS_NERR_A { # [doc = "0: CLR"] INT_EVENT0_RIS_NERR_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_RIS_NERR_SET = 1 , } impl From < INT_EVENT0_RIS_NERR_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_RIS_NERR_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_RIS_NERR_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_RIS_NERR_A { match self . bits { false => INT_EVENT0_RIS_NERR_A :: INT_EVENT0_RIS_NERR_CLR , true => INT_EVENT0_RIS_NERR_A :: INT_EVENT0_RIS_NERR_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_ris_nerr_clr (& self) -> bool { * self == INT_EVENT0_RIS_NERR_A :: INT_EVENT0_RIS_NERR_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_ris_nerr_set (& self) -> bool { * self == INT_EVENT0_RIS_NERR_A :: INT_EVENT0_RIS_NERR_SET } } impl R { # [doc = "Bit 0 - UARTOUT Receive Time-Out Interrupt."] # [inline (always)] pub fn int_event0_ris_rtout (& self) -> INT_EVENT0_RIS_RTOUT_R { INT_EVENT0_RIS_RTOUT_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - UART Framing Error Interrupt."] # [inline (always)] pub fn int_event0_ris_frmerr (& self) -> INT_EVENT0_RIS_FRMERR_R { INT_EVENT0_RIS_FRMERR_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - UART Parity Error Interrupt."] # [inline (always)] pub fn int_event0_ris_parerr (& self) -> INT_EVENT0_RIS_PARERR_R { INT_EVENT0_RIS_PARERR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - UART Break Error Interrupt."] # [inline (always)] pub fn int_event0_ris_brkerr (& self) -> INT_EVENT0_RIS_BRKERR_R { INT_EVENT0_RIS_BRKERR_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - UART Receive Overrun Error Interrupt."] # [inline (always)] pub fn int_event0_ris_ovrerr (& self) -> INT_EVENT0_RIS_OVRERR_R { INT_EVENT0_RIS_OVRERR_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Negative Edge on UARTxRXD Interrupt."] # [inline (always)] pub fn int_event0_ris_rxne (& self) -> INT_EVENT0_RIS_RXNE_R { INT_EVENT0_RIS_RXNE_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Positive Edge on UARTxRXD Interrupt."] # [inline (always)] pub fn int_event0_ris_rxpe (& self) -> INT_EVENT0_RIS_RXPE_R { INT_EVENT0_RIS_RXPE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 10 - UART Receive Interrupt."] # [inline (always)] pub fn int_event0_ris_rxint (& self) -> INT_EVENT0_RIS_RXINT_R { INT_EVENT0_RIS_RXINT_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - UART Transmit Interrupt."] # [inline (always)] pub fn int_event0_ris_txint (& self) -> INT_EVENT0_RIS_TXINT_R { INT_EVENT0_RIS_TXINT_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer."] # [inline (always)] pub fn int_event0_ris_eot (& self) -> INT_EVENT0_RIS_EOT_R { INT_EVENT0_RIS_EOT_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Address Match Interrupt."] # [inline (always)] pub fn int_event0_ris_addr_match (& self) -> INT_EVENT0_RIS_ADDR_MATCH_R { INT_EVENT0_RIS_ADDR_MATCH_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - UART Clear to Send Modem Interrupt. 0 = Interrupt disabled"] # [inline (always)] pub fn int_event0_ris_cts (& self) -> INT_EVENT0_RIS_CTS_R { INT_EVENT0_RIS_CTS_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - DMA Done on RX Event Channel"] # [inline (always)] pub fn int_event0_ris_dma_done_rx (& self) -> INT_EVENT0_RIS_DMA_DONE_RX_R { INT_EVENT0_RIS_DMA_DONE_RX_R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - DMA Done on TX Event Channel"] # [inline (always)] pub fn int_event0_ris_dma_done_tx (& self) -> INT_EVENT0_RIS_DMA_DONE_TX_R { INT_EVENT0_RIS_DMA_DONE_TX_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal"] # [inline (always)] pub fn int_event0_ris_nerr (& self) -> INT_EVENT0_RIS_NERR_R { INT_EVENT0_RIS_NERR_R :: new (((self . bits >> 17) & 1) != 0) } } # [doc = "Raw interrupt status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`int_event0_ris::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT_EVENT0_RIS_SPEC ; impl crate :: RegisterSpec for INT_EVENT0_RIS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`int_event0_ris::R`](R) reader structure"] impl crate :: Readable for INT_EVENT0_RIS_SPEC { } # [doc = "`reset()` method sets INT_EVENT0_RIS to value 0"] impl crate :: Resettable for INT_EVENT0_RIS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }