# [doc = "Register `INT_EVENT0_ISET` writer"] pub type W = crate :: W < INT_EVENT0_ISET_SPEC > ; # [doc = "Master Receive Data Interrupt Signals that a byte has been received\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_MRXDONE_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_MRXDONE_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_MRXDONE_SET = 1 , } impl From < INT_EVENT0_ISET_MRXDONE_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_MRXDONE_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_MRXDONE` writer - Master Receive Data Interrupt Signals that a byte has been received"] pub type INT_EVENT0_ISET_MRXDONE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_MRXDONE_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_MRXDONE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_mrxdone_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MRXDONE_AW :: INT_EVENT0_ISET_MRXDONE_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_mrxdone_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MRXDONE_AW :: INT_EVENT0_ISET_MRXDONE_SET) } } # [doc = "Master Transmit Transaction completed Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_MTXDONE_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_MTXDONE_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_MTXDONE_SET = 1 , } impl From < INT_EVENT0_ISET_MTXDONE_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_MTXDONE_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_MTXDONE` writer - Master Transmit Transaction completed Interrupt"] pub type INT_EVENT0_ISET_MTXDONE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_MTXDONE_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_MTXDONE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_mtxdone_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MTXDONE_AW :: INT_EVENT0_ISET_MTXDONE_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_mtxdone_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MTXDONE_AW :: INT_EVENT0_ISET_MTXDONE_SET) } } # [doc = "Master Receive FIFO Trigger Trigger when RX FIFO contains &amp;gt;= defined bytes\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_MRXFIFOTRG_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_MRXFIFOTRG_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_MRXFIFOTRG_SET = 1 , } impl From < INT_EVENT0_ISET_MRXFIFOTRG_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_MRXFIFOTRG_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_MRXFIFOTRG` writer - Master Receive FIFO Trigger Trigger when RX FIFO contains &amp;gt;= defined bytes"] pub type INT_EVENT0_ISET_MRXFIFOTRG_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_MRXFIFOTRG_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_MRXFIFOTRG_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_mrxfifotrg_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MRXFIFOTRG_AW :: INT_EVENT0_ISET_MRXFIFOTRG_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_mrxfifotrg_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MRXFIFOTRG_AW :: INT_EVENT0_ISET_MRXFIFOTRG_SET) } } # [doc = "Master Transmit FIFO Trigger Trigger when Transmit FIFO contains &amp;lt;= defined bytes\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_MTXFIFOTRG_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_MTXFIFOTRG_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_MTXFIFOTRG_SET = 1 , } impl From < INT_EVENT0_ISET_MTXFIFOTRG_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_MTXFIFOTRG_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_MTXFIFOTRG` writer - Master Transmit FIFO Trigger Trigger when Transmit FIFO contains &amp;lt;= defined bytes"] pub type INT_EVENT0_ISET_MTXFIFOTRG_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_MTXFIFOTRG_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_MTXFIFOTRG_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_mtxfifotrg_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MTXFIFOTRG_AW :: INT_EVENT0_ISET_MTXFIFOTRG_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_mtxfifotrg_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MTXFIFOTRG_AW :: INT_EVENT0_ISET_MTXFIFOTRG_SET) } } # [doc = "RXFIFO full event.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_MRXFIFOFULL_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_MRXFIFOFULL_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_MRXFIFOFULL_SET = 1 , } impl From < INT_EVENT0_ISET_MRXFIFOFULL_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_MRXFIFOFULL_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_MRXFIFOFULL` writer - RXFIFO full event."] pub type INT_EVENT0_ISET_MRXFIFOFULL_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_MRXFIFOFULL_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_MRXFIFOFULL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_mrxfifofull_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MRXFIFOFULL_AW :: INT_EVENT0_ISET_MRXFIFOFULL_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_mrxfifofull_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MRXFIFOFULL_AW :: INT_EVENT0_ISET_MRXFIFOFULL_SET) } } # [doc = "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_MTXEMPTY_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_MTXEMPTY_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_MTXEMPTY_SET = 1 , } impl From < INT_EVENT0_ISET_MTXEMPTY_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_MTXEMPTY_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_MTXEMPTY` writer - Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode."] pub type INT_EVENT0_ISET_MTXEMPTY_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_MTXEMPTY_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_MTXEMPTY_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_mtxempty_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MTXEMPTY_AW :: INT_EVENT0_ISET_MTXEMPTY_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_mtxempty_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MTXEMPTY_AW :: INT_EVENT0_ISET_MTXEMPTY_SET) } } # [doc = "Address/Data NACK Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_MNACK_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_MNACK_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_MNACK_SET = 1 , } impl From < INT_EVENT0_ISET_MNACK_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_MNACK_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_MNACK` writer - Address/Data NACK Interrupt"] pub type INT_EVENT0_ISET_MNACK_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_MNACK_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_MNACK_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_mnack_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MNACK_AW :: INT_EVENT0_ISET_MNACK_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_mnack_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MNACK_AW :: INT_EVENT0_ISET_MNACK_SET) } } # [doc = "START Detection Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_MSTART_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_MSTART_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_MSTART_SET = 1 , } impl From < INT_EVENT0_ISET_MSTART_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_MSTART_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_MSTART` writer - START Detection Interrupt"] pub type INT_EVENT0_ISET_MSTART_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_MSTART_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_MSTART_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_mstart_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MSTART_AW :: INT_EVENT0_ISET_MSTART_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_mstart_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MSTART_AW :: INT_EVENT0_ISET_MSTART_SET) } } # [doc = "STOP Detection Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_MSTOP_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_MSTOP_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_MSTOP_SET = 1 , } impl From < INT_EVENT0_ISET_MSTOP_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_MSTOP_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_MSTOP` writer - STOP Detection Interrupt"] pub type INT_EVENT0_ISET_MSTOP_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_MSTOP_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_MSTOP_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_mstop_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MSTOP_AW :: INT_EVENT0_ISET_MSTOP_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_mstop_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MSTOP_AW :: INT_EVENT0_ISET_MSTOP_SET) } } # [doc = "Arbitration Lost Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_MARBLOST_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_MARBLOST_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_MARBLOST_SET = 1 , } impl From < INT_EVENT0_ISET_MARBLOST_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_MARBLOST_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_MARBLOST` writer - Arbitration Lost Interrupt"] pub type INT_EVENT0_ISET_MARBLOST_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_MARBLOST_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_MARBLOST_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_marblost_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MARBLOST_AW :: INT_EVENT0_ISET_MARBLOST_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_marblost_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MARBLOST_AW :: INT_EVENT0_ISET_MARBLOST_SET) } } # [doc = "DMA Done 1 on Event Channel 2\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_MDMA_DONE1_2_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_MDMA_DONE1_2_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_MDMA_DONE1_2_SET = 1 , } impl From < INT_EVENT0_ISET_MDMA_DONE1_2_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_MDMA_DONE1_2_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_MDMA_DONE1_2` writer - DMA Done 1 on Event Channel 2"] pub type INT_EVENT0_ISET_MDMA_DONE1_2_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_MDMA_DONE1_2_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_MDMA_DONE1_2_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_mdma_done1_2_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MDMA_DONE1_2_AW :: INT_EVENT0_ISET_MDMA_DONE1_2_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_mdma_done1_2_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MDMA_DONE1_2_AW :: INT_EVENT0_ISET_MDMA_DONE1_2_SET) } } # [doc = "DMA Done 1 on Event Channel 3\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_MDMA_DONE1_3_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_MDMA_DONE1_3_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_MDMA_DONE1_3_SET = 1 , } impl From < INT_EVENT0_ISET_MDMA_DONE1_3_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_MDMA_DONE1_3_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_MDMA_DONE1_3` writer - DMA Done 1 on Event Channel 3"] pub type INT_EVENT0_ISET_MDMA_DONE1_3_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_MDMA_DONE1_3_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_MDMA_DONE1_3_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_mdma_done1_3_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MDMA_DONE1_3_AW :: INT_EVENT0_ISET_MDMA_DONE1_3_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_mdma_done1_3_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MDMA_DONE1_3_AW :: INT_EVENT0_ISET_MDMA_DONE1_3_SET) } } # [doc = "Master RX Pec Error Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_MPEC_RX_ERR_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_MPEC_RX_ERR_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_MPEC_RX_ERR_SET = 1 , } impl From < INT_EVENT0_ISET_MPEC_RX_ERR_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_MPEC_RX_ERR_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_MPEC_RX_ERR` writer - Master RX Pec Error Interrupt"] pub type INT_EVENT0_ISET_MPEC_RX_ERR_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_MPEC_RX_ERR_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_MPEC_RX_ERR_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_mpec_rx_err_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MPEC_RX_ERR_AW :: INT_EVENT0_ISET_MPEC_RX_ERR_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_mpec_rx_err_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_MPEC_RX_ERR_AW :: INT_EVENT0_ISET_MPEC_RX_ERR_SET) } } # [doc = "Timeout A interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_TIMEOUTA_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_TIMEOUTA_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_TIMEOUTA_SET = 1 , } impl From < INT_EVENT0_ISET_TIMEOUTA_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_TIMEOUTA_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_TIMEOUTA` writer - Timeout A interrupt"] pub type INT_EVENT0_ISET_TIMEOUTA_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_TIMEOUTA_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_TIMEOUTA_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_timeouta_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_TIMEOUTA_AW :: INT_EVENT0_ISET_TIMEOUTA_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_timeouta_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_TIMEOUTA_AW :: INT_EVENT0_ISET_TIMEOUTA_SET) } } # [doc = "Timeout B Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_TIMEOUTB_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_TIMEOUTB_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_TIMEOUTB_SET = 1 , } impl From < INT_EVENT0_ISET_TIMEOUTB_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_TIMEOUTB_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_TIMEOUTB` writer - Timeout B Interrupt"] pub type INT_EVENT0_ISET_TIMEOUTB_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_TIMEOUTB_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_TIMEOUTB_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_timeoutb_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_TIMEOUTB_AW :: INT_EVENT0_ISET_TIMEOUTB_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_timeoutb_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_TIMEOUTB_AW :: INT_EVENT0_ISET_TIMEOUTB_SET) } } # [doc = "Slave Receive Data Interrupt Signals that a byte has been received\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_SRXDONE_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_SRXDONE_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_SRXDONE_SET = 1 , } impl From < INT_EVENT0_ISET_SRXDONE_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_SRXDONE_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_SRXDONE` writer - Slave Receive Data Interrupt Signals that a byte has been received"] pub type INT_EVENT0_ISET_SRXDONE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_SRXDONE_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_SRXDONE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_srxdone_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_SRXDONE_AW :: INT_EVENT0_ISET_SRXDONE_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_srxdone_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_SRXDONE_AW :: INT_EVENT0_ISET_SRXDONE_SET) } } # [doc = "Slave Transmit Transaction completed Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_STXDONE_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_STXDONE_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_STXDONE_SET = 1 , } impl From < INT_EVENT0_ISET_STXDONE_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_STXDONE_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_STXDONE` writer - Slave Transmit Transaction completed Interrupt"] pub type INT_EVENT0_ISET_STXDONE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_STXDONE_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_STXDONE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_stxdone_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_STXDONE_AW :: INT_EVENT0_ISET_STXDONE_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_stxdone_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_STXDONE_AW :: INT_EVENT0_ISET_STXDONE_SET) } } # [doc = "Slave Receive FIFO Trigger\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_SRXFIFOTRG_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_SRXFIFOTRG_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_SRXFIFOTRG_SET = 1 , } impl From < INT_EVENT0_ISET_SRXFIFOTRG_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_SRXFIFOTRG_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_SRXFIFOTRG` writer - Slave Receive FIFO Trigger"] pub type INT_EVENT0_ISET_SRXFIFOTRG_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_SRXFIFOTRG_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_SRXFIFOTRG_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_srxfifotrg_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_SRXFIFOTRG_AW :: INT_EVENT0_ISET_SRXFIFOTRG_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_srxfifotrg_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_SRXFIFOTRG_AW :: INT_EVENT0_ISET_SRXFIFOTRG_SET) } } # [doc = "Slave Transmit FIFO Trigger\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_STXFIFOTRG_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_STXFIFOTRG_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_STXFIFOTRG_SET = 1 , } impl From < INT_EVENT0_ISET_STXFIFOTRG_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_STXFIFOTRG_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_STXFIFOTRG` writer - Slave Transmit FIFO Trigger"] pub type INT_EVENT0_ISET_STXFIFOTRG_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_STXFIFOTRG_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_STXFIFOTRG_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_stxfifotrg_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_STXFIFOTRG_AW :: INT_EVENT0_ISET_STXFIFOTRG_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_stxfifotrg_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_STXFIFOTRG_AW :: INT_EVENT0_ISET_STXFIFOTRG_SET) } } # [doc = "RXFIFO full event. This interrupt is set if an RX FIFO is full.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_SRXFIFOFULL_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_SRXFIFOFULL_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_SRXFIFOFULL_SET = 1 , } impl From < INT_EVENT0_ISET_SRXFIFOFULL_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_SRXFIFOFULL_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_SRXFIFOFULL` writer - RXFIFO full event. This interrupt is set if an RX FIFO is full."] pub type INT_EVENT0_ISET_SRXFIFOFULL_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_SRXFIFOFULL_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_SRXFIFOFULL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_srxfifofull_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_SRXFIFOFULL_AW :: INT_EVENT0_ISET_SRXFIFOFULL_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_srxfifofull_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_SRXFIFOFULL_AW :: INT_EVENT0_ISET_SRXFIFOFULL_SET) } } # [doc = "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_STXEMPTY_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_STXEMPTY_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_STXEMPTY_SET = 1 , } impl From < INT_EVENT0_ISET_STXEMPTY_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_STXEMPTY_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_STXEMPTY` writer - Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode."] pub type INT_EVENT0_ISET_STXEMPTY_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_STXEMPTY_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_STXEMPTY_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_stxempty_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_STXEMPTY_AW :: INT_EVENT0_ISET_STXEMPTY_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_stxempty_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_STXEMPTY_AW :: INT_EVENT0_ISET_STXEMPTY_SET) } } # [doc = "Start Condition Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_SSTART_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_SSTART_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_SSTART_SET = 1 , } impl From < INT_EVENT0_ISET_SSTART_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_SSTART_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_SSTART` writer - Start Condition Interrupt"] pub type INT_EVENT0_ISET_SSTART_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_SSTART_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_SSTART_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_sstart_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_SSTART_AW :: INT_EVENT0_ISET_SSTART_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_sstart_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_SSTART_AW :: INT_EVENT0_ISET_SSTART_SET) } } # [doc = "Stop Condition Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_SSTOP_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_SSTOP_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_SSTOP_SET = 1 , } impl From < INT_EVENT0_ISET_SSTOP_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_SSTOP_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_SSTOP` writer - Stop Condition Interrupt"] pub type INT_EVENT0_ISET_SSTOP_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_SSTOP_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_SSTOP_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_sstop_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_SSTOP_AW :: INT_EVENT0_ISET_SSTOP_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_sstop_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_SSTOP_AW :: INT_EVENT0_ISET_SSTOP_SET) } } # [doc = "General Call Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_SGENCALL_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_SGENCALL_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_SGENCALL_SET = 1 , } impl From < INT_EVENT0_ISET_SGENCALL_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_SGENCALL_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_SGENCALL` writer - General Call Interrupt"] pub type INT_EVENT0_ISET_SGENCALL_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_SGENCALL_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_SGENCALL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_sgencall_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_SGENCALL_AW :: INT_EVENT0_ISET_SGENCALL_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_sgencall_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_SGENCALL_AW :: INT_EVENT0_ISET_SGENCALL_SET) } } # [doc = "DMA Done 1 on Event Channel 2\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_SDMA_DONE1_2_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_SDMA_DONE1_2_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_SDMA_DONE1_2_SET = 1 , } impl From < INT_EVENT0_ISET_SDMA_DONE1_2_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_SDMA_DONE1_2_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_SDMA_DONE1_2` writer - DMA Done 1 on Event Channel 2"] pub type INT_EVENT0_ISET_SDMA_DONE1_2_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_SDMA_DONE1_2_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_SDMA_DONE1_2_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_sdma_done1_2_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_SDMA_DONE1_2_AW :: INT_EVENT0_ISET_SDMA_DONE1_2_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_sdma_done1_2_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_SDMA_DONE1_2_AW :: INT_EVENT0_ISET_SDMA_DONE1_2_SET) } } # [doc = "DMA Done 1 on Event Channel 3\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_SDMA_DONE1_3_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_SDMA_DONE1_3_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_SDMA_DONE1_3_SET = 1 , } impl From < INT_EVENT0_ISET_SDMA_DONE1_3_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_SDMA_DONE1_3_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_SDMA_DONE1_3` writer - DMA Done 1 on Event Channel 3"] pub type INT_EVENT0_ISET_SDMA_DONE1_3_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_SDMA_DONE1_3_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_SDMA_DONE1_3_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_sdma_done1_3_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_SDMA_DONE1_3_AW :: INT_EVENT0_ISET_SDMA_DONE1_3_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_sdma_done1_3_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_SDMA_DONE1_3_AW :: INT_EVENT0_ISET_SDMA_DONE1_3_SET) } } # [doc = "Slave RX Pec Error Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_SPEC_RX_ERR_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_SPEC_RX_ERR_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_SPEC_RX_ERR_SET = 1 , } impl From < INT_EVENT0_ISET_SPEC_RX_ERR_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_SPEC_RX_ERR_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_SPEC_RX_ERR` writer - Slave RX Pec Error Interrupt"] pub type INT_EVENT0_ISET_SPEC_RX_ERR_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_SPEC_RX_ERR_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_SPEC_RX_ERR_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_spec_rx_err_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_SPEC_RX_ERR_AW :: INT_EVENT0_ISET_SPEC_RX_ERR_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_spec_rx_err_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_SPEC_RX_ERR_AW :: INT_EVENT0_ISET_SPEC_RX_ERR_SET) } } # [doc = "Slave TX FIFO underflow\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_STX_UNFL_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_STX_UNFL_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_STX_UNFL_SET = 1 , } impl From < INT_EVENT0_ISET_STX_UNFL_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_STX_UNFL_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_STX_UNFL` writer - Slave TX FIFO underflow"] pub type INT_EVENT0_ISET_STX_UNFL_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_STX_UNFL_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_STX_UNFL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_stx_unfl_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_STX_UNFL_AW :: INT_EVENT0_ISET_STX_UNFL_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_stx_unfl_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_STX_UNFL_AW :: INT_EVENT0_ISET_STX_UNFL_SET) } } # [doc = "Slave RX FIFO overflow\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_SRX_OVFL_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_SRX_OVFL_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_SRX_OVFL_SET = 1 , } impl From < INT_EVENT0_ISET_SRX_OVFL_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_SRX_OVFL_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_SRX_OVFL` writer - Slave RX FIFO overflow"] pub type INT_EVENT0_ISET_SRX_OVFL_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_SRX_OVFL_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_SRX_OVFL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_srx_ovfl_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_SRX_OVFL_AW :: INT_EVENT0_ISET_SRX_OVFL_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_srx_ovfl_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_SRX_OVFL_AW :: INT_EVENT0_ISET_SRX_OVFL_SET) } } # [doc = "Slave Arbitration Lost\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_SARBLOST_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_SARBLOST_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_SARBLOST_SET = 1 , } impl From < INT_EVENT0_ISET_SARBLOST_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_SARBLOST_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_SARBLOST` writer - Slave Arbitration Lost"] pub type INT_EVENT0_ISET_SARBLOST_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_SARBLOST_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_SARBLOST_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_sarblost_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_SARBLOST_AW :: INT_EVENT0_ISET_SARBLOST_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_sarblost_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_SARBLOST_AW :: INT_EVENT0_ISET_SARBLOST_SET) } } # [doc = "Interrupt overflow\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_INTR_OVFL_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_INTR_OVFL_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_INTR_OVFL_SET = 1 , } impl From < INT_EVENT0_ISET_INTR_OVFL_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_INTR_OVFL_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_INTR_OVFL` writer - Interrupt overflow"] pub type INT_EVENT0_ISET_INTR_OVFL_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_INTR_OVFL_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_INTR_OVFL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_intr_ovfl_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_INTR_OVFL_AW :: INT_EVENT0_ISET_INTR_OVFL_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_intr_ovfl_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_INTR_OVFL_AW :: INT_EVENT0_ISET_INTR_OVFL_SET) } } impl W { # [doc = "Bit 0 - Master Receive Data Interrupt Signals that a byte has been received"] # [inline (always)] # [must_use] pub fn int_event0_iset_mrxdone (& mut self) -> INT_EVENT0_ISET_MRXDONE_W < INT_EVENT0_ISET_SPEC , 0 > { INT_EVENT0_ISET_MRXDONE_W :: new (self) } # [doc = "Bit 1 - Master Transmit Transaction completed Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iset_mtxdone (& mut self) -> INT_EVENT0_ISET_MTXDONE_W < INT_EVENT0_ISET_SPEC , 1 > { INT_EVENT0_ISET_MTXDONE_W :: new (self) } # [doc = "Bit 2 - Master Receive FIFO Trigger Trigger when RX FIFO contains &amp;gt;= defined bytes"] # [inline (always)] # [must_use] pub fn int_event0_iset_mrxfifotrg (& mut self) -> INT_EVENT0_ISET_MRXFIFOTRG_W < INT_EVENT0_ISET_SPEC , 2 > { INT_EVENT0_ISET_MRXFIFOTRG_W :: new (self) } # [doc = "Bit 3 - Master Transmit FIFO Trigger Trigger when Transmit FIFO contains &amp;lt;= defined bytes"] # [inline (always)] # [must_use] pub fn int_event0_iset_mtxfifotrg (& mut self) -> INT_EVENT0_ISET_MTXFIFOTRG_W < INT_EVENT0_ISET_SPEC , 3 > { INT_EVENT0_ISET_MTXFIFOTRG_W :: new (self) } # [doc = "Bit 4 - RXFIFO full event."] # [inline (always)] # [must_use] pub fn int_event0_iset_mrxfifofull (& mut self) -> INT_EVENT0_ISET_MRXFIFOFULL_W < INT_EVENT0_ISET_SPEC , 4 > { INT_EVENT0_ISET_MRXFIFOFULL_W :: new (self) } # [doc = "Bit 5 - Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode."] # [inline (always)] # [must_use] pub fn int_event0_iset_mtxempty (& mut self) -> INT_EVENT0_ISET_MTXEMPTY_W < INT_EVENT0_ISET_SPEC , 5 > { INT_EVENT0_ISET_MTXEMPTY_W :: new (self) } # [doc = "Bit 7 - Address/Data NACK Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iset_mnack (& mut self) -> INT_EVENT0_ISET_MNACK_W < INT_EVENT0_ISET_SPEC , 7 > { INT_EVENT0_ISET_MNACK_W :: new (self) } # [doc = "Bit 8 - START Detection Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iset_mstart (& mut self) -> INT_EVENT0_ISET_MSTART_W < INT_EVENT0_ISET_SPEC , 8 > { INT_EVENT0_ISET_MSTART_W :: new (self) } # [doc = "Bit 9 - STOP Detection Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iset_mstop (& mut self) -> INT_EVENT0_ISET_MSTOP_W < INT_EVENT0_ISET_SPEC , 9 > { INT_EVENT0_ISET_MSTOP_W :: new (self) } # [doc = "Bit 10 - Arbitration Lost Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iset_marblost (& mut self) -> INT_EVENT0_ISET_MARBLOST_W < INT_EVENT0_ISET_SPEC , 10 > { INT_EVENT0_ISET_MARBLOST_W :: new (self) } # [doc = "Bit 11 - DMA Done 1 on Event Channel 2"] # [inline (always)] # [must_use] pub fn int_event0_iset_mdma_done1_2 (& mut self) -> INT_EVENT0_ISET_MDMA_DONE1_2_W < INT_EVENT0_ISET_SPEC , 11 > { INT_EVENT0_ISET_MDMA_DONE1_2_W :: new (self) } # [doc = "Bit 12 - DMA Done 1 on Event Channel 3"] # [inline (always)] # [must_use] pub fn int_event0_iset_mdma_done1_3 (& mut self) -> INT_EVENT0_ISET_MDMA_DONE1_3_W < INT_EVENT0_ISET_SPEC , 12 > { INT_EVENT0_ISET_MDMA_DONE1_3_W :: new (self) } # [doc = "Bit 13 - Master RX Pec Error Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iset_mpec_rx_err (& mut self) -> INT_EVENT0_ISET_MPEC_RX_ERR_W < INT_EVENT0_ISET_SPEC , 13 > { INT_EVENT0_ISET_MPEC_RX_ERR_W :: new (self) } # [doc = "Bit 14 - Timeout A interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iset_timeouta (& mut self) -> INT_EVENT0_ISET_TIMEOUTA_W < INT_EVENT0_ISET_SPEC , 14 > { INT_EVENT0_ISET_TIMEOUTA_W :: new (self) } # [doc = "Bit 15 - Timeout B Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iset_timeoutb (& mut self) -> INT_EVENT0_ISET_TIMEOUTB_W < INT_EVENT0_ISET_SPEC , 15 > { INT_EVENT0_ISET_TIMEOUTB_W :: new (self) } # [doc = "Bit 16 - Slave Receive Data Interrupt Signals that a byte has been received"] # [inline (always)] # [must_use] pub fn int_event0_iset_srxdone (& mut self) -> INT_EVENT0_ISET_SRXDONE_W < INT_EVENT0_ISET_SPEC , 16 > { INT_EVENT0_ISET_SRXDONE_W :: new (self) } # [doc = "Bit 17 - Slave Transmit Transaction completed Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iset_stxdone (& mut self) -> INT_EVENT0_ISET_STXDONE_W < INT_EVENT0_ISET_SPEC , 17 > { INT_EVENT0_ISET_STXDONE_W :: new (self) } # [doc = "Bit 18 - Slave Receive FIFO Trigger"] # [inline (always)] # [must_use] pub fn int_event0_iset_srxfifotrg (& mut self) -> INT_EVENT0_ISET_SRXFIFOTRG_W < INT_EVENT0_ISET_SPEC , 18 > { INT_EVENT0_ISET_SRXFIFOTRG_W :: new (self) } # [doc = "Bit 19 - Slave Transmit FIFO Trigger"] # [inline (always)] # [must_use] pub fn int_event0_iset_stxfifotrg (& mut self) -> INT_EVENT0_ISET_STXFIFOTRG_W < INT_EVENT0_ISET_SPEC , 19 > { INT_EVENT0_ISET_STXFIFOTRG_W :: new (self) } # [doc = "Bit 20 - RXFIFO full event. This interrupt is set if an RX FIFO is full."] # [inline (always)] # [must_use] pub fn int_event0_iset_srxfifofull (& mut self) -> INT_EVENT0_ISET_SRXFIFOFULL_W < INT_EVENT0_ISET_SPEC , 20 > { INT_EVENT0_ISET_SRXFIFOFULL_W :: new (self) } # [doc = "Bit 21 - Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode."] # [inline (always)] # [must_use] pub fn int_event0_iset_stxempty (& mut self) -> INT_EVENT0_ISET_STXEMPTY_W < INT_EVENT0_ISET_SPEC , 21 > { INT_EVENT0_ISET_STXEMPTY_W :: new (self) } # [doc = "Bit 22 - Start Condition Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iset_sstart (& mut self) -> INT_EVENT0_ISET_SSTART_W < INT_EVENT0_ISET_SPEC , 22 > { INT_EVENT0_ISET_SSTART_W :: new (self) } # [doc = "Bit 23 - Stop Condition Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iset_sstop (& mut self) -> INT_EVENT0_ISET_SSTOP_W < INT_EVENT0_ISET_SPEC , 23 > { INT_EVENT0_ISET_SSTOP_W :: new (self) } # [doc = "Bit 24 - General Call Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iset_sgencall (& mut self) -> INT_EVENT0_ISET_SGENCALL_W < INT_EVENT0_ISET_SPEC , 24 > { INT_EVENT0_ISET_SGENCALL_W :: new (self) } # [doc = "Bit 25 - DMA Done 1 on Event Channel 2"] # [inline (always)] # [must_use] pub fn int_event0_iset_sdma_done1_2 (& mut self) -> INT_EVENT0_ISET_SDMA_DONE1_2_W < INT_EVENT0_ISET_SPEC , 25 > { INT_EVENT0_ISET_SDMA_DONE1_2_W :: new (self) } # [doc = "Bit 26 - DMA Done 1 on Event Channel 3"] # [inline (always)] # [must_use] pub fn int_event0_iset_sdma_done1_3 (& mut self) -> INT_EVENT0_ISET_SDMA_DONE1_3_W < INT_EVENT0_ISET_SPEC , 26 > { INT_EVENT0_ISET_SDMA_DONE1_3_W :: new (self) } # [doc = "Bit 27 - Slave RX Pec Error Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iset_spec_rx_err (& mut self) -> INT_EVENT0_ISET_SPEC_RX_ERR_W < INT_EVENT0_ISET_SPEC , 27 > { INT_EVENT0_ISET_SPEC_RX_ERR_W :: new (self) } # [doc = "Bit 28 - Slave TX FIFO underflow"] # [inline (always)] # [must_use] pub fn int_event0_iset_stx_unfl (& mut self) -> INT_EVENT0_ISET_STX_UNFL_W < INT_EVENT0_ISET_SPEC , 28 > { INT_EVENT0_ISET_STX_UNFL_W :: new (self) } # [doc = "Bit 29 - Slave RX FIFO overflow"] # [inline (always)] # [must_use] pub fn int_event0_iset_srx_ovfl (& mut self) -> INT_EVENT0_ISET_SRX_OVFL_W < INT_EVENT0_ISET_SPEC , 29 > { INT_EVENT0_ISET_SRX_OVFL_W :: new (self) } # [doc = "Bit 30 - Slave Arbitration Lost"] # [inline (always)] # [must_use] pub fn int_event0_iset_sarblost (& mut self) -> INT_EVENT0_ISET_SARBLOST_W < INT_EVENT0_ISET_SPEC , 30 > { INT_EVENT0_ISET_SARBLOST_W :: new (self) } # [doc = "Bit 31 - Interrupt overflow"] # [inline (always)] # [must_use] pub fn int_event0_iset_intr_ovfl (& mut self) -> INT_EVENT0_ISET_INTR_OVFL_W < INT_EVENT0_ISET_SPEC , 31 > { INT_EVENT0_ISET_INTR_OVFL_W :: new (self) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Interrupt set\n\nYou can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_event0_iset::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT_EVENT0_ISET_SPEC ; impl crate :: RegisterSpec for INT_EVENT0_ISET_SPEC { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`int_event0_iset::W`](W) writer structure"] impl crate :: Writable for INT_EVENT0_ISET_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT_EVENT0_ISET to value 0"] impl crate :: Resettable for INT_EVENT0_ISET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }