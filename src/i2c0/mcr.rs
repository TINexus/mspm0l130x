# [doc = "Register `MCR` reader"] pub type R = crate :: R < MCR_SPEC > ; # [doc = "Register `MCR` writer"] pub type W = crate :: W < MCR_SPEC > ; # [doc = "Field `MCR_ACTIVE` reader - Device Active After this bit has been set, it should not be set again unless it has been cleared by writing a 0 or by a reset, otherwise transfer failures may occur."] pub type MCR_ACTIVE_R = crate :: BitReader < MCR_ACTIVE_A > ; # [doc = "Device Active After this bit has been set, it should not be set again unless it has been cleared by writing a 0 or by a reset, otherwise transfer failures may occur.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum MCR_ACTIVE_A { # [doc = "0: DISABLE"] MCR_ACTIVE_DISABLE = 0 , # [doc = "1: ENABLE"] MCR_ACTIVE_ENABLE = 1 , } impl From < MCR_ACTIVE_A > for bool { # [inline (always)] fn from (variant : MCR_ACTIVE_A) -> Self { variant as u8 != 0 } } impl MCR_ACTIVE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> MCR_ACTIVE_A { match self . bits { false => MCR_ACTIVE_A :: MCR_ACTIVE_DISABLE , true => MCR_ACTIVE_A :: MCR_ACTIVE_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_mcr_active_disable (& self) -> bool { * self == MCR_ACTIVE_A :: MCR_ACTIVE_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_mcr_active_enable (& self) -> bool { * self == MCR_ACTIVE_A :: MCR_ACTIVE_ENABLE } } # [doc = "Field `MCR_ACTIVE` writer - Device Active After this bit has been set, it should not be set again unless it has been cleared by writing a 0 or by a reset, otherwise transfer failures may occur."] pub type MCR_ACTIVE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , MCR_ACTIVE_A > ; impl < 'a , REG , const O : u8 > MCR_ACTIVE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn mcr_active_disable (self) -> & 'a mut crate :: W < REG > { self . variant (MCR_ACTIVE_A :: MCR_ACTIVE_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn mcr_active_enable (self) -> & 'a mut crate :: W < REG > { self . variant (MCR_ACTIVE_A :: MCR_ACTIVE_ENABLE) } } # [doc = "Field `MCR_MMST` reader - Multimaster mode. In Multimaster mode the SCL high time counts once the SCL line has been detected high. If this is not enabled the high time counts as soon as the SCL line has been set high by the I2C controller."] pub type MCR_MMST_R = crate :: BitReader < MCR_MMST_A > ; # [doc = "Multimaster mode. In Multimaster mode the SCL high time counts once the SCL line has been detected high. If this is not enabled the high time counts as soon as the SCL line has been set high by the I2C controller.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum MCR_MMST_A { # [doc = "0: DISABLE"] MCR_MMST_DISABLE = 0 , # [doc = "1: ENABLE"] MCR_MMST_ENABLE = 1 , } impl From < MCR_MMST_A > for bool { # [inline (always)] fn from (variant : MCR_MMST_A) -> Self { variant as u8 != 0 } } impl MCR_MMST_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> MCR_MMST_A { match self . bits { false => MCR_MMST_A :: MCR_MMST_DISABLE , true => MCR_MMST_A :: MCR_MMST_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_mcr_mmst_disable (& self) -> bool { * self == MCR_MMST_A :: MCR_MMST_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_mcr_mmst_enable (& self) -> bool { * self == MCR_MMST_A :: MCR_MMST_ENABLE } } # [doc = "Field `MCR_MMST` writer - Multimaster mode. In Multimaster mode the SCL high time counts once the SCL line has been detected high. If this is not enabled the high time counts as soon as the SCL line has been set high by the I2C controller."] pub type MCR_MMST_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , MCR_MMST_A > ; impl < 'a , REG , const O : u8 > MCR_MMST_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn mcr_mmst_disable (self) -> & 'a mut crate :: W < REG > { self . variant (MCR_MMST_A :: MCR_MMST_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn mcr_mmst_enable (self) -> & 'a mut crate :: W < REG > { self . variant (MCR_MMST_A :: MCR_MMST_ENABLE) } } # [doc = "Field `MCR_CLKSTRETCH` reader - Clock Stretching. This bit controls the support for clock stretching of the I2C bus."] pub type MCR_CLKSTRETCH_R = crate :: BitReader < MCR_CLKSTRETCH_A > ; # [doc = "Clock Stretching. This bit controls the support for clock stretching of the I2C bus.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum MCR_CLKSTRETCH_A { # [doc = "0: DISABLE"] MCR_CLKSTRETCH_DISABLE = 0 , # [doc = "1: ENABLE"] MCR_CLKSTRETCH_ENABLE = 1 , } impl From < MCR_CLKSTRETCH_A > for bool { # [inline (always)] fn from (variant : MCR_CLKSTRETCH_A) -> Self { variant as u8 != 0 } } impl MCR_CLKSTRETCH_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> MCR_CLKSTRETCH_A { match self . bits { false => MCR_CLKSTRETCH_A :: MCR_CLKSTRETCH_DISABLE , true => MCR_CLKSTRETCH_A :: MCR_CLKSTRETCH_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_mcr_clkstretch_disable (& self) -> bool { * self == MCR_CLKSTRETCH_A :: MCR_CLKSTRETCH_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_mcr_clkstretch_enable (& self) -> bool { * self == MCR_CLKSTRETCH_A :: MCR_CLKSTRETCH_ENABLE } } # [doc = "Field `MCR_CLKSTRETCH` writer - Clock Stretching. This bit controls the support for clock stretching of the I2C bus."] pub type MCR_CLKSTRETCH_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , MCR_CLKSTRETCH_A > ; impl < 'a , REG , const O : u8 > MCR_CLKSTRETCH_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn mcr_clkstretch_disable (self) -> & 'a mut crate :: W < REG > { self . variant (MCR_CLKSTRETCH_A :: MCR_CLKSTRETCH_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn mcr_clkstretch_enable (self) -> & 'a mut crate :: W < REG > { self . variant (MCR_CLKSTRETCH_A :: MCR_CLKSTRETCH_ENABLE) } } # [doc = "Field `MCR_LPBK` reader - I2C Loopback"] pub type MCR_LPBK_R = crate :: BitReader < MCR_LPBK_A > ; # [doc = "I2C Loopback\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum MCR_LPBK_A { # [doc = "0: DISABLE"] MCR_LPBK_DISABLE = 0 , # [doc = "1: ENABLE"] MCR_LPBK_ENABLE = 1 , } impl From < MCR_LPBK_A > for bool { # [inline (always)] fn from (variant : MCR_LPBK_A) -> Self { variant as u8 != 0 } } impl MCR_LPBK_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> MCR_LPBK_A { match self . bits { false => MCR_LPBK_A :: MCR_LPBK_DISABLE , true => MCR_LPBK_A :: MCR_LPBK_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_mcr_lpbk_disable (& self) -> bool { * self == MCR_LPBK_A :: MCR_LPBK_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_mcr_lpbk_enable (& self) -> bool { * self == MCR_LPBK_A :: MCR_LPBK_ENABLE } } # [doc = "Field `MCR_LPBK` writer - I2C Loopback"] pub type MCR_LPBK_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , MCR_LPBK_A > ; impl < 'a , REG , const O : u8 > MCR_LPBK_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn mcr_lpbk_disable (self) -> & 'a mut crate :: W < REG > { self . variant (MCR_LPBK_A :: MCR_LPBK_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn mcr_lpbk_enable (self) -> & 'a mut crate :: W < REG > { self . variant (MCR_LPBK_A :: MCR_LPBK_ENABLE) } } impl R { # [doc = "Bit 0 - Device Active After this bit has been set, it should not be set again unless it has been cleared by writing a 0 or by a reset, otherwise transfer failures may occur."] # [inline (always)] pub fn mcr_active (& self) -> MCR_ACTIVE_R { MCR_ACTIVE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Multimaster mode. In Multimaster mode the SCL high time counts once the SCL line has been detected high. If this is not enabled the high time counts as soon as the SCL line has been set high by the I2C controller."] # [inline (always)] pub fn mcr_mmst (& self) -> MCR_MMST_R { MCR_MMST_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Clock Stretching. This bit controls the support for clock stretching of the I2C bus."] # [inline (always)] pub fn mcr_clkstretch (& self) -> MCR_CLKSTRETCH_R { MCR_CLKSTRETCH_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 8 - I2C Loopback"] # [inline (always)] pub fn mcr_lpbk (& self) -> MCR_LPBK_R { MCR_LPBK_R :: new (((self . bits >> 8) & 1) != 0) } } impl W { # [doc = "Bit 0 - Device Active After this bit has been set, it should not be set again unless it has been cleared by writing a 0 or by a reset, otherwise transfer failures may occur."] # [inline (always)] # [must_use] pub fn mcr_active (& mut self) -> MCR_ACTIVE_W < MCR_SPEC , 0 > { MCR_ACTIVE_W :: new (self) } # [doc = "Bit 1 - Multimaster mode. In Multimaster mode the SCL high time counts once the SCL line has been detected high. If this is not enabled the high time counts as soon as the SCL line has been set high by the I2C controller."] # [inline (always)] # [must_use] pub fn mcr_mmst (& mut self) -> MCR_MMST_W < MCR_SPEC , 1 > { MCR_MMST_W :: new (self) } # [doc = "Bit 2 - Clock Stretching. This bit controls the support for clock stretching of the I2C bus."] # [inline (always)] # [must_use] pub fn mcr_clkstretch (& mut self) -> MCR_CLKSTRETCH_W < MCR_SPEC , 2 > { MCR_CLKSTRETCH_W :: new (self) } # [doc = "Bit 8 - I2C Loopback"] # [inline (always)] # [must_use] pub fn mcr_lpbk (& mut self) -> MCR_LPBK_W < MCR_SPEC , 8 > { MCR_LPBK_W :: new (self) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "I2C Master Configuration\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`mcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MCR_SPEC ; impl crate :: RegisterSpec for MCR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`mcr::R`](R) reader structure"] impl crate :: Readable for MCR_SPEC { } # [doc = "`write(|w| ..)` method takes [`mcr::W`](W) writer structure"] impl crate :: Writable for MCR_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MCR to value 0"] impl crate :: Resettable for MCR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }