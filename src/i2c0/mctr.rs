# [doc = "Register `MCTR` reader"] pub type R = crate :: R < MCTR_SPEC > ; # [doc = "Register `MCTR` writer"] pub type W = crate :: W < MCTR_SPEC > ; # [doc = "Field `MCTR_BURSTRUN` reader - I2C Master Enable and start transaction"] pub type MCTR_BURSTRUN_R = crate :: BitReader < MCTR_BURSTRUN_A > ; # [doc = "I2C Master Enable and start transaction\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum MCTR_BURSTRUN_A { # [doc = "0: DISABLE"] MCTR_BURSTRUN_DISABLE = 0 , # [doc = "1: ENABLE"] MCTR_BURSTRUN_ENABLE = 1 , } impl From < MCTR_BURSTRUN_A > for bool { # [inline (always)] fn from (variant : MCTR_BURSTRUN_A) -> Self { variant as u8 != 0 } } impl MCTR_BURSTRUN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> MCTR_BURSTRUN_A { match self . bits { false => MCTR_BURSTRUN_A :: MCTR_BURSTRUN_DISABLE , true => MCTR_BURSTRUN_A :: MCTR_BURSTRUN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_mctr_burstrun_disable (& self) -> bool { * self == MCTR_BURSTRUN_A :: MCTR_BURSTRUN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_mctr_burstrun_enable (& self) -> bool { * self == MCTR_BURSTRUN_A :: MCTR_BURSTRUN_ENABLE } } # [doc = "Field `MCTR_BURSTRUN` writer - I2C Master Enable and start transaction"] pub type MCTR_BURSTRUN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , MCTR_BURSTRUN_A > ; impl < 'a , REG , const O : u8 > MCTR_BURSTRUN_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn mctr_burstrun_disable (self) -> & 'a mut crate :: W < REG > { self . variant (MCTR_BURSTRUN_A :: MCTR_BURSTRUN_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn mctr_burstrun_enable (self) -> & 'a mut crate :: W < REG > { self . variant (MCTR_BURSTRUN_A :: MCTR_BURSTRUN_ENABLE) } } # [doc = "Field `MCTR_START` reader - Generate START"] pub type MCTR_START_R = crate :: BitReader < MCTR_START_A > ; # [doc = "Generate START\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum MCTR_START_A { # [doc = "0: DISABLE"] MCTR_START_DISABLE = 0 , # [doc = "1: ENABLE"] MCTR_START_ENABLE = 1 , } impl From < MCTR_START_A > for bool { # [inline (always)] fn from (variant : MCTR_START_A) -> Self { variant as u8 != 0 } } impl MCTR_START_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> MCTR_START_A { match self . bits { false => MCTR_START_A :: MCTR_START_DISABLE , true => MCTR_START_A :: MCTR_START_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_mctr_start_disable (& self) -> bool { * self == MCTR_START_A :: MCTR_START_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_mctr_start_enable (& self) -> bool { * self == MCTR_START_A :: MCTR_START_ENABLE } } # [doc = "Field `MCTR_START` writer - Generate START"] pub type MCTR_START_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , MCTR_START_A > ; impl < 'a , REG , const O : u8 > MCTR_START_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn mctr_start_disable (self) -> & 'a mut crate :: W < REG > { self . variant (MCTR_START_A :: MCTR_START_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn mctr_start_enable (self) -> & 'a mut crate :: W < REG > { self . variant (MCTR_START_A :: MCTR_START_ENABLE) } } # [doc = "Field `MCTR_STOP` reader - Generate STOP"] pub type MCTR_STOP_R = crate :: BitReader < MCTR_STOP_A > ; # [doc = "Generate STOP\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum MCTR_STOP_A { # [doc = "0: DISABLE"] MCTR_STOP_DISABLE = 0 , # [doc = "1: ENABLE"] MCTR_STOP_ENABLE = 1 , } impl From < MCTR_STOP_A > for bool { # [inline (always)] fn from (variant : MCTR_STOP_A) -> Self { variant as u8 != 0 } } impl MCTR_STOP_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> MCTR_STOP_A { match self . bits { false => MCTR_STOP_A :: MCTR_STOP_DISABLE , true => MCTR_STOP_A :: MCTR_STOP_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_mctr_stop_disable (& self) -> bool { * self == MCTR_STOP_A :: MCTR_STOP_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_mctr_stop_enable (& self) -> bool { * self == MCTR_STOP_A :: MCTR_STOP_ENABLE } } # [doc = "Field `MCTR_STOP` writer - Generate STOP"] pub type MCTR_STOP_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , MCTR_STOP_A > ; impl < 'a , REG , const O : u8 > MCTR_STOP_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn mctr_stop_disable (self) -> & 'a mut crate :: W < REG > { self . variant (MCTR_STOP_A :: MCTR_STOP_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn mctr_stop_enable (self) -> & 'a mut crate :: W < REG > { self . variant (MCTR_STOP_A :: MCTR_STOP_ENABLE) } } # [doc = "Field `MCTR_ACK` reader - Data Acknowledge Enable. Software needs to configure this bit to send the ACK or NACK. See field decoding in Table: MCTR Field decoding."] pub type MCTR_ACK_R = crate :: BitReader < MCTR_ACK_A > ; # [doc = "Data Acknowledge Enable. Software needs to configure this bit to send the ACK or NACK. See field decoding in Table: MCTR Field decoding.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum MCTR_ACK_A { # [doc = "0: DISABLE"] MCTR_ACK_DISABLE = 0 , # [doc = "1: ENABLE"] MCTR_ACK_ENABLE = 1 , } impl From < MCTR_ACK_A > for bool { # [inline (always)] fn from (variant : MCTR_ACK_A) -> Self { variant as u8 != 0 } } impl MCTR_ACK_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> MCTR_ACK_A { match self . bits { false => MCTR_ACK_A :: MCTR_ACK_DISABLE , true => MCTR_ACK_A :: MCTR_ACK_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_mctr_ack_disable (& self) -> bool { * self == MCTR_ACK_A :: MCTR_ACK_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_mctr_ack_enable (& self) -> bool { * self == MCTR_ACK_A :: MCTR_ACK_ENABLE } } # [doc = "Field `MCTR_ACK` writer - Data Acknowledge Enable. Software needs to configure this bit to send the ACK or NACK. See field decoding in Table: MCTR Field decoding."] pub type MCTR_ACK_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , MCTR_ACK_A > ; impl < 'a , REG , const O : u8 > MCTR_ACK_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn mctr_ack_disable (self) -> & 'a mut crate :: W < REG > { self . variant (MCTR_ACK_A :: MCTR_ACK_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn mctr_ack_enable (self) -> & 'a mut crate :: W < REG > { self . variant (MCTR_ACK_A :: MCTR_ACK_ENABLE) } } # [doc = "Field `MCTR_MACKOEN` reader - Master ACK overrride Enable"] pub type MCTR_MACKOEN_R = crate :: BitReader < MCTR_MACKOEN_A > ; # [doc = "Master ACK overrride Enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum MCTR_MACKOEN_A { # [doc = "0: DISABLE"] MCTR_MACKOEN_DISABLE = 0 , # [doc = "1: ENABLE"] MCTR_MACKOEN_ENABLE = 1 , } impl From < MCTR_MACKOEN_A > for bool { # [inline (always)] fn from (variant : MCTR_MACKOEN_A) -> Self { variant as u8 != 0 } } impl MCTR_MACKOEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> MCTR_MACKOEN_A { match self . bits { false => MCTR_MACKOEN_A :: MCTR_MACKOEN_DISABLE , true => MCTR_MACKOEN_A :: MCTR_MACKOEN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_mctr_mackoen_disable (& self) -> bool { * self == MCTR_MACKOEN_A :: MCTR_MACKOEN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_mctr_mackoen_enable (& self) -> bool { * self == MCTR_MACKOEN_A :: MCTR_MACKOEN_ENABLE } } # [doc = "Field `MCTR_MACKOEN` writer - Master ACK overrride Enable"] pub type MCTR_MACKOEN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , MCTR_MACKOEN_A > ; impl < 'a , REG , const O : u8 > MCTR_MACKOEN_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn mctr_mackoen_disable (self) -> & 'a mut crate :: W < REG > { self . variant (MCTR_MACKOEN_A :: MCTR_MACKOEN_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn mctr_mackoen_enable (self) -> & 'a mut crate :: W < REG > { self . variant (MCTR_MACKOEN_A :: MCTR_MACKOEN_ENABLE) } } # [doc = "Field `MCTR_RD_ON_TXEMPTY` reader - Read on TX Empty"] pub type MCTR_RD_ON_TXEMPTY_R = crate :: BitReader < MCTR_RD_ON_TXEMPTY_A > ; # [doc = "Read on TX Empty\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum MCTR_RD_ON_TXEMPTY_A { # [doc = "0: DISABLE"] MCTR_RD_ON_TXEMPTY_DISABLE = 0 , # [doc = "1: ENABLE"] MCTR_RD_ON_TXEMPTY_ENABLE = 1 , } impl From < MCTR_RD_ON_TXEMPTY_A > for bool { # [inline (always)] fn from (variant : MCTR_RD_ON_TXEMPTY_A) -> Self { variant as u8 != 0 } } impl MCTR_RD_ON_TXEMPTY_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> MCTR_RD_ON_TXEMPTY_A { match self . bits { false => MCTR_RD_ON_TXEMPTY_A :: MCTR_RD_ON_TXEMPTY_DISABLE , true => MCTR_RD_ON_TXEMPTY_A :: MCTR_RD_ON_TXEMPTY_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_mctr_rd_on_txempty_disable (& self) -> bool { * self == MCTR_RD_ON_TXEMPTY_A :: MCTR_RD_ON_TXEMPTY_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_mctr_rd_on_txempty_enable (& self) -> bool { * self == MCTR_RD_ON_TXEMPTY_A :: MCTR_RD_ON_TXEMPTY_ENABLE } } # [doc = "Field `MCTR_RD_ON_TXEMPTY` writer - Read on TX Empty"] pub type MCTR_RD_ON_TXEMPTY_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , MCTR_RD_ON_TXEMPTY_A > ; impl < 'a , REG , const O : u8 > MCTR_RD_ON_TXEMPTY_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn mctr_rd_on_txempty_disable (self) -> & 'a mut crate :: W < REG > { self . variant (MCTR_RD_ON_TXEMPTY_A :: MCTR_RD_ON_TXEMPTY_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn mctr_rd_on_txempty_enable (self) -> & 'a mut crate :: W < REG > { self . variant (MCTR_RD_ON_TXEMPTY_A :: MCTR_RD_ON_TXEMPTY_ENABLE) } } # [doc = "Field `MCTR_MBLEN` reader - I2C transaction length This field contains the programmed length of bytes of the Transaction."] pub type MCTR_MBLEN_R = crate :: FieldReader < u16 > ; # [doc = "Field `MCTR_MBLEN` writer - I2C transaction length This field contains the programmed length of bytes of the Transaction."] pub type MCTR_MBLEN_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 12 , O , u16 > ; impl R { # [doc = "Bit 0 - I2C Master Enable and start transaction"] # [inline (always)] pub fn mctr_burstrun (& self) -> MCTR_BURSTRUN_R { MCTR_BURSTRUN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Generate START"] # [inline (always)] pub fn mctr_start (& self) -> MCTR_START_R { MCTR_START_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Generate STOP"] # [inline (always)] pub fn mctr_stop (& self) -> MCTR_STOP_R { MCTR_STOP_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Data Acknowledge Enable. Software needs to configure this bit to send the ACK or NACK. See field decoding in Table: MCTR Field decoding."] # [inline (always)] pub fn mctr_ack (& self) -> MCTR_ACK_R { MCTR_ACK_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Master ACK overrride Enable"] # [inline (always)] pub fn mctr_mackoen (& self) -> MCTR_MACKOEN_R { MCTR_MACKOEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Read on TX Empty"] # [inline (always)] pub fn mctr_rd_on_txempty (& self) -> MCTR_RD_ON_TXEMPTY_R { MCTR_RD_ON_TXEMPTY_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bits 16:27 - I2C transaction length This field contains the programmed length of bytes of the Transaction."] # [inline (always)] pub fn mctr_mblen (& self) -> MCTR_MBLEN_R { MCTR_MBLEN_R :: new (((self . bits >> 16) & 0x0fff) as u16) } } impl W { # [doc = "Bit 0 - I2C Master Enable and start transaction"] # [inline (always)] # [must_use] pub fn mctr_burstrun (& mut self) -> MCTR_BURSTRUN_W < MCTR_SPEC , 0 > { MCTR_BURSTRUN_W :: new (self) } # [doc = "Bit 1 - Generate START"] # [inline (always)] # [must_use] pub fn mctr_start (& mut self) -> MCTR_START_W < MCTR_SPEC , 1 > { MCTR_START_W :: new (self) } # [doc = "Bit 2 - Generate STOP"] # [inline (always)] # [must_use] pub fn mctr_stop (& mut self) -> MCTR_STOP_W < MCTR_SPEC , 2 > { MCTR_STOP_W :: new (self) } # [doc = "Bit 3 - Data Acknowledge Enable. Software needs to configure this bit to send the ACK or NACK. See field decoding in Table: MCTR Field decoding."] # [inline (always)] # [must_use] pub fn mctr_ack (& mut self) -> MCTR_ACK_W < MCTR_SPEC , 3 > { MCTR_ACK_W :: new (self) } # [doc = "Bit 4 - Master ACK overrride Enable"] # [inline (always)] # [must_use] pub fn mctr_mackoen (& mut self) -> MCTR_MACKOEN_W < MCTR_SPEC , 4 > { MCTR_MACKOEN_W :: new (self) } # [doc = "Bit 5 - Read on TX Empty"] # [inline (always)] # [must_use] pub fn mctr_rd_on_txempty (& mut self) -> MCTR_RD_ON_TXEMPTY_W < MCTR_SPEC , 5 > { MCTR_RD_ON_TXEMPTY_W :: new (self) } # [doc = "Bits 16:27 - I2C transaction length This field contains the programmed length of bytes of the Transaction."] # [inline (always)] # [must_use] pub fn mctr_mblen (& mut self) -> MCTR_MBLEN_W < MCTR_SPEC , 16 > { MCTR_MBLEN_W :: new (self) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "I2C Master Control Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`mctr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mctr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MCTR_SPEC ; impl crate :: RegisterSpec for MCTR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`mctr::R`](R) reader structure"] impl crate :: Readable for MCTR_SPEC { } # [doc = "`write(|w| ..)` method takes [`mctr::W`](W) writer structure"] impl crate :: Writable for MCTR_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MCTR to value 0"] impl crate :: Resettable for MCTR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }