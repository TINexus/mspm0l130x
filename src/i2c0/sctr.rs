# [doc = "Register `SCTR` reader"] pub type R = crate :: R < SCTR_SPEC > ; # [doc = "Register `SCTR` writer"] pub type W = crate :: W < SCTR_SPEC > ; # [doc = "Field `SCTR_ACTIVE` reader - Device Active. Setting this bit enables the slave functionality."] pub type SCTR_ACTIVE_R = crate :: BitReader < SCTR_ACTIVE_A > ; # [doc = "Device Active. Setting this bit enables the slave functionality.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SCTR_ACTIVE_A { # [doc = "0: DISABLE"] SCTR_ACTIVE_DISABLE = 0 , # [doc = "1: ENABLE"] SCTR_ACTIVE_ENABLE = 1 , } impl From < SCTR_ACTIVE_A > for bool { # [inline (always)] fn from (variant : SCTR_ACTIVE_A) -> Self { variant as u8 != 0 } } impl SCTR_ACTIVE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SCTR_ACTIVE_A { match self . bits { false => SCTR_ACTIVE_A :: SCTR_ACTIVE_DISABLE , true => SCTR_ACTIVE_A :: SCTR_ACTIVE_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_sctr_active_disable (& self) -> bool { * self == SCTR_ACTIVE_A :: SCTR_ACTIVE_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_sctr_active_enable (& self) -> bool { * self == SCTR_ACTIVE_A :: SCTR_ACTIVE_ENABLE } } # [doc = "Field `SCTR_ACTIVE` writer - Device Active. Setting this bit enables the slave functionality."] pub type SCTR_ACTIVE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , SCTR_ACTIVE_A > ; impl < 'a , REG , const O : u8 > SCTR_ACTIVE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn sctr_active_disable (self) -> & 'a mut crate :: W < REG > { self . variant (SCTR_ACTIVE_A :: SCTR_ACTIVE_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn sctr_active_enable (self) -> & 'a mut crate :: W < REG > { self . variant (SCTR_ACTIVE_A :: SCTR_ACTIVE_ENABLE) } } # [doc = "Field `SCTR_GENCALL` reader - General call response enable. This bit is only available in UCBxI2COA0. Modify only when UCSWRST = 1. 0b = Do not respond to a general call 1b = Respond to a general call"] pub type SCTR_GENCALL_R = crate :: BitReader < SCTR_GENCALL_A > ; # [doc = "General call response enable. This bit is only available in UCBxI2COA0. Modify only when UCSWRST = 1. 0b = Do not respond to a general call 1b = Respond to a general call\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SCTR_GENCALL_A { # [doc = "0: DISABLE"] SCTR_GENCALL_DISABLE = 0 , # [doc = "1: ENABLE"] SCTR_GENCALL_ENABLE = 1 , } impl From < SCTR_GENCALL_A > for bool { # [inline (always)] fn from (variant : SCTR_GENCALL_A) -> Self { variant as u8 != 0 } } impl SCTR_GENCALL_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SCTR_GENCALL_A { match self . bits { false => SCTR_GENCALL_A :: SCTR_GENCALL_DISABLE , true => SCTR_GENCALL_A :: SCTR_GENCALL_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_sctr_gencall_disable (& self) -> bool { * self == SCTR_GENCALL_A :: SCTR_GENCALL_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_sctr_gencall_enable (& self) -> bool { * self == SCTR_GENCALL_A :: SCTR_GENCALL_ENABLE } } # [doc = "Field `SCTR_GENCALL` writer - General call response enable. This bit is only available in UCBxI2COA0. Modify only when UCSWRST = 1. 0b = Do not respond to a general call 1b = Respond to a general call"] pub type SCTR_GENCALL_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , SCTR_GENCALL_A > ; impl < 'a , REG , const O : u8 > SCTR_GENCALL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn sctr_gencall_disable (self) -> & 'a mut crate :: W < REG > { self . variant (SCTR_GENCALL_A :: SCTR_GENCALL_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn sctr_gencall_enable (self) -> & 'a mut crate :: W < REG > { self . variant (SCTR_GENCALL_A :: SCTR_GENCALL_ENABLE) } } # [doc = "Field `SCTR_SCLKSTRETCH` reader - Slave Clock Stretch Enable"] pub type SCTR_SCLKSTRETCH_R = crate :: BitReader < SCTR_SCLKSTRETCH_A > ; # [doc = "Slave Clock Stretch Enable\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SCTR_SCLKSTRETCH_A { # [doc = "0: DISABLE"] SCTR_SCLKSTRETCH_DISABLE = 0 , # [doc = "1: ENABLE"] SCTR_SCLKSTRETCH_ENABLE = 1 , } impl From < SCTR_SCLKSTRETCH_A > for bool { # [inline (always)] fn from (variant : SCTR_SCLKSTRETCH_A) -> Self { variant as u8 != 0 } } impl SCTR_SCLKSTRETCH_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SCTR_SCLKSTRETCH_A { match self . bits { false => SCTR_SCLKSTRETCH_A :: SCTR_SCLKSTRETCH_DISABLE , true => SCTR_SCLKSTRETCH_A :: SCTR_SCLKSTRETCH_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_sctr_sclkstretch_disable (& self) -> bool { * self == SCTR_SCLKSTRETCH_A :: SCTR_SCLKSTRETCH_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_sctr_sclkstretch_enable (& self) -> bool { * self == SCTR_SCLKSTRETCH_A :: SCTR_SCLKSTRETCH_ENABLE } } # [doc = "Field `SCTR_SCLKSTRETCH` writer - Slave Clock Stretch Enable"] pub type SCTR_SCLKSTRETCH_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , SCTR_SCLKSTRETCH_A > ; impl < 'a , REG , const O : u8 > SCTR_SCLKSTRETCH_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn sctr_sclkstretch_disable (self) -> & 'a mut crate :: W < REG > { self . variant (SCTR_SCLKSTRETCH_A :: SCTR_SCLKSTRETCH_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn sctr_sclkstretch_enable (self) -> & 'a mut crate :: W < REG > { self . variant (SCTR_SCLKSTRETCH_A :: SCTR_SCLKSTRETCH_ENABLE) } } # [doc = "Field `SCTR_TXEMPTY_ON_TREQ` reader - Tx Empty Interrupt on TREQ"] pub type SCTR_TXEMPTY_ON_TREQ_R = crate :: BitReader < SCTR_TXEMPTY_ON_TREQ_A > ; # [doc = "Tx Empty Interrupt on TREQ\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SCTR_TXEMPTY_ON_TREQ_A { # [doc = "0: DISABLE"] SCTR_TXEMPTY_ON_TREQ_DISABLE = 0 , # [doc = "1: ENABLE"] SCTR_TXEMPTY_ON_TREQ_ENABLE = 1 , } impl From < SCTR_TXEMPTY_ON_TREQ_A > for bool { # [inline (always)] fn from (variant : SCTR_TXEMPTY_ON_TREQ_A) -> Self { variant as u8 != 0 } } impl SCTR_TXEMPTY_ON_TREQ_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SCTR_TXEMPTY_ON_TREQ_A { match self . bits { false => SCTR_TXEMPTY_ON_TREQ_A :: SCTR_TXEMPTY_ON_TREQ_DISABLE , true => SCTR_TXEMPTY_ON_TREQ_A :: SCTR_TXEMPTY_ON_TREQ_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_sctr_txempty_on_treq_disable (& self) -> bool { * self == SCTR_TXEMPTY_ON_TREQ_A :: SCTR_TXEMPTY_ON_TREQ_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_sctr_txempty_on_treq_enable (& self) -> bool { * self == SCTR_TXEMPTY_ON_TREQ_A :: SCTR_TXEMPTY_ON_TREQ_ENABLE } } # [doc = "Field `SCTR_TXEMPTY_ON_TREQ` writer - Tx Empty Interrupt on TREQ"] pub type SCTR_TXEMPTY_ON_TREQ_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , SCTR_TXEMPTY_ON_TREQ_A > ; impl < 'a , REG , const O : u8 > SCTR_TXEMPTY_ON_TREQ_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn sctr_txempty_on_treq_disable (self) -> & 'a mut crate :: W < REG > { self . variant (SCTR_TXEMPTY_ON_TREQ_A :: SCTR_TXEMPTY_ON_TREQ_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn sctr_txempty_on_treq_enable (self) -> & 'a mut crate :: W < REG > { self . variant (SCTR_TXEMPTY_ON_TREQ_A :: SCTR_TXEMPTY_ON_TREQ_ENABLE) } } # [doc = "Field `SCTR_TXTRIG_TXMODE` reader - Tx Trigger when slave FSM is in Tx Mode"] pub type SCTR_TXTRIG_TXMODE_R = crate :: BitReader < SCTR_TXTRIG_TXMODE_A > ; # [doc = "Tx Trigger when slave FSM is in Tx Mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SCTR_TXTRIG_TXMODE_A { # [doc = "0: DISABLE"] SCTR_TXTRIG_TXMODE_DISABLE = 0 , # [doc = "1: ENABLE"] SCTR_TXTRIG_TXMODE_ENABLE = 1 , } impl From < SCTR_TXTRIG_TXMODE_A > for bool { # [inline (always)] fn from (variant : SCTR_TXTRIG_TXMODE_A) -> Self { variant as u8 != 0 } } impl SCTR_TXTRIG_TXMODE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SCTR_TXTRIG_TXMODE_A { match self . bits { false => SCTR_TXTRIG_TXMODE_A :: SCTR_TXTRIG_TXMODE_DISABLE , true => SCTR_TXTRIG_TXMODE_A :: SCTR_TXTRIG_TXMODE_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_sctr_txtrig_txmode_disable (& self) -> bool { * self == SCTR_TXTRIG_TXMODE_A :: SCTR_TXTRIG_TXMODE_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_sctr_txtrig_txmode_enable (& self) -> bool { * self == SCTR_TXTRIG_TXMODE_A :: SCTR_TXTRIG_TXMODE_ENABLE } } # [doc = "Field `SCTR_TXTRIG_TXMODE` writer - Tx Trigger when slave FSM is in Tx Mode"] pub type SCTR_TXTRIG_TXMODE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , SCTR_TXTRIG_TXMODE_A > ; impl < 'a , REG , const O : u8 > SCTR_TXTRIG_TXMODE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn sctr_txtrig_txmode_disable (self) -> & 'a mut crate :: W < REG > { self . variant (SCTR_TXTRIG_TXMODE_A :: SCTR_TXTRIG_TXMODE_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn sctr_txtrig_txmode_enable (self) -> & 'a mut crate :: W < REG > { self . variant (SCTR_TXTRIG_TXMODE_A :: SCTR_TXTRIG_TXMODE_ENABLE) } } # [doc = "Field `SCTR_TXWAIT_STALE_TXFIFO` reader - Tx transfer waits when stale data in Tx FIFO. This prevents stale bytes left in the TX FIFO from automatically being sent on the next I2C packet. Note: this should be used with TXEMPTY_ON_TREQ set to prevent the Slave State Machine from waiting for TX FIFO data without an interrupt notification when the FIFO data is stale."] pub type SCTR_TXWAIT_STALE_TXFIFO_R = crate :: BitReader < SCTR_TXWAIT_STALE_TXFIFO_A > ; # [doc = "Tx transfer waits when stale data in Tx FIFO. This prevents stale bytes left in the TX FIFO from automatically being sent on the next I2C packet. Note: this should be used with TXEMPTY_ON_TREQ set to prevent the Slave State Machine from waiting for TX FIFO data without an interrupt notification when the FIFO data is stale.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SCTR_TXWAIT_STALE_TXFIFO_A { # [doc = "0: DISABLE"] SCTR_TXWAIT_STALE_TXFIFO_DISABLE = 0 , # [doc = "1: ENABLE"] SCTR_TXWAIT_STALE_TXFIFO_ENABLE = 1 , } impl From < SCTR_TXWAIT_STALE_TXFIFO_A > for bool { # [inline (always)] fn from (variant : SCTR_TXWAIT_STALE_TXFIFO_A) -> Self { variant as u8 != 0 } } impl SCTR_TXWAIT_STALE_TXFIFO_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SCTR_TXWAIT_STALE_TXFIFO_A { match self . bits { false => SCTR_TXWAIT_STALE_TXFIFO_A :: SCTR_TXWAIT_STALE_TXFIFO_DISABLE , true => SCTR_TXWAIT_STALE_TXFIFO_A :: SCTR_TXWAIT_STALE_TXFIFO_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_sctr_txwait_stale_txfifo_disable (& self) -> bool { * self == SCTR_TXWAIT_STALE_TXFIFO_A :: SCTR_TXWAIT_STALE_TXFIFO_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_sctr_txwait_stale_txfifo_enable (& self) -> bool { * self == SCTR_TXWAIT_STALE_TXFIFO_A :: SCTR_TXWAIT_STALE_TXFIFO_ENABLE } } # [doc = "Field `SCTR_TXWAIT_STALE_TXFIFO` writer - Tx transfer waits when stale data in Tx FIFO. This prevents stale bytes left in the TX FIFO from automatically being sent on the next I2C packet. Note: this should be used with TXEMPTY_ON_TREQ set to prevent the Slave State Machine from waiting for TX FIFO data without an interrupt notification when the FIFO data is stale."] pub type SCTR_TXWAIT_STALE_TXFIFO_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , SCTR_TXWAIT_STALE_TXFIFO_A > ; impl < 'a , REG , const O : u8 > SCTR_TXWAIT_STALE_TXFIFO_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn sctr_txwait_stale_txfifo_disable (self) -> & 'a mut crate :: W < REG > { self . variant (SCTR_TXWAIT_STALE_TXFIFO_A :: SCTR_TXWAIT_STALE_TXFIFO_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn sctr_txwait_stale_txfifo_enable (self) -> & 'a mut crate :: W < REG > { self . variant (SCTR_TXWAIT_STALE_TXFIFO_A :: SCTR_TXWAIT_STALE_TXFIFO_ENABLE) } } # [doc = "Field `SCTR_RXFULL_ON_RREQ` reader - Rx full interrupt generated on RREQ condition as indicated in SSR"] pub type SCTR_RXFULL_ON_RREQ_R = crate :: BitReader < SCTR_RXFULL_ON_RREQ_A > ; # [doc = "Rx full interrupt generated on RREQ condition as indicated in SSR\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SCTR_RXFULL_ON_RREQ_A { # [doc = "0: DISABLE"] SCTR_RXFULL_ON_RREQ_DISABLE = 0 , # [doc = "1: ENABLE"] SCTR_RXFULL_ON_RREQ_ENABLE = 1 , } impl From < SCTR_RXFULL_ON_RREQ_A > for bool { # [inline (always)] fn from (variant : SCTR_RXFULL_ON_RREQ_A) -> Self { variant as u8 != 0 } } impl SCTR_RXFULL_ON_RREQ_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SCTR_RXFULL_ON_RREQ_A { match self . bits { false => SCTR_RXFULL_ON_RREQ_A :: SCTR_RXFULL_ON_RREQ_DISABLE , true => SCTR_RXFULL_ON_RREQ_A :: SCTR_RXFULL_ON_RREQ_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_sctr_rxfull_on_rreq_disable (& self) -> bool { * self == SCTR_RXFULL_ON_RREQ_A :: SCTR_RXFULL_ON_RREQ_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_sctr_rxfull_on_rreq_enable (& self) -> bool { * self == SCTR_RXFULL_ON_RREQ_A :: SCTR_RXFULL_ON_RREQ_ENABLE } } # [doc = "Field `SCTR_RXFULL_ON_RREQ` writer - Rx full interrupt generated on RREQ condition as indicated in SSR"] pub type SCTR_RXFULL_ON_RREQ_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , SCTR_RXFULL_ON_RREQ_A > ; impl < 'a , REG , const O : u8 > SCTR_RXFULL_ON_RREQ_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn sctr_rxfull_on_rreq_disable (self) -> & 'a mut crate :: W < REG > { self . variant (SCTR_RXFULL_ON_RREQ_A :: SCTR_RXFULL_ON_RREQ_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn sctr_rxfull_on_rreq_enable (self) -> & 'a mut crate :: W < REG > { self . variant (SCTR_RXFULL_ON_RREQ_A :: SCTR_RXFULL_ON_RREQ_ENABLE) } } # [doc = "Field `SCTR_EN_DEFHOSTADR` reader - Enable Default Host Address"] pub type SCTR_EN_DEFHOSTADR_R = crate :: BitReader < SCTR_EN_DEFHOSTADR_A > ; # [doc = "Enable Default Host Address\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SCTR_EN_DEFHOSTADR_A { # [doc = "0: DISABLE"] SCTR_EN_DEFHOSTADR_DISABLE = 0 , # [doc = "1: ENABLE"] SCTR_EN_DEFHOSTADR_ENABLE = 1 , } impl From < SCTR_EN_DEFHOSTADR_A > for bool { # [inline (always)] fn from (variant : SCTR_EN_DEFHOSTADR_A) -> Self { variant as u8 != 0 } } impl SCTR_EN_DEFHOSTADR_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SCTR_EN_DEFHOSTADR_A { match self . bits { false => SCTR_EN_DEFHOSTADR_A :: SCTR_EN_DEFHOSTADR_DISABLE , true => SCTR_EN_DEFHOSTADR_A :: SCTR_EN_DEFHOSTADR_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_sctr_en_defhostadr_disable (& self) -> bool { * self == SCTR_EN_DEFHOSTADR_A :: SCTR_EN_DEFHOSTADR_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_sctr_en_defhostadr_enable (& self) -> bool { * self == SCTR_EN_DEFHOSTADR_A :: SCTR_EN_DEFHOSTADR_ENABLE } } # [doc = "Field `SCTR_EN_DEFHOSTADR` writer - Enable Default Host Address"] pub type SCTR_EN_DEFHOSTADR_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , SCTR_EN_DEFHOSTADR_A > ; impl < 'a , REG , const O : u8 > SCTR_EN_DEFHOSTADR_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn sctr_en_defhostadr_disable (self) -> & 'a mut crate :: W < REG > { self . variant (SCTR_EN_DEFHOSTADR_A :: SCTR_EN_DEFHOSTADR_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn sctr_en_defhostadr_enable (self) -> & 'a mut crate :: W < REG > { self . variant (SCTR_EN_DEFHOSTADR_A :: SCTR_EN_DEFHOSTADR_ENABLE) } } # [doc = "Field `SCTR_EN_ALRESPADR` reader - Enable Alert Response Address"] pub type SCTR_EN_ALRESPADR_R = crate :: BitReader < SCTR_EN_ALRESPADR_A > ; # [doc = "Enable Alert Response Address\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SCTR_EN_ALRESPADR_A { # [doc = "0: DISABLE"] SCTR_EN_ALRESPADR_DISABLE = 0 , # [doc = "1: ENABLE"] SCTR_EN_ALRESPADR_ENABLE = 1 , } impl From < SCTR_EN_ALRESPADR_A > for bool { # [inline (always)] fn from (variant : SCTR_EN_ALRESPADR_A) -> Self { variant as u8 != 0 } } impl SCTR_EN_ALRESPADR_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SCTR_EN_ALRESPADR_A { match self . bits { false => SCTR_EN_ALRESPADR_A :: SCTR_EN_ALRESPADR_DISABLE , true => SCTR_EN_ALRESPADR_A :: SCTR_EN_ALRESPADR_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_sctr_en_alrespadr_disable (& self) -> bool { * self == SCTR_EN_ALRESPADR_A :: SCTR_EN_ALRESPADR_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_sctr_en_alrespadr_enable (& self) -> bool { * self == SCTR_EN_ALRESPADR_A :: SCTR_EN_ALRESPADR_ENABLE } } # [doc = "Field `SCTR_EN_ALRESPADR` writer - Enable Alert Response Address"] pub type SCTR_EN_ALRESPADR_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , SCTR_EN_ALRESPADR_A > ; impl < 'a , REG , const O : u8 > SCTR_EN_ALRESPADR_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn sctr_en_alrespadr_disable (self) -> & 'a mut crate :: W < REG > { self . variant (SCTR_EN_ALRESPADR_A :: SCTR_EN_ALRESPADR_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn sctr_en_alrespadr_enable (self) -> & 'a mut crate :: W < REG > { self . variant (SCTR_EN_ALRESPADR_A :: SCTR_EN_ALRESPADR_ENABLE) } } # [doc = "Field `SCTR_EN_DEFDEVADR` reader - Enable Deault device address"] pub type SCTR_EN_DEFDEVADR_R = crate :: BitReader < SCTR_EN_DEFDEVADR_A > ; # [doc = "Enable Deault device address\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SCTR_EN_DEFDEVADR_A { # [doc = "0: DISABLE"] SCTR_EN_DEFDEVADR_DISABLE = 0 , # [doc = "1: ENABLE"] SCTR_EN_DEFDEVADR_ENABLE = 1 , } impl From < SCTR_EN_DEFDEVADR_A > for bool { # [inline (always)] fn from (variant : SCTR_EN_DEFDEVADR_A) -> Self { variant as u8 != 0 } } impl SCTR_EN_DEFDEVADR_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SCTR_EN_DEFDEVADR_A { match self . bits { false => SCTR_EN_DEFDEVADR_A :: SCTR_EN_DEFDEVADR_DISABLE , true => SCTR_EN_DEFDEVADR_A :: SCTR_EN_DEFDEVADR_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_sctr_en_defdevadr_disable (& self) -> bool { * self == SCTR_EN_DEFDEVADR_A :: SCTR_EN_DEFDEVADR_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_sctr_en_defdevadr_enable (& self) -> bool { * self == SCTR_EN_DEFDEVADR_A :: SCTR_EN_DEFDEVADR_ENABLE } } # [doc = "Field `SCTR_EN_DEFDEVADR` writer - Enable Deault device address"] pub type SCTR_EN_DEFDEVADR_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , SCTR_EN_DEFDEVADR_A > ; impl < 'a , REG , const O : u8 > SCTR_EN_DEFDEVADR_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn sctr_en_defdevadr_disable (self) -> & 'a mut crate :: W < REG > { self . variant (SCTR_EN_DEFDEVADR_A :: SCTR_EN_DEFDEVADR_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn sctr_en_defdevadr_enable (self) -> & 'a mut crate :: W < REG > { self . variant (SCTR_EN_DEFDEVADR_A :: SCTR_EN_DEFDEVADR_ENABLE) } } # [doc = "Field `SCTR_SWUEN` reader - Slave Wakeup Enable"] pub type SCTR_SWUEN_R = crate :: BitReader < SCTR_SWUEN_A > ; # [doc = "Slave Wakeup Enable\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SCTR_SWUEN_A { # [doc = "0: DISABLE"] SCTR_SWUEN_DISABLE = 0 , # [doc = "1: ENABLE"] SCTR_SWUEN_ENABLE = 1 , } impl From < SCTR_SWUEN_A > for bool { # [inline (always)] fn from (variant : SCTR_SWUEN_A) -> Self { variant as u8 != 0 } } impl SCTR_SWUEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SCTR_SWUEN_A { match self . bits { false => SCTR_SWUEN_A :: SCTR_SWUEN_DISABLE , true => SCTR_SWUEN_A :: SCTR_SWUEN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_sctr_swuen_disable (& self) -> bool { * self == SCTR_SWUEN_A :: SCTR_SWUEN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_sctr_swuen_enable (& self) -> bool { * self == SCTR_SWUEN_A :: SCTR_SWUEN_ENABLE } } # [doc = "Field `SCTR_SWUEN` writer - Slave Wakeup Enable"] pub type SCTR_SWUEN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , SCTR_SWUEN_A > ; impl < 'a , REG , const O : u8 > SCTR_SWUEN_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn sctr_swuen_disable (self) -> & 'a mut crate :: W < REG > { self . variant (SCTR_SWUEN_A :: SCTR_SWUEN_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn sctr_swuen_enable (self) -> & 'a mut crate :: W < REG > { self . variant (SCTR_SWUEN_A :: SCTR_SWUEN_ENABLE) } } impl R { # [doc = "Bit 0 - Device Active. Setting this bit enables the slave functionality."] # [inline (always)] pub fn sctr_active (& self) -> SCTR_ACTIVE_R { SCTR_ACTIVE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - General call response enable. This bit is only available in UCBxI2COA0. Modify only when UCSWRST = 1. 0b = Do not respond to a general call 1b = Respond to a general call"] # [inline (always)] pub fn sctr_gencall (& self) -> SCTR_GENCALL_R { SCTR_GENCALL_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Slave Clock Stretch Enable"] # [inline (always)] pub fn sctr_sclkstretch (& self) -> SCTR_SCLKSTRETCH_R { SCTR_SCLKSTRETCH_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Tx Empty Interrupt on TREQ"] # [inline (always)] pub fn sctr_txempty_on_treq (& self) -> SCTR_TXEMPTY_ON_TREQ_R { SCTR_TXEMPTY_ON_TREQ_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Tx Trigger when slave FSM is in Tx Mode"] # [inline (always)] pub fn sctr_txtrig_txmode (& self) -> SCTR_TXTRIG_TXMODE_R { SCTR_TXTRIG_TXMODE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Tx transfer waits when stale data in Tx FIFO. This prevents stale bytes left in the TX FIFO from automatically being sent on the next I2C packet. Note: this should be used with TXEMPTY_ON_TREQ set to prevent the Slave State Machine from waiting for TX FIFO data without an interrupt notification when the FIFO data is stale."] # [inline (always)] pub fn sctr_txwait_stale_txfifo (& self) -> SCTR_TXWAIT_STALE_TXFIFO_R { SCTR_TXWAIT_STALE_TXFIFO_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Rx full interrupt generated on RREQ condition as indicated in SSR"] # [inline (always)] pub fn sctr_rxfull_on_rreq (& self) -> SCTR_RXFULL_ON_RREQ_R { SCTR_RXFULL_ON_RREQ_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Enable Default Host Address"] # [inline (always)] pub fn sctr_en_defhostadr (& self) -> SCTR_EN_DEFHOSTADR_R { SCTR_EN_DEFHOSTADR_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Enable Alert Response Address"] # [inline (always)] pub fn sctr_en_alrespadr (& self) -> SCTR_EN_ALRESPADR_R { SCTR_EN_ALRESPADR_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Enable Deault device address"] # [inline (always)] pub fn sctr_en_defdevadr (& self) -> SCTR_EN_DEFDEVADR_R { SCTR_EN_DEFDEVADR_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Slave Wakeup Enable"] # [inline (always)] pub fn sctr_swuen (& self) -> SCTR_SWUEN_R { SCTR_SWUEN_R :: new (((self . bits >> 10) & 1) != 0) } } impl W { # [doc = "Bit 0 - Device Active. Setting this bit enables the slave functionality."] # [inline (always)] # [must_use] pub fn sctr_active (& mut self) -> SCTR_ACTIVE_W < SCTR_SPEC , 0 > { SCTR_ACTIVE_W :: new (self) } # [doc = "Bit 1 - General call response enable. This bit is only available in UCBxI2COA0. Modify only when UCSWRST = 1. 0b = Do not respond to a general call 1b = Respond to a general call"] # [inline (always)] # [must_use] pub fn sctr_gencall (& mut self) -> SCTR_GENCALL_W < SCTR_SPEC , 1 > { SCTR_GENCALL_W :: new (self) } # [doc = "Bit 2 - Slave Clock Stretch Enable"] # [inline (always)] # [must_use] pub fn sctr_sclkstretch (& mut self) -> SCTR_SCLKSTRETCH_W < SCTR_SPEC , 2 > { SCTR_SCLKSTRETCH_W :: new (self) } # [doc = "Bit 3 - Tx Empty Interrupt on TREQ"] # [inline (always)] # [must_use] pub fn sctr_txempty_on_treq (& mut self) -> SCTR_TXEMPTY_ON_TREQ_W < SCTR_SPEC , 3 > { SCTR_TXEMPTY_ON_TREQ_W :: new (self) } # [doc = "Bit 4 - Tx Trigger when slave FSM is in Tx Mode"] # [inline (always)] # [must_use] pub fn sctr_txtrig_txmode (& mut self) -> SCTR_TXTRIG_TXMODE_W < SCTR_SPEC , 4 > { SCTR_TXTRIG_TXMODE_W :: new (self) } # [doc = "Bit 5 - Tx transfer waits when stale data in Tx FIFO. This prevents stale bytes left in the TX FIFO from automatically being sent on the next I2C packet. Note: this should be used with TXEMPTY_ON_TREQ set to prevent the Slave State Machine from waiting for TX FIFO data without an interrupt notification when the FIFO data is stale."] # [inline (always)] # [must_use] pub fn sctr_txwait_stale_txfifo (& mut self) -> SCTR_TXWAIT_STALE_TXFIFO_W < SCTR_SPEC , 5 > { SCTR_TXWAIT_STALE_TXFIFO_W :: new (self) } # [doc = "Bit 6 - Rx full interrupt generated on RREQ condition as indicated in SSR"] # [inline (always)] # [must_use] pub fn sctr_rxfull_on_rreq (& mut self) -> SCTR_RXFULL_ON_RREQ_W < SCTR_SPEC , 6 > { SCTR_RXFULL_ON_RREQ_W :: new (self) } # [doc = "Bit 7 - Enable Default Host Address"] # [inline (always)] # [must_use] pub fn sctr_en_defhostadr (& mut self) -> SCTR_EN_DEFHOSTADR_W < SCTR_SPEC , 7 > { SCTR_EN_DEFHOSTADR_W :: new (self) } # [doc = "Bit 8 - Enable Alert Response Address"] # [inline (always)] # [must_use] pub fn sctr_en_alrespadr (& mut self) -> SCTR_EN_ALRESPADR_W < SCTR_SPEC , 8 > { SCTR_EN_ALRESPADR_W :: new (self) } # [doc = "Bit 9 - Enable Deault device address"] # [inline (always)] # [must_use] pub fn sctr_en_defdevadr (& mut self) -> SCTR_EN_DEFDEVADR_W < SCTR_SPEC , 9 > { SCTR_EN_DEFDEVADR_W :: new (self) } # [doc = "Bit 10 - Slave Wakeup Enable"] # [inline (always)] # [must_use] pub fn sctr_swuen (& mut self) -> SCTR_SWUEN_W < SCTR_SPEC , 10 > { SCTR_SWUEN_W :: new (self) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "I2C Slave Control Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`sctr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sctr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SCTR_SPEC ; impl crate :: RegisterSpec for SCTR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`sctr::R`](R) reader structure"] impl crate :: Readable for SCTR_SPEC { } # [doc = "`write(|w| ..)` method takes [`sctr::W`](W) writer structure"] impl crate :: Writable for SCTR_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCTR to value 0x0404"] impl crate :: Resettable for SCTR_SPEC { const RESET_VALUE : Self :: Ux = 0x0404 ; }