# [doc = "Register `SSR` reader"] pub type R = crate :: R < SSR_SPEC > ; # [doc = "Field `SSR_RREQ` reader - Receive Request"] pub type SSR_RREQ_R = crate :: BitReader < SSR_RREQ_A > ; # [doc = "Receive Request\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SSR_RREQ_A { # [doc = "0: CLEARED"] SSR_RREQ_CLEARED = 0 , # [doc = "1: SET"] SSR_RREQ_SET = 1 , } impl From < SSR_RREQ_A > for bool { # [inline (always)] fn from (variant : SSR_RREQ_A) -> Self { variant as u8 != 0 } } impl SSR_RREQ_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SSR_RREQ_A { match self . bits { false => SSR_RREQ_A :: SSR_RREQ_CLEARED , true => SSR_RREQ_A :: SSR_RREQ_SET , } } # [doc = "CLEARED"] # [inline (always)] pub fn is_ssr_rreq_cleared (& self) -> bool { * self == SSR_RREQ_A :: SSR_RREQ_CLEARED } # [doc = "SET"] # [inline (always)] pub fn is_ssr_rreq_set (& self) -> bool { * self == SSR_RREQ_A :: SSR_RREQ_SET } } # [doc = "Field `SSR_TREQ` reader - Transmit Request"] pub type SSR_TREQ_R = crate :: BitReader < SSR_TREQ_A > ; # [doc = "Transmit Request\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SSR_TREQ_A { # [doc = "0: CLEARED"] SSR_TREQ_CLEARED = 0 , # [doc = "1: SET"] SSR_TREQ_SET = 1 , } impl From < SSR_TREQ_A > for bool { # [inline (always)] fn from (variant : SSR_TREQ_A) -> Self { variant as u8 != 0 } } impl SSR_TREQ_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SSR_TREQ_A { match self . bits { false => SSR_TREQ_A :: SSR_TREQ_CLEARED , true => SSR_TREQ_A :: SSR_TREQ_SET , } } # [doc = "CLEARED"] # [inline (always)] pub fn is_ssr_treq_cleared (& self) -> bool { * self == SSR_TREQ_A :: SSR_TREQ_CLEARED } # [doc = "SET"] # [inline (always)] pub fn is_ssr_treq_set (& self) -> bool { * self == SSR_TREQ_A :: SSR_TREQ_SET } } # [doc = "Field `SSR_RXMODE` reader - Slave FSM is in Rx MODE"] pub type SSR_RXMODE_R = crate :: BitReader < SSR_RXMODE_A > ; # [doc = "Slave FSM is in Rx MODE\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SSR_RXMODE_A { # [doc = "0: CLEARED"] SSR_RXMODE_CLEARED = 0 , # [doc = "1: SET"] SSR_RXMODE_SET = 1 , } impl From < SSR_RXMODE_A > for bool { # [inline (always)] fn from (variant : SSR_RXMODE_A) -> Self { variant as u8 != 0 } } impl SSR_RXMODE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SSR_RXMODE_A { match self . bits { false => SSR_RXMODE_A :: SSR_RXMODE_CLEARED , true => SSR_RXMODE_A :: SSR_RXMODE_SET , } } # [doc = "CLEARED"] # [inline (always)] pub fn is_ssr_rxmode_cleared (& self) -> bool { * self == SSR_RXMODE_A :: SSR_RXMODE_CLEARED } # [doc = "SET"] # [inline (always)] pub fn is_ssr_rxmode_set (& self) -> bool { * self == SSR_RXMODE_A :: SSR_RXMODE_SET } } # [doc = "Field `SSR_OAR2SEL` reader - OAR2 Address Matched This bit gets reevaluated after every address comparison."] pub type SSR_OAR2SEL_R = crate :: BitReader < SSR_OAR2SEL_A > ; # [doc = "OAR2 Address Matched This bit gets reevaluated after every address comparison.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SSR_OAR2SEL_A { # [doc = "0: CLEARED"] SSR_OAR2SEL_CLEARED = 0 , # [doc = "1: SET"] SSR_OAR2SEL_SET = 1 , } impl From < SSR_OAR2SEL_A > for bool { # [inline (always)] fn from (variant : SSR_OAR2SEL_A) -> Self { variant as u8 != 0 } } impl SSR_OAR2SEL_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SSR_OAR2SEL_A { match self . bits { false => SSR_OAR2SEL_A :: SSR_OAR2SEL_CLEARED , true => SSR_OAR2SEL_A :: SSR_OAR2SEL_SET , } } # [doc = "CLEARED"] # [inline (always)] pub fn is_ssr_oar2sel_cleared (& self) -> bool { * self == SSR_OAR2SEL_A :: SSR_OAR2SEL_CLEARED } # [doc = "SET"] # [inline (always)] pub fn is_ssr_oar2sel_set (& self) -> bool { * self == SSR_OAR2SEL_A :: SSR_OAR2SEL_SET } } # [doc = "Field `SSR_QCMDST` reader - Quick Command Status Value Description: 0: The last transaction was a normal transaction or a transaction has not occurred. 1: The last transaction was a Quick Command transaction"] pub type SSR_QCMDST_R = crate :: BitReader < SSR_QCMDST_A > ; # [doc = "Quick Command Status Value Description: 0: The last transaction was a normal transaction or a transaction has not occurred. 1: The last transaction was a Quick Command transaction\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SSR_QCMDST_A { # [doc = "0: CLEARED"] SSR_QCMDST_CLEARED = 0 , # [doc = "1: SET"] SSR_QCMDST_SET = 1 , } impl From < SSR_QCMDST_A > for bool { # [inline (always)] fn from (variant : SSR_QCMDST_A) -> Self { variant as u8 != 0 } } impl SSR_QCMDST_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SSR_QCMDST_A { match self . bits { false => SSR_QCMDST_A :: SSR_QCMDST_CLEARED , true => SSR_QCMDST_A :: SSR_QCMDST_SET , } } # [doc = "CLEARED"] # [inline (always)] pub fn is_ssr_qcmdst_cleared (& self) -> bool { * self == SSR_QCMDST_A :: SSR_QCMDST_CLEARED } # [doc = "SET"] # [inline (always)] pub fn is_ssr_qcmdst_set (& self) -> bool { * self == SSR_QCMDST_A :: SSR_QCMDST_SET } } # [doc = "Field `SSR_QCMDRW` reader - Quick Command Read / Write This bit only has meaning when the QCMDST bit is set. Value Description: 0: Quick command was a write 1: Quick command was a read"] pub type SSR_QCMDRW_R = crate :: BitReader < SSR_QCMDRW_A > ; # [doc = "Quick Command Read / Write This bit only has meaning when the QCMDST bit is set. Value Description: 0: Quick command was a write 1: Quick command was a read\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SSR_QCMDRW_A { # [doc = "0: CLEARED"] SSR_QCMDRW_CLEARED = 0 , # [doc = "1: SET"] SSR_QCMDRW_SET = 1 , } impl From < SSR_QCMDRW_A > for bool { # [inline (always)] fn from (variant : SSR_QCMDRW_A) -> Self { variant as u8 != 0 } } impl SSR_QCMDRW_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SSR_QCMDRW_A { match self . bits { false => SSR_QCMDRW_A :: SSR_QCMDRW_CLEARED , true => SSR_QCMDRW_A :: SSR_QCMDRW_SET , } } # [doc = "CLEARED"] # [inline (always)] pub fn is_ssr_qcmdrw_cleared (& self) -> bool { * self == SSR_QCMDRW_A :: SSR_QCMDRW_CLEARED } # [doc = "SET"] # [inline (always)] pub fn is_ssr_qcmdrw_set (& self) -> bool { * self == SSR_QCMDRW_A :: SSR_QCMDRW_SET } } # [doc = "Field `SSR_BUSBSY` reader - I2C bus is busy"] pub type SSR_BUSBSY_R = crate :: BitReader < SSR_BUSBSY_A > ; # [doc = "I2C bus is busy\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SSR_BUSBSY_A { # [doc = "0: CLEARED"] SSR_BUSBSY_CLEARED = 0 , # [doc = "1: SET"] SSR_BUSBSY_SET = 1 , } impl From < SSR_BUSBSY_A > for bool { # [inline (always)] fn from (variant : SSR_BUSBSY_A) -> Self { variant as u8 != 0 } } impl SSR_BUSBSY_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SSR_BUSBSY_A { match self . bits { false => SSR_BUSBSY_A :: SSR_BUSBSY_CLEARED , true => SSR_BUSBSY_A :: SSR_BUSBSY_SET , } } # [doc = "CLEARED"] # [inline (always)] pub fn is_ssr_busbsy_cleared (& self) -> bool { * self == SSR_BUSBSY_A :: SSR_BUSBSY_CLEARED } # [doc = "SET"] # [inline (always)] pub fn is_ssr_busbsy_set (& self) -> bool { * self == SSR_BUSBSY_A :: SSR_BUSBSY_SET } } # [doc = "Field `SSR_TXMODE` reader - Slave FSM is in TX MODE"] pub type SSR_TXMODE_R = crate :: BitReader < SSR_TXMODE_A > ; # [doc = "Slave FSM is in TX MODE\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SSR_TXMODE_A { # [doc = "0: CLEARED"] SSR_TXMODE_CLEARED = 0 , # [doc = "1: SET"] SSR_TXMODE_SET = 1 , } impl From < SSR_TXMODE_A > for bool { # [inline (always)] fn from (variant : SSR_TXMODE_A) -> Self { variant as u8 != 0 } } impl SSR_TXMODE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SSR_TXMODE_A { match self . bits { false => SSR_TXMODE_A :: SSR_TXMODE_CLEARED , true => SSR_TXMODE_A :: SSR_TXMODE_SET , } } # [doc = "CLEARED"] # [inline (always)] pub fn is_ssr_txmode_cleared (& self) -> bool { * self == SSR_TXMODE_A :: SSR_TXMODE_CLEARED } # [doc = "SET"] # [inline (always)] pub fn is_ssr_txmode_set (& self) -> bool { * self == SSR_TXMODE_A :: SSR_TXMODE_SET } } # [doc = "Field `SSR_STALE_TXFIFO` reader - Stale Tx FIFO"] pub type SSR_STALE_TXFIFO_R = crate :: BitReader < SSR_STALE_TXFIFO_A > ; # [doc = "Stale Tx FIFO\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SSR_STALE_TXFIFO_A { # [doc = "0: CLEARED"] SSR_STALE_TXFIFO_CLEARED = 0 , # [doc = "1: SET"] SSR_STALE_TXFIFO_SET = 1 , } impl From < SSR_STALE_TXFIFO_A > for bool { # [inline (always)] fn from (variant : SSR_STALE_TXFIFO_A) -> Self { variant as u8 != 0 } } impl SSR_STALE_TXFIFO_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SSR_STALE_TXFIFO_A { match self . bits { false => SSR_STALE_TXFIFO_A :: SSR_STALE_TXFIFO_CLEARED , true => SSR_STALE_TXFIFO_A :: SSR_STALE_TXFIFO_SET , } } # [doc = "CLEARED"] # [inline (always)] pub fn is_ssr_stale_txfifo_cleared (& self) -> bool { * self == SSR_STALE_TXFIFO_A :: SSR_STALE_TXFIFO_CLEARED } # [doc = "SET"] # [inline (always)] pub fn is_ssr_stale_txfifo_set (& self) -> bool { * self == SSR_STALE_TXFIFO_A :: SSR_STALE_TXFIFO_SET } } # [doc = "Field `SSR_ADDRMATCH` reader - Indicates the address for which slave address match happened"] pub type SSR_ADDRMATCH_R = crate :: FieldReader < u16 > ; impl R { # [doc = "Bit 0 - Receive Request"] # [inline (always)] pub fn ssr_rreq (& self) -> SSR_RREQ_R { SSR_RREQ_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Transmit Request"] # [inline (always)] pub fn ssr_treq (& self) -> SSR_TREQ_R { SSR_TREQ_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Slave FSM is in Rx MODE"] # [inline (always)] pub fn ssr_rxmode (& self) -> SSR_RXMODE_R { SSR_RXMODE_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - OAR2 Address Matched This bit gets reevaluated after every address comparison."] # [inline (always)] pub fn ssr_oar2sel (& self) -> SSR_OAR2SEL_R { SSR_OAR2SEL_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Quick Command Status Value Description: 0: The last transaction was a normal transaction or a transaction has not occurred. 1: The last transaction was a Quick Command transaction"] # [inline (always)] pub fn ssr_qcmdst (& self) -> SSR_QCMDST_R { SSR_QCMDST_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Quick Command Read / Write This bit only has meaning when the QCMDST bit is set. Value Description: 0: Quick command was a write 1: Quick command was a read"] # [inline (always)] pub fn ssr_qcmdrw (& self) -> SSR_QCMDRW_R { SSR_QCMDRW_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - I2C bus is busy"] # [inline (always)] pub fn ssr_busbsy (& self) -> SSR_BUSBSY_R { SSR_BUSBSY_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slave FSM is in TX MODE"] # [inline (always)] pub fn ssr_txmode (& self) -> SSR_TXMODE_R { SSR_TXMODE_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Stale Tx FIFO"] # [inline (always)] pub fn ssr_stale_txfifo (& self) -> SSR_STALE_TXFIFO_R { SSR_STALE_TXFIFO_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bits 9:18 - Indicates the address for which slave address match happened"] # [inline (always)] pub fn ssr_addrmatch (& self) -> SSR_ADDRMATCH_R { SSR_ADDRMATCH_R :: new (((self . bits >> 9) & 0x03ff) as u16) } } # [doc = "I2C Slave Status Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ssr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SSR_SPEC ; impl crate :: RegisterSpec for SSR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`ssr::R`](R) reader structure"] impl crate :: Readable for SSR_SPEC { } # [doc = "`reset()` method sets SSR to value 0"] impl crate :: Resettable for SSR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }