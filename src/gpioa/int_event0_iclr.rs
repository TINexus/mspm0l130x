# [doc = "Register `INT_EVENT0_ICLR` writer"] pub type W = crate :: W < INT_EVENT0_ICLR_SPEC > ; # [doc = "DIO0 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO0_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO0_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO0_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO0_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO0_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO0` writer - DIO0 event"] pub type INT_EVENT0_ICLR_DIO0_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO0_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO0_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio0_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO0_AW :: INT_EVENT0_ICLR_DIO0_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio0_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO0_AW :: INT_EVENT0_ICLR_DIO0_CLR) } } # [doc = "DIO1 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO1_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO1_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO1_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO1_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO1_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO1` writer - DIO1 event"] pub type INT_EVENT0_ICLR_DIO1_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO1_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO1_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio1_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO1_AW :: INT_EVENT0_ICLR_DIO1_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio1_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO1_AW :: INT_EVENT0_ICLR_DIO1_CLR) } } # [doc = "DIO2 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO2_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO2_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO2_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO2_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO2_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO2` writer - DIO2 event"] pub type INT_EVENT0_ICLR_DIO2_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO2_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO2_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio2_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO2_AW :: INT_EVENT0_ICLR_DIO2_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio2_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO2_AW :: INT_EVENT0_ICLR_DIO2_CLR) } } # [doc = "DIO3 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO3_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO3_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO3_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO3_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO3_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO3` writer - DIO3 event"] pub type INT_EVENT0_ICLR_DIO3_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO3_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO3_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio3_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO3_AW :: INT_EVENT0_ICLR_DIO3_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio3_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO3_AW :: INT_EVENT0_ICLR_DIO3_CLR) } } # [doc = "DIO4 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO4_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO4_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO4_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO4_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO4_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO4` writer - DIO4 event"] pub type INT_EVENT0_ICLR_DIO4_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO4_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO4_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio4_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO4_AW :: INT_EVENT0_ICLR_DIO4_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio4_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO4_AW :: INT_EVENT0_ICLR_DIO4_CLR) } } # [doc = "DIO5 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO5_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO5_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO5_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO5_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO5_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO5` writer - DIO5 event"] pub type INT_EVENT0_ICLR_DIO5_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO5_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO5_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio5_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO5_AW :: INT_EVENT0_ICLR_DIO5_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio5_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO5_AW :: INT_EVENT0_ICLR_DIO5_CLR) } } # [doc = "DIO6 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO6_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO6_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO6_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO6_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO6_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO6` writer - DIO6 event"] pub type INT_EVENT0_ICLR_DIO6_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO6_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO6_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio6_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO6_AW :: INT_EVENT0_ICLR_DIO6_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio6_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO6_AW :: INT_EVENT0_ICLR_DIO6_CLR) } } # [doc = "DIO7 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO7_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO7_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO7_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO7_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO7_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO7` writer - DIO7 event"] pub type INT_EVENT0_ICLR_DIO7_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO7_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO7_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio7_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO7_AW :: INT_EVENT0_ICLR_DIO7_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio7_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO7_AW :: INT_EVENT0_ICLR_DIO7_CLR) } } # [doc = "DIO8 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO8_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO8_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO8_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO8_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO8_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO8` writer - DIO8 event"] pub type INT_EVENT0_ICLR_DIO8_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO8_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO8_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio8_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO8_AW :: INT_EVENT0_ICLR_DIO8_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio8_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO8_AW :: INT_EVENT0_ICLR_DIO8_CLR) } } # [doc = "DIO9 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO9_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO9_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO9_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO9_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO9_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO9` writer - DIO9 event"] pub type INT_EVENT0_ICLR_DIO9_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO9_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO9_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio9_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO9_AW :: INT_EVENT0_ICLR_DIO9_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio9_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO9_AW :: INT_EVENT0_ICLR_DIO9_CLR) } } # [doc = "DIO10 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO10_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO10_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO10_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO10_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO10_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO10` writer - DIO10 event"] pub type INT_EVENT0_ICLR_DIO10_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO10_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO10_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio10_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO10_AW :: INT_EVENT0_ICLR_DIO10_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio10_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO10_AW :: INT_EVENT0_ICLR_DIO10_CLR) } } # [doc = "DIO11 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO11_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO11_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO11_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO11_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO11_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO11` writer - DIO11 event"] pub type INT_EVENT0_ICLR_DIO11_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO11_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO11_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio11_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO11_AW :: INT_EVENT0_ICLR_DIO11_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio11_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO11_AW :: INT_EVENT0_ICLR_DIO11_CLR) } } # [doc = "DIO12 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO12_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO12_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO12_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO12_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO12_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO12` writer - DIO12 event"] pub type INT_EVENT0_ICLR_DIO12_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO12_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO12_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio12_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO12_AW :: INT_EVENT0_ICLR_DIO12_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio12_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO12_AW :: INT_EVENT0_ICLR_DIO12_CLR) } } # [doc = "DIO13 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO13_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO13_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO13_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO13_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO13_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO13` writer - DIO13 event"] pub type INT_EVENT0_ICLR_DIO13_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO13_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO13_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio13_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO13_AW :: INT_EVENT0_ICLR_DIO13_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio13_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO13_AW :: INT_EVENT0_ICLR_DIO13_CLR) } } # [doc = "DIO14 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO14_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO14_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO14_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO14_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO14_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO14` writer - DIO14 event"] pub type INT_EVENT0_ICLR_DIO14_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO14_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO14_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio14_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO14_AW :: INT_EVENT0_ICLR_DIO14_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio14_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO14_AW :: INT_EVENT0_ICLR_DIO14_CLR) } } # [doc = "DIO15 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO15_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO15_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO15_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO15_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO15_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO15` writer - DIO15 event"] pub type INT_EVENT0_ICLR_DIO15_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO15_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO15_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio15_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO15_AW :: INT_EVENT0_ICLR_DIO15_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio15_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO15_AW :: INT_EVENT0_ICLR_DIO15_CLR) } } # [doc = "DIO16 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO16_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO16_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO16_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO16_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO16_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO16` writer - DIO16 event"] pub type INT_EVENT0_ICLR_DIO16_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO16_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO16_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio16_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO16_AW :: INT_EVENT0_ICLR_DIO16_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio16_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO16_AW :: INT_EVENT0_ICLR_DIO16_CLR) } } # [doc = "DIO17 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO17_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO17_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO17_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO17_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO17_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO17` writer - DIO17 event"] pub type INT_EVENT0_ICLR_DIO17_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO17_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO17_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio17_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO17_AW :: INT_EVENT0_ICLR_DIO17_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio17_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO17_AW :: INT_EVENT0_ICLR_DIO17_CLR) } } # [doc = "DIO18 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO18_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO18_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO18_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO18_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO18_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO18` writer - DIO18 event"] pub type INT_EVENT0_ICLR_DIO18_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO18_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO18_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio18_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO18_AW :: INT_EVENT0_ICLR_DIO18_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio18_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO18_AW :: INT_EVENT0_ICLR_DIO18_CLR) } } # [doc = "DIO19 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO19_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO19_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO19_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO19_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO19_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO19` writer - DIO19 event"] pub type INT_EVENT0_ICLR_DIO19_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO19_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO19_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio19_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO19_AW :: INT_EVENT0_ICLR_DIO19_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio19_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO19_AW :: INT_EVENT0_ICLR_DIO19_CLR) } } # [doc = "DIO20 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO20_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO20_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO20_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO20_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO20_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO20` writer - DIO20 event"] pub type INT_EVENT0_ICLR_DIO20_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO20_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO20_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio20_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO20_AW :: INT_EVENT0_ICLR_DIO20_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio20_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO20_AW :: INT_EVENT0_ICLR_DIO20_CLR) } } # [doc = "DIO21 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO21_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO21_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO21_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO21_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO21_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO21` writer - DIO21 event"] pub type INT_EVENT0_ICLR_DIO21_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO21_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO21_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio21_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO21_AW :: INT_EVENT0_ICLR_DIO21_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio21_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO21_AW :: INT_EVENT0_ICLR_DIO21_CLR) } } # [doc = "DIO22 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO22_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO22_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO22_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO22_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO22_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO22` writer - DIO22 event"] pub type INT_EVENT0_ICLR_DIO22_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO22_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO22_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio22_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO22_AW :: INT_EVENT0_ICLR_DIO22_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio22_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO22_AW :: INT_EVENT0_ICLR_DIO22_CLR) } } # [doc = "DIO23 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO23_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO23_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO23_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO23_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO23_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO23` writer - DIO23 event"] pub type INT_EVENT0_ICLR_DIO23_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO23_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO23_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio23_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO23_AW :: INT_EVENT0_ICLR_DIO23_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio23_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO23_AW :: INT_EVENT0_ICLR_DIO23_CLR) } } # [doc = "DIO24 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO24_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO24_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO24_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO24_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO24_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO24` writer - DIO24 event"] pub type INT_EVENT0_ICLR_DIO24_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO24_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO24_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio24_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO24_AW :: INT_EVENT0_ICLR_DIO24_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio24_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO24_AW :: INT_EVENT0_ICLR_DIO24_CLR) } } # [doc = "DIO25 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO25_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO25_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO25_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO25_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO25_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO25` writer - DIO25 event"] pub type INT_EVENT0_ICLR_DIO25_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO25_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO25_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio25_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO25_AW :: INT_EVENT0_ICLR_DIO25_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio25_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO25_AW :: INT_EVENT0_ICLR_DIO25_CLR) } } # [doc = "DIO26 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO26_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO26_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO26_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO26_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO26_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO26` writer - DIO26 event"] pub type INT_EVENT0_ICLR_DIO26_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO26_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO26_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio26_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO26_AW :: INT_EVENT0_ICLR_DIO26_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio26_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO26_AW :: INT_EVENT0_ICLR_DIO26_CLR) } } # [doc = "DIO27 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO27_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO27_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO27_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO27_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO27_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO27` writer - DIO27 event"] pub type INT_EVENT0_ICLR_DIO27_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO27_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO27_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio27_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO27_AW :: INT_EVENT0_ICLR_DIO27_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio27_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO27_AW :: INT_EVENT0_ICLR_DIO27_CLR) } } # [doc = "DIO28 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO28_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO28_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO28_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO28_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO28_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO28` writer - DIO28 event"] pub type INT_EVENT0_ICLR_DIO28_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO28_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO28_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio28_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO28_AW :: INT_EVENT0_ICLR_DIO28_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio28_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO28_AW :: INT_EVENT0_ICLR_DIO28_CLR) } } # [doc = "DIO29 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO29_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO29_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO29_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO29_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO29_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO29` writer - DIO29 event"] pub type INT_EVENT0_ICLR_DIO29_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO29_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO29_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio29_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO29_AW :: INT_EVENT0_ICLR_DIO29_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio29_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO29_AW :: INT_EVENT0_ICLR_DIO29_CLR) } } # [doc = "DIO30 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO30_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO30_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO30_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO30_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO30_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO30` writer - DIO30 event"] pub type INT_EVENT0_ICLR_DIO30_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO30_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO30_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio30_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO30_AW :: INT_EVENT0_ICLR_DIO30_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio30_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO30_AW :: INT_EVENT0_ICLR_DIO30_CLR) } } # [doc = "DIO31 event\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_DIO31_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_DIO31_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_DIO31_CLR = 1 , } impl From < INT_EVENT0_ICLR_DIO31_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_DIO31_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_DIO31` writer - DIO31 event"] pub type INT_EVENT0_ICLR_DIO31_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_DIO31_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_DIO31_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_dio31_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO31_AW :: INT_EVENT0_ICLR_DIO31_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_dio31_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_DIO31_AW :: INT_EVENT0_ICLR_DIO31_CLR) } } impl W { # [doc = "Bit 0 - DIO0 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio0 (& mut self) -> INT_EVENT0_ICLR_DIO0_W < INT_EVENT0_ICLR_SPEC , 0 > { INT_EVENT0_ICLR_DIO0_W :: new (self) } # [doc = "Bit 1 - DIO1 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio1 (& mut self) -> INT_EVENT0_ICLR_DIO1_W < INT_EVENT0_ICLR_SPEC , 1 > { INT_EVENT0_ICLR_DIO1_W :: new (self) } # [doc = "Bit 2 - DIO2 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio2 (& mut self) -> INT_EVENT0_ICLR_DIO2_W < INT_EVENT0_ICLR_SPEC , 2 > { INT_EVENT0_ICLR_DIO2_W :: new (self) } # [doc = "Bit 3 - DIO3 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio3 (& mut self) -> INT_EVENT0_ICLR_DIO3_W < INT_EVENT0_ICLR_SPEC , 3 > { INT_EVENT0_ICLR_DIO3_W :: new (self) } # [doc = "Bit 4 - DIO4 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio4 (& mut self) -> INT_EVENT0_ICLR_DIO4_W < INT_EVENT0_ICLR_SPEC , 4 > { INT_EVENT0_ICLR_DIO4_W :: new (self) } # [doc = "Bit 5 - DIO5 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio5 (& mut self) -> INT_EVENT0_ICLR_DIO5_W < INT_EVENT0_ICLR_SPEC , 5 > { INT_EVENT0_ICLR_DIO5_W :: new (self) } # [doc = "Bit 6 - DIO6 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio6 (& mut self) -> INT_EVENT0_ICLR_DIO6_W < INT_EVENT0_ICLR_SPEC , 6 > { INT_EVENT0_ICLR_DIO6_W :: new (self) } # [doc = "Bit 7 - DIO7 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio7 (& mut self) -> INT_EVENT0_ICLR_DIO7_W < INT_EVENT0_ICLR_SPEC , 7 > { INT_EVENT0_ICLR_DIO7_W :: new (self) } # [doc = "Bit 8 - DIO8 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio8 (& mut self) -> INT_EVENT0_ICLR_DIO8_W < INT_EVENT0_ICLR_SPEC , 8 > { INT_EVENT0_ICLR_DIO8_W :: new (self) } # [doc = "Bit 9 - DIO9 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio9 (& mut self) -> INT_EVENT0_ICLR_DIO9_W < INT_EVENT0_ICLR_SPEC , 9 > { INT_EVENT0_ICLR_DIO9_W :: new (self) } # [doc = "Bit 10 - DIO10 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio10 (& mut self) -> INT_EVENT0_ICLR_DIO10_W < INT_EVENT0_ICLR_SPEC , 10 > { INT_EVENT0_ICLR_DIO10_W :: new (self) } # [doc = "Bit 11 - DIO11 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio11 (& mut self) -> INT_EVENT0_ICLR_DIO11_W < INT_EVENT0_ICLR_SPEC , 11 > { INT_EVENT0_ICLR_DIO11_W :: new (self) } # [doc = "Bit 12 - DIO12 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio12 (& mut self) -> INT_EVENT0_ICLR_DIO12_W < INT_EVENT0_ICLR_SPEC , 12 > { INT_EVENT0_ICLR_DIO12_W :: new (self) } # [doc = "Bit 13 - DIO13 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio13 (& mut self) -> INT_EVENT0_ICLR_DIO13_W < INT_EVENT0_ICLR_SPEC , 13 > { INT_EVENT0_ICLR_DIO13_W :: new (self) } # [doc = "Bit 14 - DIO14 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio14 (& mut self) -> INT_EVENT0_ICLR_DIO14_W < INT_EVENT0_ICLR_SPEC , 14 > { INT_EVENT0_ICLR_DIO14_W :: new (self) } # [doc = "Bit 15 - DIO15 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio15 (& mut self) -> INT_EVENT0_ICLR_DIO15_W < INT_EVENT0_ICLR_SPEC , 15 > { INT_EVENT0_ICLR_DIO15_W :: new (self) } # [doc = "Bit 16 - DIO16 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio16 (& mut self) -> INT_EVENT0_ICLR_DIO16_W < INT_EVENT0_ICLR_SPEC , 16 > { INT_EVENT0_ICLR_DIO16_W :: new (self) } # [doc = "Bit 17 - DIO17 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio17 (& mut self) -> INT_EVENT0_ICLR_DIO17_W < INT_EVENT0_ICLR_SPEC , 17 > { INT_EVENT0_ICLR_DIO17_W :: new (self) } # [doc = "Bit 18 - DIO18 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio18 (& mut self) -> INT_EVENT0_ICLR_DIO18_W < INT_EVENT0_ICLR_SPEC , 18 > { INT_EVENT0_ICLR_DIO18_W :: new (self) } # [doc = "Bit 19 - DIO19 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio19 (& mut self) -> INT_EVENT0_ICLR_DIO19_W < INT_EVENT0_ICLR_SPEC , 19 > { INT_EVENT0_ICLR_DIO19_W :: new (self) } # [doc = "Bit 20 - DIO20 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio20 (& mut self) -> INT_EVENT0_ICLR_DIO20_W < INT_EVENT0_ICLR_SPEC , 20 > { INT_EVENT0_ICLR_DIO20_W :: new (self) } # [doc = "Bit 21 - DIO21 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio21 (& mut self) -> INT_EVENT0_ICLR_DIO21_W < INT_EVENT0_ICLR_SPEC , 21 > { INT_EVENT0_ICLR_DIO21_W :: new (self) } # [doc = "Bit 22 - DIO22 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio22 (& mut self) -> INT_EVENT0_ICLR_DIO22_W < INT_EVENT0_ICLR_SPEC , 22 > { INT_EVENT0_ICLR_DIO22_W :: new (self) } # [doc = "Bit 23 - DIO23 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio23 (& mut self) -> INT_EVENT0_ICLR_DIO23_W < INT_EVENT0_ICLR_SPEC , 23 > { INT_EVENT0_ICLR_DIO23_W :: new (self) } # [doc = "Bit 24 - DIO24 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio24 (& mut self) -> INT_EVENT0_ICLR_DIO24_W < INT_EVENT0_ICLR_SPEC , 24 > { INT_EVENT0_ICLR_DIO24_W :: new (self) } # [doc = "Bit 25 - DIO25 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio25 (& mut self) -> INT_EVENT0_ICLR_DIO25_W < INT_EVENT0_ICLR_SPEC , 25 > { INT_EVENT0_ICLR_DIO25_W :: new (self) } # [doc = "Bit 26 - DIO26 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio26 (& mut self) -> INT_EVENT0_ICLR_DIO26_W < INT_EVENT0_ICLR_SPEC , 26 > { INT_EVENT0_ICLR_DIO26_W :: new (self) } # [doc = "Bit 27 - DIO27 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio27 (& mut self) -> INT_EVENT0_ICLR_DIO27_W < INT_EVENT0_ICLR_SPEC , 27 > { INT_EVENT0_ICLR_DIO27_W :: new (self) } # [doc = "Bit 28 - DIO28 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio28 (& mut self) -> INT_EVENT0_ICLR_DIO28_W < INT_EVENT0_ICLR_SPEC , 28 > { INT_EVENT0_ICLR_DIO28_W :: new (self) } # [doc = "Bit 29 - DIO29 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio29 (& mut self) -> INT_EVENT0_ICLR_DIO29_W < INT_EVENT0_ICLR_SPEC , 29 > { INT_EVENT0_ICLR_DIO29_W :: new (self) } # [doc = "Bit 30 - DIO30 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio30 (& mut self) -> INT_EVENT0_ICLR_DIO30_W < INT_EVENT0_ICLR_SPEC , 30 > { INT_EVENT0_ICLR_DIO30_W :: new (self) } # [doc = "Bit 31 - DIO31 event"] # [inline (always)] # [must_use] pub fn int_event0_iclr_dio31 (& mut self) -> INT_EVENT0_ICLR_DIO31_W < INT_EVENT0_ICLR_SPEC , 31 > { INT_EVENT0_ICLR_DIO31_W :: new (self) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Interrupt clear\n\nYou can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_event0_iclr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT_EVENT0_ICLR_SPEC ; impl crate :: RegisterSpec for INT_EVENT0_ICLR_SPEC { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`int_event0_iclr::W`](W) writer structure"] impl crate :: Writable for INT_EVENT0_ICLR_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT_EVENT0_ICLR to value 0"] impl crate :: Resettable for INT_EVENT0_ICLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }