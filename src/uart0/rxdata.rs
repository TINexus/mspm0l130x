# [doc = "Register `RXDATA` reader"] pub type R = crate :: R < RXDATA_SPEC > ; # [doc = "Field `RXDATA_DATA` reader - Data Transmitted or Received Data that is to be transmitted via the UART is written to this field. When read, this field contains the data that was received by the UART."] pub type RXDATA_DATA_R = crate :: FieldReader ; # [doc = "Field `RXDATA_FRMERR` reader - UART Framing Error Writing to this bit has no effect. The flag is cleared by writing 1 to the FRMERR bit in the UART EVENT ICLR register. This error is associated with the character at the top of the FIFO."] pub type RXDATA_FRMERR_R = crate :: BitReader < RXDATA_FRMERR_A > ; # [doc = "UART Framing Error Writing to this bit has no effect. The flag is cleared by writing 1 to the FRMERR bit in the UART EVENT ICLR register. This error is associated with the character at the top of the FIFO.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum RXDATA_FRMERR_A { # [doc = "0: CLR"] RXDATA_FRMERR_CLR = 0 , # [doc = "1: SET"] RXDATA_FRMERR_SET = 1 , } impl From < RXDATA_FRMERR_A > for bool { # [inline (always)] fn from (variant : RXDATA_FRMERR_A) -> Self { variant as u8 != 0 } } impl RXDATA_FRMERR_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> RXDATA_FRMERR_A { match self . bits { false => RXDATA_FRMERR_A :: RXDATA_FRMERR_CLR , true => RXDATA_FRMERR_A :: RXDATA_FRMERR_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_rxdata_frmerr_clr (& self) -> bool { * self == RXDATA_FRMERR_A :: RXDATA_FRMERR_CLR } # [doc = "SET"] # [inline (always)] pub fn is_rxdata_frmerr_set (& self) -> bool { * self == RXDATA_FRMERR_A :: RXDATA_FRMERR_SET } } # [doc = "Field `RXDATA_PARERR` reader - UART Parity Error Writing to this bit has no effect. The flag is cleared by writing 1 to the PARERR bit in the UART EVENT ICLR register."] pub type RXDATA_PARERR_R = crate :: BitReader < RXDATA_PARERR_A > ; # [doc = "UART Parity Error Writing to this bit has no effect. The flag is cleared by writing 1 to the PARERR bit in the UART EVENT ICLR register.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum RXDATA_PARERR_A { # [doc = "0: CLR"] RXDATA_PARERR_CLR = 0 , # [doc = "1: SET"] RXDATA_PARERR_SET = 1 , } impl From < RXDATA_PARERR_A > for bool { # [inline (always)] fn from (variant : RXDATA_PARERR_A) -> Self { variant as u8 != 0 } } impl RXDATA_PARERR_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> RXDATA_PARERR_A { match self . bits { false => RXDATA_PARERR_A :: RXDATA_PARERR_CLR , true => RXDATA_PARERR_A :: RXDATA_PARERR_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_rxdata_parerr_clr (& self) -> bool { * self == RXDATA_PARERR_A :: RXDATA_PARERR_CLR } # [doc = "SET"] # [inline (always)] pub fn is_rxdata_parerr_set (& self) -> bool { * self == RXDATA_PARERR_A :: RXDATA_PARERR_SET } } # [doc = "Field `RXDATA_BRKERR` reader - UART Break Error Writing to this bit has no effect. The flag is cleared by writing 1 to the BRKERR bit in the UART EVENT ICLR register. This error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received."] pub type RXDATA_BRKERR_R = crate :: BitReader < RXDATA_BRKERR_A > ; # [doc = "UART Break Error Writing to this bit has no effect. The flag is cleared by writing 1 to the BRKERR bit in the UART EVENT ICLR register. This error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum RXDATA_BRKERR_A { # [doc = "0: CLR"] RXDATA_BRKERR_CLR = 0 , # [doc = "1: SET"] RXDATA_BRKERR_SET = 1 , } impl From < RXDATA_BRKERR_A > for bool { # [inline (always)] fn from (variant : RXDATA_BRKERR_A) -> Self { variant as u8 != 0 } } impl RXDATA_BRKERR_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> RXDATA_BRKERR_A { match self . bits { false => RXDATA_BRKERR_A :: RXDATA_BRKERR_CLR , true => RXDATA_BRKERR_A :: RXDATA_BRKERR_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_rxdata_brkerr_clr (& self) -> bool { * self == RXDATA_BRKERR_A :: RXDATA_BRKERR_CLR } # [doc = "SET"] # [inline (always)] pub fn is_rxdata_brkerr_set (& self) -> bool { * self == RXDATA_BRKERR_A :: RXDATA_BRKERR_SET } } # [doc = "Field `RXDATA_OVRERR` reader - UART Receive Overrun Error Writing to this bit has no effect. The flag is cleared by writing 1 to the OVRERR bit in the UART EVENT ICLR register. In case of a receive FIFO overflow, the FIFO contents remain valid because no further data is written when the FIFO is full. Only the contents of the shift register are overwritten. The CPU must read the data in order to empty the FIFO."] pub type RXDATA_OVRERR_R = crate :: BitReader < RXDATA_OVRERR_A > ; # [doc = "UART Receive Overrun Error Writing to this bit has no effect. The flag is cleared by writing 1 to the OVRERR bit in the UART EVENT ICLR register. In case of a receive FIFO overflow, the FIFO contents remain valid because no further data is written when the FIFO is full. Only the contents of the shift register are overwritten. The CPU must read the data in order to empty the FIFO.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum RXDATA_OVRERR_A { # [doc = "0: CLR"] RXDATA_OVRERR_CLR = 0 , # [doc = "1: SET"] RXDATA_OVRERR_SET = 1 , } impl From < RXDATA_OVRERR_A > for bool { # [inline (always)] fn from (variant : RXDATA_OVRERR_A) -> Self { variant as u8 != 0 } } impl RXDATA_OVRERR_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> RXDATA_OVRERR_A { match self . bits { false => RXDATA_OVRERR_A :: RXDATA_OVRERR_CLR , true => RXDATA_OVRERR_A :: RXDATA_OVRERR_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_rxdata_ovrerr_clr (& self) -> bool { * self == RXDATA_OVRERR_A :: RXDATA_OVRERR_CLR } # [doc = "SET"] # [inline (always)] pub fn is_rxdata_ovrerr_set (& self) -> bool { * self == RXDATA_OVRERR_A :: RXDATA_OVRERR_SET } } # [doc = "Field `RXDATA_NERR` reader - Noise Error. Writing to this bit has no effect. The flag is cleared by writing 1 to the NERR bit in the UART EVENT ICLR register."] pub type RXDATA_NERR_R = crate :: BitReader < RXDATA_NERR_A > ; # [doc = "Noise Error. Writing to this bit has no effect. The flag is cleared by writing 1 to the NERR bit in the UART EVENT ICLR register.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum RXDATA_NERR_A { # [doc = "0: CLR"] RXDATA_NERR_CLR = 0 , # [doc = "1: SET"] RXDATA_NERR_SET = 1 , } impl From < RXDATA_NERR_A > for bool { # [inline (always)] fn from (variant : RXDATA_NERR_A) -> Self { variant as u8 != 0 } } impl RXDATA_NERR_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> RXDATA_NERR_A { match self . bits { false => RXDATA_NERR_A :: RXDATA_NERR_CLR , true => RXDATA_NERR_A :: RXDATA_NERR_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_rxdata_nerr_clr (& self) -> bool { * self == RXDATA_NERR_A :: RXDATA_NERR_CLR } # [doc = "SET"] # [inline (always)] pub fn is_rxdata_nerr_set (& self) -> bool { * self == RXDATA_NERR_A :: RXDATA_NERR_SET } } impl R { # [doc = "Bits 0:7 - Data Transmitted or Received Data that is to be transmitted via the UART is written to this field. When read, this field contains the data that was received by the UART."] # [inline (always)] pub fn rxdata_data (& self) -> RXDATA_DATA_R { RXDATA_DATA_R :: new ((self . bits & 0xff) as u8) } # [doc = "Bit 8 - UART Framing Error Writing to this bit has no effect. The flag is cleared by writing 1 to the FRMERR bit in the UART EVENT ICLR register. This error is associated with the character at the top of the FIFO."] # [inline (always)] pub fn rxdata_frmerr (& self) -> RXDATA_FRMERR_R { RXDATA_FRMERR_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - UART Parity Error Writing to this bit has no effect. The flag is cleared by writing 1 to the PARERR bit in the UART EVENT ICLR register."] # [inline (always)] pub fn rxdata_parerr (& self) -> RXDATA_PARERR_R { RXDATA_PARERR_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - UART Break Error Writing to this bit has no effect. The flag is cleared by writing 1 to the BRKERR bit in the UART EVENT ICLR register. This error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received."] # [inline (always)] pub fn rxdata_brkerr (& self) -> RXDATA_BRKERR_R { RXDATA_BRKERR_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - UART Receive Overrun Error Writing to this bit has no effect. The flag is cleared by writing 1 to the OVRERR bit in the UART EVENT ICLR register. In case of a receive FIFO overflow, the FIFO contents remain valid because no further data is written when the FIFO is full. Only the contents of the shift register are overwritten. The CPU must read the data in order to empty the FIFO."] # [inline (always)] pub fn rxdata_ovrerr (& self) -> RXDATA_OVRERR_R { RXDATA_OVRERR_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Noise Error. Writing to this bit has no effect. The flag is cleared by writing 1 to the NERR bit in the UART EVENT ICLR register."] # [inline (always)] pub fn rxdata_nerr (& self) -> RXDATA_NERR_R { RXDATA_NERR_R :: new (((self . bits >> 12) & 1) != 0) } } # [doc = "UART Receive Data Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rxdata::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RXDATA_SPEC ; impl crate :: RegisterSpec for RXDATA_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`rxdata::R`](R) reader structure"] impl crate :: Readable for RXDATA_SPEC { } # [doc = "`reset()` method sets RXDATA to value 0"] impl crate :: Resettable for RXDATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }