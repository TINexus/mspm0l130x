# [doc = "Register `LCRH` reader"] pub type R = crate :: R < LCRH_SPEC > ; # [doc = "Register `LCRH` writer"] pub type W = crate :: W < LCRH_SPEC > ; # [doc = "Field `LCRH_BRK` reader - UART Send Break (for LIN Protocol)"] pub type LCRH_BRK_R = crate :: BitReader < LCRH_BRK_A > ; # [doc = "UART Send Break (for LIN Protocol)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum LCRH_BRK_A { # [doc = "0: DISABLE"] LCRH_BRK_DISABLE = 0 , # [doc = "1: ENABLE"] LCRH_BRK_ENABLE = 1 , } impl From < LCRH_BRK_A > for bool { # [inline (always)] fn from (variant : LCRH_BRK_A) -> Self { variant as u8 != 0 } } impl LCRH_BRK_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> LCRH_BRK_A { match self . bits { false => LCRH_BRK_A :: LCRH_BRK_DISABLE , true => LCRH_BRK_A :: LCRH_BRK_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_lcrh_brk_disable (& self) -> bool { * self == LCRH_BRK_A :: LCRH_BRK_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_lcrh_brk_enable (& self) -> bool { * self == LCRH_BRK_A :: LCRH_BRK_ENABLE } } # [doc = "Field `LCRH_BRK` writer - UART Send Break (for LIN Protocol)"] pub type LCRH_BRK_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , LCRH_BRK_A > ; impl < 'a , REG , const O : u8 > LCRH_BRK_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn lcrh_brk_disable (self) -> & 'a mut crate :: W < REG > { self . variant (LCRH_BRK_A :: LCRH_BRK_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn lcrh_brk_enable (self) -> & 'a mut crate :: W < REG > { self . variant (LCRH_BRK_A :: LCRH_BRK_ENABLE) } } # [doc = "Field `LCRH_PEN` reader - UART Parity Enable"] pub type LCRH_PEN_R = crate :: BitReader < LCRH_PEN_A > ; # [doc = "UART Parity Enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum LCRH_PEN_A { # [doc = "0: DISABLE"] LCRH_PEN_DISABLE = 0 , # [doc = "1: ENABLE"] LCRH_PEN_ENABLE = 1 , } impl From < LCRH_PEN_A > for bool { # [inline (always)] fn from (variant : LCRH_PEN_A) -> Self { variant as u8 != 0 } } impl LCRH_PEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> LCRH_PEN_A { match self . bits { false => LCRH_PEN_A :: LCRH_PEN_DISABLE , true => LCRH_PEN_A :: LCRH_PEN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_lcrh_pen_disable (& self) -> bool { * self == LCRH_PEN_A :: LCRH_PEN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_lcrh_pen_enable (& self) -> bool { * self == LCRH_PEN_A :: LCRH_PEN_ENABLE } } # [doc = "Field `LCRH_PEN` writer - UART Parity Enable"] pub type LCRH_PEN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , LCRH_PEN_A > ; impl < 'a , REG , const O : u8 > LCRH_PEN_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn lcrh_pen_disable (self) -> & 'a mut crate :: W < REG > { self . variant (LCRH_PEN_A :: LCRH_PEN_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn lcrh_pen_enable (self) -> & 'a mut crate :: W < REG > { self . variant (LCRH_PEN_A :: LCRH_PEN_ENABLE) } } # [doc = "Field `LCRH_EPS` reader - UART Even Parity Select This bit has no effect when parity is disabled by the PEN bit. For 9-Bit UART Mode transmissions, this bit controls the address byte and data byte indication (9th bit). 0 = The transferred byte is a data byte 1 = The transferred byte is an address byte"] pub type LCRH_EPS_R = crate :: BitReader < LCRH_EPS_A > ; # [doc = "UART Even Parity Select This bit has no effect when parity is disabled by the PEN bit. For 9-Bit UART Mode transmissions, this bit controls the address byte and data byte indication (9th bit). 0 = The transferred byte is a data byte 1 = The transferred byte is an address byte\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum LCRH_EPS_A { # [doc = "0: ODD"] LCRH_EPS_ODD = 0 , # [doc = "1: EVEN"] LCRH_EPS_EVEN = 1 , } impl From < LCRH_EPS_A > for bool { # [inline (always)] fn from (variant : LCRH_EPS_A) -> Self { variant as u8 != 0 } } impl LCRH_EPS_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> LCRH_EPS_A { match self . bits { false => LCRH_EPS_A :: LCRH_EPS_ODD , true => LCRH_EPS_A :: LCRH_EPS_EVEN , } } # [doc = "ODD"] # [inline (always)] pub fn is_lcrh_eps_odd (& self) -> bool { * self == LCRH_EPS_A :: LCRH_EPS_ODD } # [doc = "EVEN"] # [inline (always)] pub fn is_lcrh_eps_even (& self) -> bool { * self == LCRH_EPS_A :: LCRH_EPS_EVEN } } # [doc = "Field `LCRH_EPS` writer - UART Even Parity Select This bit has no effect when parity is disabled by the PEN bit. For 9-Bit UART Mode transmissions, this bit controls the address byte and data byte indication (9th bit). 0 = The transferred byte is a data byte 1 = The transferred byte is an address byte"] pub type LCRH_EPS_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , LCRH_EPS_A > ; impl < 'a , REG , const O : u8 > LCRH_EPS_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "ODD"] # [inline (always)] pub fn lcrh_eps_odd (self) -> & 'a mut crate :: W < REG > { self . variant (LCRH_EPS_A :: LCRH_EPS_ODD) } # [doc = "EVEN"] # [inline (always)] pub fn lcrh_eps_even (self) -> & 'a mut crate :: W < REG > { self . variant (LCRH_EPS_A :: LCRH_EPS_EVEN) } } # [doc = "Field `LCRH_STP2` reader - UART Two Stop Bits Select When in 7816 smart card mode (the SMART bit is set in the UARTCTL register), the number of stop bits is forced to 2."] pub type LCRH_STP2_R = crate :: BitReader < LCRH_STP2_A > ; # [doc = "UART Two Stop Bits Select When in 7816 smart card mode (the SMART bit is set in the UARTCTL register), the number of stop bits is forced to 2.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum LCRH_STP2_A { # [doc = "0: DISABLE"] LCRH_STP2_DISABLE = 0 , # [doc = "1: ENABLE"] LCRH_STP2_ENABLE = 1 , } impl From < LCRH_STP2_A > for bool { # [inline (always)] fn from (variant : LCRH_STP2_A) -> Self { variant as u8 != 0 } } impl LCRH_STP2_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> LCRH_STP2_A { match self . bits { false => LCRH_STP2_A :: LCRH_STP2_DISABLE , true => LCRH_STP2_A :: LCRH_STP2_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_lcrh_stp2_disable (& self) -> bool { * self == LCRH_STP2_A :: LCRH_STP2_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_lcrh_stp2_enable (& self) -> bool { * self == LCRH_STP2_A :: LCRH_STP2_ENABLE } } # [doc = "Field `LCRH_STP2` writer - UART Two Stop Bits Select When in 7816 smart card mode (the SMART bit is set in the UARTCTL register), the number of stop bits is forced to 2."] pub type LCRH_STP2_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , LCRH_STP2_A > ; impl < 'a , REG , const O : u8 > LCRH_STP2_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn lcrh_stp2_disable (self) -> & 'a mut crate :: W < REG > { self . variant (LCRH_STP2_A :: LCRH_STP2_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn lcrh_stp2_enable (self) -> & 'a mut crate :: W < REG > { self . variant (LCRH_STP2_A :: LCRH_STP2_ENABLE) } } # [doc = "Field `LCRH_WLEN` reader - UART Word Length The bits indicate the number of data bits transmitted or received in a frame as follows:"] pub type LCRH_WLEN_R = crate :: FieldReader < LCRH_WLEN_A > ; # [doc = "UART Word Length The bits indicate the number of data bits transmitted or received in a frame as follows:\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum LCRH_WLEN_A { # [doc = "0: DATABIT5"] LCRH_WLEN_DATABIT5 = 0 , # [doc = "1: DATABIT6"] LCRH_WLEN_DATABIT6 = 1 , # [doc = "2: DATABIT7"] LCRH_WLEN_DATABIT7 = 2 , # [doc = "3: DATABIT8"] LCRH_WLEN_DATABIT8 = 3 , } impl From < LCRH_WLEN_A > for u8 { # [inline (always)] fn from (variant : LCRH_WLEN_A) -> Self { variant as _ } } impl crate :: FieldSpec for LCRH_WLEN_A { type Ux = u8 ; } impl LCRH_WLEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> LCRH_WLEN_A { match self . bits { 0 => LCRH_WLEN_A :: LCRH_WLEN_DATABIT5 , 1 => LCRH_WLEN_A :: LCRH_WLEN_DATABIT6 , 2 => LCRH_WLEN_A :: LCRH_WLEN_DATABIT7 , 3 => LCRH_WLEN_A :: LCRH_WLEN_DATABIT8 , _ => unreachable ! () , } } # [doc = "DATABIT5"] # [inline (always)] pub fn is_lcrh_wlen_databit5 (& self) -> bool { * self == LCRH_WLEN_A :: LCRH_WLEN_DATABIT5 } # [doc = "DATABIT6"] # [inline (always)] pub fn is_lcrh_wlen_databit6 (& self) -> bool { * self == LCRH_WLEN_A :: LCRH_WLEN_DATABIT6 } # [doc = "DATABIT7"] # [inline (always)] pub fn is_lcrh_wlen_databit7 (& self) -> bool { * self == LCRH_WLEN_A :: LCRH_WLEN_DATABIT7 } # [doc = "DATABIT8"] # [inline (always)] pub fn is_lcrh_wlen_databit8 (& self) -> bool { * self == LCRH_WLEN_A :: LCRH_WLEN_DATABIT8 } } # [doc = "Field `LCRH_WLEN` writer - UART Word Length The bits indicate the number of data bits transmitted or received in a frame as follows:"] pub type LCRH_WLEN_W < 'a , REG , const O : u8 > = crate :: FieldWriterSafe < 'a , REG , 2 , O , LCRH_WLEN_A > ; impl < 'a , REG , const O : u8 > LCRH_WLEN_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "DATABIT5"] # [inline (always)] pub fn lcrh_wlen_databit5 (self) -> & 'a mut crate :: W < REG > { self . variant (LCRH_WLEN_A :: LCRH_WLEN_DATABIT5) } # [doc = "DATABIT6"] # [inline (always)] pub fn lcrh_wlen_databit6 (self) -> & 'a mut crate :: W < REG > { self . variant (LCRH_WLEN_A :: LCRH_WLEN_DATABIT6) } # [doc = "DATABIT7"] # [inline (always)] pub fn lcrh_wlen_databit7 (self) -> & 'a mut crate :: W < REG > { self . variant (LCRH_WLEN_A :: LCRH_WLEN_DATABIT7) } # [doc = "DATABIT8"] # [inline (always)] pub fn lcrh_wlen_databit8 (self) -> & 'a mut crate :: W < REG > { self . variant (LCRH_WLEN_A :: LCRH_WLEN_DATABIT8) } } # [doc = "Field `LCRH_SPS` reader - UART Stick Parity Select The Stick Parity Select (SPS) bit is used to set either a permanent '1' or a permanent '0' as parity when transmitting or receiving data. Its purpose is to typically indicate the first byte of a package or to mark an address byte, for example in a multi-drop RS-485 network. 0h = Stick parity is disabled 1h = Stick parity is enabled. When bits PEN, EPS, and SPS of UARTLCRH are set, the parity bit is transmitted and checked as a 0. When bits PEN and SPS are set and EPS is cleared, the parity bit is transmitted and checked as a 1."] pub type LCRH_SPS_R = crate :: BitReader < LCRH_SPS_A > ; # [doc = "UART Stick Parity Select The Stick Parity Select (SPS) bit is used to set either a permanent '1' or a permanent '0' as parity when transmitting or receiving data. Its purpose is to typically indicate the first byte of a package or to mark an address byte, for example in a multi-drop RS-485 network. 0h = Stick parity is disabled 1h = Stick parity is enabled. When bits PEN, EPS, and SPS of UARTLCRH are set, the parity bit is transmitted and checked as a 0. When bits PEN and SPS are set and EPS is cleared, the parity bit is transmitted and checked as a 1.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum LCRH_SPS_A { # [doc = "0: DISABLE"] LCRH_SPS_DISABLE = 0 , # [doc = "1: ENABLE"] LCRH_SPS_ENABLE = 1 , } impl From < LCRH_SPS_A > for bool { # [inline (always)] fn from (variant : LCRH_SPS_A) -> Self { variant as u8 != 0 } } impl LCRH_SPS_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> LCRH_SPS_A { match self . bits { false => LCRH_SPS_A :: LCRH_SPS_DISABLE , true => LCRH_SPS_A :: LCRH_SPS_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_lcrh_sps_disable (& self) -> bool { * self == LCRH_SPS_A :: LCRH_SPS_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_lcrh_sps_enable (& self) -> bool { * self == LCRH_SPS_A :: LCRH_SPS_ENABLE } } # [doc = "Field `LCRH_SPS` writer - UART Stick Parity Select The Stick Parity Select (SPS) bit is used to set either a permanent '1' or a permanent '0' as parity when transmitting or receiving data. Its purpose is to typically indicate the first byte of a package or to mark an address byte, for example in a multi-drop RS-485 network. 0h = Stick parity is disabled 1h = Stick parity is enabled. When bits PEN, EPS, and SPS of UARTLCRH are set, the parity bit is transmitted and checked as a 0. When bits PEN and SPS are set and EPS is cleared, the parity bit is transmitted and checked as a 1."] pub type LCRH_SPS_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , LCRH_SPS_A > ; impl < 'a , REG , const O : u8 > LCRH_SPS_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn lcrh_sps_disable (self) -> & 'a mut crate :: W < REG > { self . variant (LCRH_SPS_A :: LCRH_SPS_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn lcrh_sps_enable (self) -> & 'a mut crate :: W < REG > { self . variant (LCRH_SPS_A :: LCRH_SPS_ENABLE) } } # [doc = "Field `LCRH_SENDIDLE` reader - UART send IDLE pattern. When this bit is set an SENDIDLE period of 11 bit times will be sent on the TX line. The bit is cleared by hardware afterwards."] pub type LCRH_SENDIDLE_R = crate :: BitReader < LCRH_SENDIDLE_A > ; # [doc = "UART send IDLE pattern. When this bit is set an SENDIDLE period of 11 bit times will be sent on the TX line. The bit is cleared by hardware afterwards.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum LCRH_SENDIDLE_A { # [doc = "0: DISABLE"] LCRH_SENDIDLE_DISABLE = 0 , # [doc = "1: ENABLE"] LCRH_SENDIDLE_ENABLE = 1 , } impl From < LCRH_SENDIDLE_A > for bool { # [inline (always)] fn from (variant : LCRH_SENDIDLE_A) -> Self { variant as u8 != 0 } } impl LCRH_SENDIDLE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> LCRH_SENDIDLE_A { match self . bits { false => LCRH_SENDIDLE_A :: LCRH_SENDIDLE_DISABLE , true => LCRH_SENDIDLE_A :: LCRH_SENDIDLE_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_lcrh_sendidle_disable (& self) -> bool { * self == LCRH_SENDIDLE_A :: LCRH_SENDIDLE_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_lcrh_sendidle_enable (& self) -> bool { * self == LCRH_SENDIDLE_A :: LCRH_SENDIDLE_ENABLE } } # [doc = "Field `LCRH_SENDIDLE` writer - UART send IDLE pattern. When this bit is set an SENDIDLE period of 11 bit times will be sent on the TX line. The bit is cleared by hardware afterwards."] pub type LCRH_SENDIDLE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , LCRH_SENDIDLE_A > ; impl < 'a , REG , const O : u8 > LCRH_SENDIDLE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn lcrh_sendidle_disable (self) -> & 'a mut crate :: W < REG > { self . variant (LCRH_SENDIDLE_A :: LCRH_SENDIDLE_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn lcrh_sendidle_enable (self) -> & 'a mut crate :: W < REG > { self . variant (LCRH_SENDIDLE_A :: LCRH_SENDIDLE_ENABLE) } } # [doc = "Field `LCRH_EXTDIR_SETUP` reader - Defines the number of UARTclk ticks the signal to control the external driver for the RS485 will be set before the START bit is send"] pub type LCRH_EXTDIR_SETUP_R = crate :: FieldReader ; # [doc = "Field `LCRH_EXTDIR_SETUP` writer - Defines the number of UARTclk ticks the signal to control the external driver for the RS485 will be set before the START bit is send"] pub type LCRH_EXTDIR_SETUP_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 5 , O > ; # [doc = "Field `LCRH_EXTDIR_HOLD` reader - Defines the number of UARTclk ticks the signal to control the external driver for the RS485 will be reset after the beginning of the stop bit. (If 2 STOP bits are enabled the beginning of the 2nd STOP bit.)"] pub type LCRH_EXTDIR_HOLD_R = crate :: FieldReader ; # [doc = "Field `LCRH_EXTDIR_HOLD` writer - Defines the number of UARTclk ticks the signal to control the external driver for the RS485 will be reset after the beginning of the stop bit. (If 2 STOP bits are enabled the beginning of the 2nd STOP bit.)"] pub type LCRH_EXTDIR_HOLD_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 5 , O > ; impl R { # [doc = "Bit 0 - UART Send Break (for LIN Protocol)"] # [inline (always)] pub fn lcrh_brk (& self) -> LCRH_BRK_R { LCRH_BRK_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - UART Parity Enable"] # [inline (always)] pub fn lcrh_pen (& self) -> LCRH_PEN_R { LCRH_PEN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - UART Even Parity Select This bit has no effect when parity is disabled by the PEN bit. For 9-Bit UART Mode transmissions, this bit controls the address byte and data byte indication (9th bit). 0 = The transferred byte is a data byte 1 = The transferred byte is an address byte"] # [inline (always)] pub fn lcrh_eps (& self) -> LCRH_EPS_R { LCRH_EPS_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - UART Two Stop Bits Select When in 7816 smart card mode (the SMART bit is set in the UARTCTL register), the number of stop bits is forced to 2."] # [inline (always)] pub fn lcrh_stp2 (& self) -> LCRH_STP2_R { LCRH_STP2_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - UART Word Length The bits indicate the number of data bits transmitted or received in a frame as follows:"] # [inline (always)] pub fn lcrh_wlen (& self) -> LCRH_WLEN_R { LCRH_WLEN_R :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bit 6 - UART Stick Parity Select The Stick Parity Select (SPS) bit is used to set either a permanent '1' or a permanent '0' as parity when transmitting or receiving data. Its purpose is to typically indicate the first byte of a package or to mark an address byte, for example in a multi-drop RS-485 network. 0h = Stick parity is disabled 1h = Stick parity is enabled. When bits PEN, EPS, and SPS of UARTLCRH are set, the parity bit is transmitted and checked as a 0. When bits PEN and SPS are set and EPS is cleared, the parity bit is transmitted and checked as a 1."] # [inline (always)] pub fn lcrh_sps (& self) -> LCRH_SPS_R { LCRH_SPS_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - UART send IDLE pattern. When this bit is set an SENDIDLE period of 11 bit times will be sent on the TX line. The bit is cleared by hardware afterwards."] # [inline (always)] pub fn lcrh_sendidle (& self) -> LCRH_SENDIDLE_R { LCRH_SENDIDLE_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bits 16:20 - Defines the number of UARTclk ticks the signal to control the external driver for the RS485 will be set before the START bit is send"] # [inline (always)] pub fn lcrh_extdir_setup (& self) -> LCRH_EXTDIR_SETUP_R { LCRH_EXTDIR_SETUP_R :: new (((self . bits >> 16) & 0x1f) as u8) } # [doc = "Bits 21:25 - Defines the number of UARTclk ticks the signal to control the external driver for the RS485 will be reset after the beginning of the stop bit. (If 2 STOP bits are enabled the beginning of the 2nd STOP bit.)"] # [inline (always)] pub fn lcrh_extdir_hold (& self) -> LCRH_EXTDIR_HOLD_R { LCRH_EXTDIR_HOLD_R :: new (((self . bits >> 21) & 0x1f) as u8) } } impl W { # [doc = "Bit 0 - UART Send Break (for LIN Protocol)"] # [inline (always)] # [must_use] pub fn lcrh_brk (& mut self) -> LCRH_BRK_W < LCRH_SPEC , 0 > { LCRH_BRK_W :: new (self) } # [doc = "Bit 1 - UART Parity Enable"] # [inline (always)] # [must_use] pub fn lcrh_pen (& mut self) -> LCRH_PEN_W < LCRH_SPEC , 1 > { LCRH_PEN_W :: new (self) } # [doc = "Bit 2 - UART Even Parity Select This bit has no effect when parity is disabled by the PEN bit. For 9-Bit UART Mode transmissions, this bit controls the address byte and data byte indication (9th bit). 0 = The transferred byte is a data byte 1 = The transferred byte is an address byte"] # [inline (always)] # [must_use] pub fn lcrh_eps (& mut self) -> LCRH_EPS_W < LCRH_SPEC , 2 > { LCRH_EPS_W :: new (self) } # [doc = "Bit 3 - UART Two Stop Bits Select When in 7816 smart card mode (the SMART bit is set in the UARTCTL register), the number of stop bits is forced to 2."] # [inline (always)] # [must_use] pub fn lcrh_stp2 (& mut self) -> LCRH_STP2_W < LCRH_SPEC , 3 > { LCRH_STP2_W :: new (self) } # [doc = "Bits 4:5 - UART Word Length The bits indicate the number of data bits transmitted or received in a frame as follows:"] # [inline (always)] # [must_use] pub fn lcrh_wlen (& mut self) -> LCRH_WLEN_W < LCRH_SPEC , 4 > { LCRH_WLEN_W :: new (self) } # [doc = "Bit 6 - UART Stick Parity Select The Stick Parity Select (SPS) bit is used to set either a permanent '1' or a permanent '0' as parity when transmitting or receiving data. Its purpose is to typically indicate the first byte of a package or to mark an address byte, for example in a multi-drop RS-485 network. 0h = Stick parity is disabled 1h = Stick parity is enabled. When bits PEN, EPS, and SPS of UARTLCRH are set, the parity bit is transmitted and checked as a 0. When bits PEN and SPS are set and EPS is cleared, the parity bit is transmitted and checked as a 1."] # [inline (always)] # [must_use] pub fn lcrh_sps (& mut self) -> LCRH_SPS_W < LCRH_SPEC , 6 > { LCRH_SPS_W :: new (self) } # [doc = "Bit 7 - UART send IDLE pattern. When this bit is set an SENDIDLE period of 11 bit times will be sent on the TX line. The bit is cleared by hardware afterwards."] # [inline (always)] # [must_use] pub fn lcrh_sendidle (& mut self) -> LCRH_SENDIDLE_W < LCRH_SPEC , 7 > { LCRH_SENDIDLE_W :: new (self) } # [doc = "Bits 16:20 - Defines the number of UARTclk ticks the signal to control the external driver for the RS485 will be set before the START bit is send"] # [inline (always)] # [must_use] pub fn lcrh_extdir_setup (& mut self) -> LCRH_EXTDIR_SETUP_W < LCRH_SPEC , 16 > { LCRH_EXTDIR_SETUP_W :: new (self) } # [doc = "Bits 21:25 - Defines the number of UARTclk ticks the signal to control the external driver for the RS485 will be reset after the beginning of the stop bit. (If 2 STOP bits are enabled the beginning of the 2nd STOP bit.)"] # [inline (always)] # [must_use] pub fn lcrh_extdir_hold (& mut self) -> LCRH_EXTDIR_HOLD_W < LCRH_SPEC , 21 > { LCRH_EXTDIR_HOLD_W :: new (self) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "UART Line Control Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`lcrh::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lcrh::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct LCRH_SPEC ; impl crate :: RegisterSpec for LCRH_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`lcrh::R`](R) reader structure"] impl crate :: Readable for LCRH_SPEC { } # [doc = "`write(|w| ..)` method takes [`lcrh::W`](W) writer structure"] impl crate :: Writable for LCRH_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LCRH to value 0"] impl crate :: Resettable for LCRH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }