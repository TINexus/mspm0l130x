# [doc = "Register `GFCTL` reader"] pub type R = crate :: R < GFCTL_SPEC > ; # [doc = "Register `GFCTL` writer"] pub type W = crate :: W < GFCTL_SPEC > ; # [doc = "Field `GFCTL_DGFSEL` reader - Glitch Suppression Pulse Width This field controls the pulse width select for glitch suppression on the RX line. The following values are the glitch suppression values in terms of functional clocks. In IRDA mode: Receive filter length. The minimum pulse length for receive is given by: t(MIN) = (DGFSEL) / f(IRTXCLK)"] pub type GFCTL_DGFSEL_R = crate :: FieldReader < GFCTL_DGFSEL_A > ; # [doc = "Glitch Suppression Pulse Width This field controls the pulse width select for glitch suppression on the RX line. The following values are the glitch suppression values in terms of functional clocks. In IRDA mode: Receive filter length. The minimum pulse length for receive is given by: t(MIN) = (DGFSEL) / f(IRTXCLK)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum GFCTL_DGFSEL_A { # [doc = "0: DISABLED"] GFCTL_DGFSEL_DISABLED = 0 , } impl From < GFCTL_DGFSEL_A > for u8 { # [inline (always)] fn from (variant : GFCTL_DGFSEL_A) -> Self { variant as _ } } impl crate :: FieldSpec for GFCTL_DGFSEL_A { type Ux = u8 ; } impl GFCTL_DGFSEL_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < GFCTL_DGFSEL_A > { match self . bits { 0 => Some (GFCTL_DGFSEL_A :: GFCTL_DGFSEL_DISABLED) , _ => None , } } # [doc = "DISABLED"] # [inline (always)] pub fn is_gfctl_dgfsel_disabled (& self) -> bool { * self == GFCTL_DGFSEL_A :: GFCTL_DGFSEL_DISABLED } } # [doc = "Field `GFCTL_DGFSEL` writer - Glitch Suppression Pulse Width This field controls the pulse width select for glitch suppression on the RX line. The following values are the glitch suppression values in terms of functional clocks. In IRDA mode: Receive filter length. The minimum pulse length for receive is given by: t(MIN) = (DGFSEL) / f(IRTXCLK)"] pub type GFCTL_DGFSEL_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 6 , O , GFCTL_DGFSEL_A > ; impl < 'a , REG , const O : u8 > GFCTL_DGFSEL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "DISABLED"] # [inline (always)] pub fn gfctl_dgfsel_disabled (self) -> & 'a mut crate :: W < REG > { self . variant (GFCTL_DGFSEL_A :: GFCTL_DGFSEL_DISABLED) } } # [doc = "Field `GFCTL_AGFEN` reader - Analog Glitch Suppression Enable"] pub type GFCTL_AGFEN_R = crate :: BitReader < GFCTL_AGFEN_A > ; # [doc = "Analog Glitch Suppression Enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum GFCTL_AGFEN_A { # [doc = "0: DISABLE"] GFCTL_AGFEN_DISABLE = 0 , # [doc = "1: ENABLE"] GFCTL_AGFEN_ENABLE = 1 , } impl From < GFCTL_AGFEN_A > for bool { # [inline (always)] fn from (variant : GFCTL_AGFEN_A) -> Self { variant as u8 != 0 } } impl GFCTL_AGFEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> GFCTL_AGFEN_A { match self . bits { false => GFCTL_AGFEN_A :: GFCTL_AGFEN_DISABLE , true => GFCTL_AGFEN_A :: GFCTL_AGFEN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_gfctl_agfen_disable (& self) -> bool { * self == GFCTL_AGFEN_A :: GFCTL_AGFEN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_gfctl_agfen_enable (& self) -> bool { * self == GFCTL_AGFEN_A :: GFCTL_AGFEN_ENABLE } } # [doc = "Field `GFCTL_AGFEN` writer - Analog Glitch Suppression Enable"] pub type GFCTL_AGFEN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , GFCTL_AGFEN_A > ; impl < 'a , REG , const O : u8 > GFCTL_AGFEN_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn gfctl_agfen_disable (self) -> & 'a mut crate :: W < REG > { self . variant (GFCTL_AGFEN_A :: GFCTL_AGFEN_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn gfctl_agfen_enable (self) -> & 'a mut crate :: W < REG > { self . variant (GFCTL_AGFEN_A :: GFCTL_AGFEN_ENABLE) } } # [doc = "Field `GFCTL_AGFSEL` reader - Analog Glitch Suppression Pulse Width This field controls the pulse width select for the analog glitch suppression on the RX line. See device datasheet for exact values. (ULP UART only)"] pub type GFCTL_AGFSEL_R = crate :: FieldReader < GFCTL_AGFSEL_A > ; # [doc = "Analog Glitch Suppression Pulse Width This field controls the pulse width select for the analog glitch suppression on the RX line. See device datasheet for exact values. (ULP UART only)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum GFCTL_AGFSEL_A { # [doc = "0: AGLIT_5"] GFCTL_AGFSEL_AGLIT_5 = 0 , # [doc = "1: AGLIT_10"] GFCTL_AGFSEL_AGLIT_10 = 1 , # [doc = "2: AGLIT_25"] GFCTL_AGFSEL_AGLIT_25 = 2 , # [doc = "3: AGLIT_50"] GFCTL_AGFSEL_AGLIT_50 = 3 , } impl From < GFCTL_AGFSEL_A > for u8 { # [inline (always)] fn from (variant : GFCTL_AGFSEL_A) -> Self { variant as _ } } impl crate :: FieldSpec for GFCTL_AGFSEL_A { type Ux = u8 ; } impl GFCTL_AGFSEL_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> GFCTL_AGFSEL_A { match self . bits { 0 => GFCTL_AGFSEL_A :: GFCTL_AGFSEL_AGLIT_5 , 1 => GFCTL_AGFSEL_A :: GFCTL_AGFSEL_AGLIT_10 , 2 => GFCTL_AGFSEL_A :: GFCTL_AGFSEL_AGLIT_25 , 3 => GFCTL_AGFSEL_A :: GFCTL_AGFSEL_AGLIT_50 , _ => unreachable ! () , } } # [doc = "AGLIT_5"] # [inline (always)] pub fn is_gfctl_agfsel_aglit_5 (& self) -> bool { * self == GFCTL_AGFSEL_A :: GFCTL_AGFSEL_AGLIT_5 } # [doc = "AGLIT_10"] # [inline (always)] pub fn is_gfctl_agfsel_aglit_10 (& self) -> bool { * self == GFCTL_AGFSEL_A :: GFCTL_AGFSEL_AGLIT_10 } # [doc = "AGLIT_25"] # [inline (always)] pub fn is_gfctl_agfsel_aglit_25 (& self) -> bool { * self == GFCTL_AGFSEL_A :: GFCTL_AGFSEL_AGLIT_25 } # [doc = "AGLIT_50"] # [inline (always)] pub fn is_gfctl_agfsel_aglit_50 (& self) -> bool { * self == GFCTL_AGFSEL_A :: GFCTL_AGFSEL_AGLIT_50 } } # [doc = "Field `GFCTL_AGFSEL` writer - Analog Glitch Suppression Pulse Width This field controls the pulse width select for the analog glitch suppression on the RX line. See device datasheet for exact values. (ULP UART only)"] pub type GFCTL_AGFSEL_W < 'a , REG , const O : u8 > = crate :: FieldWriterSafe < 'a , REG , 2 , O , GFCTL_AGFSEL_A > ; impl < 'a , REG , const O : u8 > GFCTL_AGFSEL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "AGLIT_5"] # [inline (always)] pub fn gfctl_agfsel_aglit_5 (self) -> & 'a mut crate :: W < REG > { self . variant (GFCTL_AGFSEL_A :: GFCTL_AGFSEL_AGLIT_5) } # [doc = "AGLIT_10"] # [inline (always)] pub fn gfctl_agfsel_aglit_10 (self) -> & 'a mut crate :: W < REG > { self . variant (GFCTL_AGFSEL_A :: GFCTL_AGFSEL_AGLIT_10) } # [doc = "AGLIT_25"] # [inline (always)] pub fn gfctl_agfsel_aglit_25 (self) -> & 'a mut crate :: W < REG > { self . variant (GFCTL_AGFSEL_A :: GFCTL_AGFSEL_AGLIT_25) } # [doc = "AGLIT_50"] # [inline (always)] pub fn gfctl_agfsel_aglit_50 (self) -> & 'a mut crate :: W < REG > { self . variant (GFCTL_AGFSEL_A :: GFCTL_AGFSEL_AGLIT_50) } } # [doc = "Field `GFCTL_CHAIN` reader - Analog and digital noise filters chaining enable. 0 DISABLE: When 0, chaining is disabled and only digital filter output is available to IP logic for sampling 1 ENABLE: When 1, analog and digital glitch filters are chained and the output of the combination is made available to IP logic for sampling"] pub type GFCTL_CHAIN_R = crate :: BitReader < GFCTL_CHAIN_A > ; # [doc = "Analog and digital noise filters chaining enable. 0 DISABLE: When 0, chaining is disabled and only digital filter output is available to IP logic for sampling 1 ENABLE: When 1, analog and digital glitch filters are chained and the output of the combination is made available to IP logic for sampling\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum GFCTL_CHAIN_A { # [doc = "0: DISABLED"] GFCTL_CHAIN_DISABLED = 0 , # [doc = "1: ENABLED"] GFCTL_CHAIN_ENABLED = 1 , } impl From < GFCTL_CHAIN_A > for bool { # [inline (always)] fn from (variant : GFCTL_CHAIN_A) -> Self { variant as u8 != 0 } } impl GFCTL_CHAIN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> GFCTL_CHAIN_A { match self . bits { false => GFCTL_CHAIN_A :: GFCTL_CHAIN_DISABLED , true => GFCTL_CHAIN_A :: GFCTL_CHAIN_ENABLED , } } # [doc = "DISABLED"] # [inline (always)] pub fn is_gfctl_chain_disabled (& self) -> bool { * self == GFCTL_CHAIN_A :: GFCTL_CHAIN_DISABLED } # [doc = "ENABLED"] # [inline (always)] pub fn is_gfctl_chain_enabled (& self) -> bool { * self == GFCTL_CHAIN_A :: GFCTL_CHAIN_ENABLED } } # [doc = "Field `GFCTL_CHAIN` writer - Analog and digital noise filters chaining enable. 0 DISABLE: When 0, chaining is disabled and only digital filter output is available to IP logic for sampling 1 ENABLE: When 1, analog and digital glitch filters are chained and the output of the combination is made available to IP logic for sampling"] pub type GFCTL_CHAIN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , GFCTL_CHAIN_A > ; impl < 'a , REG , const O : u8 > GFCTL_CHAIN_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLED"] # [inline (always)] pub fn gfctl_chain_disabled (self) -> & 'a mut crate :: W < REG > { self . variant (GFCTL_CHAIN_A :: GFCTL_CHAIN_DISABLED) } # [doc = "ENABLED"] # [inline (always)] pub fn gfctl_chain_enabled (self) -> & 'a mut crate :: W < REG > { self . variant (GFCTL_CHAIN_A :: GFCTL_CHAIN_ENABLED) } } impl R { # [doc = "Bits 0:5 - Glitch Suppression Pulse Width This field controls the pulse width select for glitch suppression on the RX line. The following values are the glitch suppression values in terms of functional clocks. In IRDA mode: Receive filter length. The minimum pulse length for receive is given by: t(MIN) = (DGFSEL) / f(IRTXCLK)"] # [inline (always)] pub fn gfctl_dgfsel (& self) -> GFCTL_DGFSEL_R { GFCTL_DGFSEL_R :: new ((self . bits & 0x3f) as u8) } # [doc = "Bit 8 - Analog Glitch Suppression Enable"] # [inline (always)] pub fn gfctl_agfen (& self) -> GFCTL_AGFEN_R { GFCTL_AGFEN_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bits 9:10 - Analog Glitch Suppression Pulse Width This field controls the pulse width select for the analog glitch suppression on the RX line. See device datasheet for exact values. (ULP UART only)"] # [inline (always)] pub fn gfctl_agfsel (& self) -> GFCTL_AGFSEL_R { GFCTL_AGFSEL_R :: new (((self . bits >> 9) & 3) as u8) } # [doc = "Bit 11 - Analog and digital noise filters chaining enable. 0 DISABLE: When 0, chaining is disabled and only digital filter output is available to IP logic for sampling 1 ENABLE: When 1, analog and digital glitch filters are chained and the output of the combination is made available to IP logic for sampling"] # [inline (always)] pub fn gfctl_chain (& self) -> GFCTL_CHAIN_R { GFCTL_CHAIN_R :: new (((self . bits >> 11) & 1) != 0) } } impl W { # [doc = "Bits 0:5 - Glitch Suppression Pulse Width This field controls the pulse width select for glitch suppression on the RX line. The following values are the glitch suppression values in terms of functional clocks. In IRDA mode: Receive filter length. The minimum pulse length for receive is given by: t(MIN) = (DGFSEL) / f(IRTXCLK)"] # [inline (always)] # [must_use] pub fn gfctl_dgfsel (& mut self) -> GFCTL_DGFSEL_W < GFCTL_SPEC , 0 > { GFCTL_DGFSEL_W :: new (self) } # [doc = "Bit 8 - Analog Glitch Suppression Enable"] # [inline (always)] # [must_use] pub fn gfctl_agfen (& mut self) -> GFCTL_AGFEN_W < GFCTL_SPEC , 8 > { GFCTL_AGFEN_W :: new (self) } # [doc = "Bits 9:10 - Analog Glitch Suppression Pulse Width This field controls the pulse width select for the analog glitch suppression on the RX line. See device datasheet for exact values. (ULP UART only)"] # [inline (always)] # [must_use] pub fn gfctl_agfsel (& mut self) -> GFCTL_AGFSEL_W < GFCTL_SPEC , 9 > { GFCTL_AGFSEL_W :: new (self) } # [doc = "Bit 11 - Analog and digital noise filters chaining enable. 0 DISABLE: When 0, chaining is disabled and only digital filter output is available to IP logic for sampling 1 ENABLE: When 1, analog and digital glitch filters are chained and the output of the combination is made available to IP logic for sampling"] # [inline (always)] # [must_use] pub fn gfctl_chain (& mut self) -> GFCTL_CHAIN_W < GFCTL_SPEC , 11 > { GFCTL_CHAIN_W :: new (self) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Glitch Filter Control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`gfctl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`gfctl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct GFCTL_SPEC ; impl crate :: RegisterSpec for GFCTL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`gfctl::R`](R) reader structure"] impl crate :: Readable for GFCTL_SPEC { } # [doc = "`write(|w| ..)` method takes [`gfctl::W`](W) writer structure"] impl crate :: Writable for GFCTL_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GFCTL to value 0"] impl crate :: Resettable for GFCTL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }