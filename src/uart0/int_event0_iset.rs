# [doc = "Register `INT_EVENT0_ISET` writer"] pub type W = crate :: W < INT_EVENT0_ISET_SPEC > ; # [doc = "Set UARTOUT Receive Time-Out Interrupt.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_RTOUT_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_RTOUT_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_RTOUT_SET = 1 , } impl From < INT_EVENT0_ISET_RTOUT_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_RTOUT_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_RTOUT` writer - Set UARTOUT Receive Time-Out Interrupt."] pub type INT_EVENT0_ISET_RTOUT_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_RTOUT_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_RTOUT_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_rtout_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_RTOUT_AW :: INT_EVENT0_ISET_RTOUT_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_rtout_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_RTOUT_AW :: INT_EVENT0_ISET_RTOUT_SET) } } # [doc = "Set UART Framing Error Interrupt.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_FRMERR_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_FRMERR_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_FRMERR_SET = 1 , } impl From < INT_EVENT0_ISET_FRMERR_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_FRMERR_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_FRMERR` writer - Set UART Framing Error Interrupt."] pub type INT_EVENT0_ISET_FRMERR_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_FRMERR_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_FRMERR_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_frmerr_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_FRMERR_AW :: INT_EVENT0_ISET_FRMERR_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_frmerr_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_FRMERR_AW :: INT_EVENT0_ISET_FRMERR_SET) } } # [doc = "Set UART Parity Error Interrupt.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_PARERR_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_PARERR_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_PARERR_SET = 1 , } impl From < INT_EVENT0_ISET_PARERR_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_PARERR_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_PARERR` writer - Set UART Parity Error Interrupt."] pub type INT_EVENT0_ISET_PARERR_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_PARERR_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_PARERR_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_parerr_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_PARERR_AW :: INT_EVENT0_ISET_PARERR_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_parerr_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_PARERR_AW :: INT_EVENT0_ISET_PARERR_SET) } } # [doc = "Set UART Break Error Interrupt.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_BRKERR_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_BRKERR_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_BRKERR_SET = 1 , } impl From < INT_EVENT0_ISET_BRKERR_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_BRKERR_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_BRKERR` writer - Set UART Break Error Interrupt."] pub type INT_EVENT0_ISET_BRKERR_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_BRKERR_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_BRKERR_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_brkerr_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_BRKERR_AW :: INT_EVENT0_ISET_BRKERR_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_brkerr_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_BRKERR_AW :: INT_EVENT0_ISET_BRKERR_SET) } } # [doc = "Set UART Receive Overrun Error Interrupt.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_OVRERR_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_OVRERR_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_OVRERR_SET = 1 , } impl From < INT_EVENT0_ISET_OVRERR_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_OVRERR_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_OVRERR` writer - Set UART Receive Overrun Error Interrupt."] pub type INT_EVENT0_ISET_OVRERR_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_OVRERR_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_OVRERR_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_ovrerr_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_OVRERR_AW :: INT_EVENT0_ISET_OVRERR_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_ovrerr_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_OVRERR_AW :: INT_EVENT0_ISET_OVRERR_SET) } } # [doc = "Set Negative Edge on UARTxRXD Interrupt.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_RXNE_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_RXNE_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_RXNE_SET = 1 , } impl From < INT_EVENT0_ISET_RXNE_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_RXNE_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_RXNE` writer - Set Negative Edge on UARTxRXD Interrupt."] pub type INT_EVENT0_ISET_RXNE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_RXNE_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_RXNE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_rxne_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_RXNE_AW :: INT_EVENT0_ISET_RXNE_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_rxne_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_RXNE_AW :: INT_EVENT0_ISET_RXNE_SET) } } # [doc = "Set Positive Edge on UARTxRXD Interrupt.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_RXPE_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_RXPE_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_RXPE_SET = 1 , } impl From < INT_EVENT0_ISET_RXPE_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_RXPE_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_RXPE` writer - Set Positive Edge on UARTxRXD Interrupt."] pub type INT_EVENT0_ISET_RXPE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_RXPE_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_RXPE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_rxpe_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_RXPE_AW :: INT_EVENT0_ISET_RXPE_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_rxpe_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_RXPE_AW :: INT_EVENT0_ISET_RXPE_SET) } } # [doc = "Set LIN Capture 0 / Match Interrupt .\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_LINC0_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_LINC0_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_LINC0_SET = 1 , } impl From < INT_EVENT0_ISET_LINC0_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_LINC0_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_LINC0` writer - Set LIN Capture 0 / Match Interrupt ."] pub type INT_EVENT0_ISET_LINC0_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_LINC0_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_LINC0_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_linc0_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_LINC0_AW :: INT_EVENT0_ISET_LINC0_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_linc0_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_LINC0_AW :: INT_EVENT0_ISET_LINC0_SET) } } # [doc = "Set LIN Capture 1 Interrupt.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_LINC1_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_LINC1_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_LINC1_SET = 1 , } impl From < INT_EVENT0_ISET_LINC1_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_LINC1_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_LINC1` writer - Set LIN Capture 1 Interrupt."] pub type INT_EVENT0_ISET_LINC1_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_LINC1_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_LINC1_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_linc1_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_LINC1_AW :: INT_EVENT0_ISET_LINC1_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_linc1_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_LINC1_AW :: INT_EVENT0_ISET_LINC1_SET) } } # [doc = "Set LIN Hardware Counter Overflow Interrupt.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_LINOVF_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_LINOVF_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_LINOVF_SET = 1 , } impl From < INT_EVENT0_ISET_LINOVF_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_LINOVF_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_LINOVF` writer - Set LIN Hardware Counter Overflow Interrupt."] pub type INT_EVENT0_ISET_LINOVF_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_LINOVF_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_LINOVF_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_linovf_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_LINOVF_AW :: INT_EVENT0_ISET_LINOVF_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_linovf_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_LINOVF_AW :: INT_EVENT0_ISET_LINOVF_SET) } } # [doc = "Set UART Receive Interrupt.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_RXINT_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_RXINT_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_RXINT_SET = 1 , } impl From < INT_EVENT0_ISET_RXINT_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_RXINT_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_RXINT` writer - Set UART Receive Interrupt."] pub type INT_EVENT0_ISET_RXINT_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_RXINT_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_RXINT_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_rxint_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_RXINT_AW :: INT_EVENT0_ISET_RXINT_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_rxint_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_RXINT_AW :: INT_EVENT0_ISET_RXINT_SET) } } # [doc = "Set UART Transmit Interrupt.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_TXINT_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_TXINT_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_TXINT_SET = 1 , } impl From < INT_EVENT0_ISET_TXINT_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_TXINT_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_TXINT` writer - Set UART Transmit Interrupt."] pub type INT_EVENT0_ISET_TXINT_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_TXINT_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_TXINT_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_txint_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_TXINT_AW :: INT_EVENT0_ISET_TXINT_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_txint_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_TXINT_AW :: INT_EVENT0_ISET_TXINT_SET) } } # [doc = "Set UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_EOT_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_EOT_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_EOT_SET = 1 , } impl From < INT_EVENT0_ISET_EOT_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_EOT_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_EOT` writer - Set UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer."] pub type INT_EVENT0_ISET_EOT_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_EOT_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_EOT_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_eot_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_EOT_AW :: INT_EVENT0_ISET_EOT_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_eot_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_EOT_AW :: INT_EVENT0_ISET_EOT_SET) } } # [doc = "Set Address Match Interrupt.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_ADDR_MATCH_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_ADDR_MATCH_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_ADDR_MATCH_SET = 1 , } impl From < INT_EVENT0_ISET_ADDR_MATCH_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_ADDR_MATCH_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_ADDR_MATCH` writer - Set Address Match Interrupt."] pub type INT_EVENT0_ISET_ADDR_MATCH_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_ADDR_MATCH_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_ADDR_MATCH_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_addr_match_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_ADDR_MATCH_AW :: INT_EVENT0_ISET_ADDR_MATCH_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_addr_match_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_ADDR_MATCH_AW :: INT_EVENT0_ISET_ADDR_MATCH_SET) } } # [doc = "Set UART Clear to Send Modem Interrupt. 0 = Interrupt disabled\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_CTS_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_CTS_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_CTS_SET = 1 , } impl From < INT_EVENT0_ISET_CTS_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_CTS_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_CTS` writer - Set UART Clear to Send Modem Interrupt. 0 = Interrupt disabled"] pub type INT_EVENT0_ISET_CTS_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_CTS_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_CTS_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_cts_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_CTS_AW :: INT_EVENT0_ISET_CTS_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_cts_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_CTS_AW :: INT_EVENT0_ISET_CTS_SET) } } # [doc = "Set DMA Done on RX Event Channel\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_DMA_DONE_RX_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_DMA_DONE_RX_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_DMA_DONE_RX_SET = 1 , } impl From < INT_EVENT0_ISET_DMA_DONE_RX_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_DMA_DONE_RX_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_DMA_DONE_RX` writer - Set DMA Done on RX Event Channel"] pub type INT_EVENT0_ISET_DMA_DONE_RX_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_DMA_DONE_RX_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_DMA_DONE_RX_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_dma_done_rx_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_DMA_DONE_RX_AW :: INT_EVENT0_ISET_DMA_DONE_RX_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_dma_done_rx_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_DMA_DONE_RX_AW :: INT_EVENT0_ISET_DMA_DONE_RX_SET) } } # [doc = "Set DMA Done on TX Event Channel\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_DMA_DONE_TX_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_DMA_DONE_TX_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_DMA_DONE_TX_SET = 1 , } impl From < INT_EVENT0_ISET_DMA_DONE_TX_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_DMA_DONE_TX_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_DMA_DONE_TX` writer - Set DMA Done on TX Event Channel"] pub type INT_EVENT0_ISET_DMA_DONE_TX_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_DMA_DONE_TX_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_DMA_DONE_TX_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_dma_done_tx_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_DMA_DONE_TX_AW :: INT_EVENT0_ISET_DMA_DONE_TX_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_dma_done_tx_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_DMA_DONE_TX_AW :: INT_EVENT0_ISET_DMA_DONE_TX_SET) } } # [doc = "Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ISET_NERR_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ISET_NERR_NO_EFFECT = 0 , # [doc = "1: SET"] INT_EVENT0_ISET_NERR_SET = 1 , } impl From < INT_EVENT0_ISET_NERR_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ISET_NERR_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ISET_NERR` writer - Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal"] pub type INT_EVENT0_ISET_NERR_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ISET_NERR_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ISET_NERR_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iset_nerr_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_NERR_AW :: INT_EVENT0_ISET_NERR_NO_EFFECT) } # [doc = "SET"] # [inline (always)] pub fn int_event0_iset_nerr_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ISET_NERR_AW :: INT_EVENT0_ISET_NERR_SET) } } impl W { # [doc = "Bit 0 - Set UARTOUT Receive Time-Out Interrupt."] # [inline (always)] # [must_use] pub fn int_event0_iset_rtout (& mut self) -> INT_EVENT0_ISET_RTOUT_W < INT_EVENT0_ISET_SPEC , 0 > { INT_EVENT0_ISET_RTOUT_W :: new (self) } # [doc = "Bit 1 - Set UART Framing Error Interrupt."] # [inline (always)] # [must_use] pub fn int_event0_iset_frmerr (& mut self) -> INT_EVENT0_ISET_FRMERR_W < INT_EVENT0_ISET_SPEC , 1 > { INT_EVENT0_ISET_FRMERR_W :: new (self) } # [doc = "Bit 2 - Set UART Parity Error Interrupt."] # [inline (always)] # [must_use] pub fn int_event0_iset_parerr (& mut self) -> INT_EVENT0_ISET_PARERR_W < INT_EVENT0_ISET_SPEC , 2 > { INT_EVENT0_ISET_PARERR_W :: new (self) } # [doc = "Bit 3 - Set UART Break Error Interrupt."] # [inline (always)] # [must_use] pub fn int_event0_iset_brkerr (& mut self) -> INT_EVENT0_ISET_BRKERR_W < INT_EVENT0_ISET_SPEC , 3 > { INT_EVENT0_ISET_BRKERR_W :: new (self) } # [doc = "Bit 4 - Set UART Receive Overrun Error Interrupt."] # [inline (always)] # [must_use] pub fn int_event0_iset_ovrerr (& mut self) -> INT_EVENT0_ISET_OVRERR_W < INT_EVENT0_ISET_SPEC , 4 > { INT_EVENT0_ISET_OVRERR_W :: new (self) } # [doc = "Bit 5 - Set Negative Edge on UARTxRXD Interrupt."] # [inline (always)] # [must_use] pub fn int_event0_iset_rxne (& mut self) -> INT_EVENT0_ISET_RXNE_W < INT_EVENT0_ISET_SPEC , 5 > { INT_EVENT0_ISET_RXNE_W :: new (self) } # [doc = "Bit 6 - Set Positive Edge on UARTxRXD Interrupt."] # [inline (always)] # [must_use] pub fn int_event0_iset_rxpe (& mut self) -> INT_EVENT0_ISET_RXPE_W < INT_EVENT0_ISET_SPEC , 6 > { INT_EVENT0_ISET_RXPE_W :: new (self) } # [doc = "Bit 7 - Set LIN Capture 0 / Match Interrupt ."] # [inline (always)] # [must_use] pub fn int_event0_iset_linc0 (& mut self) -> INT_EVENT0_ISET_LINC0_W < INT_EVENT0_ISET_SPEC , 7 > { INT_EVENT0_ISET_LINC0_W :: new (self) } # [doc = "Bit 8 - Set LIN Capture 1 Interrupt."] # [inline (always)] # [must_use] pub fn int_event0_iset_linc1 (& mut self) -> INT_EVENT0_ISET_LINC1_W < INT_EVENT0_ISET_SPEC , 8 > { INT_EVENT0_ISET_LINC1_W :: new (self) } # [doc = "Bit 9 - Set LIN Hardware Counter Overflow Interrupt."] # [inline (always)] # [must_use] pub fn int_event0_iset_linovf (& mut self) -> INT_EVENT0_ISET_LINOVF_W < INT_EVENT0_ISET_SPEC , 9 > { INT_EVENT0_ISET_LINOVF_W :: new (self) } # [doc = "Bit 10 - Set UART Receive Interrupt."] # [inline (always)] # [must_use] pub fn int_event0_iset_rxint (& mut self) -> INT_EVENT0_ISET_RXINT_W < INT_EVENT0_ISET_SPEC , 10 > { INT_EVENT0_ISET_RXINT_W :: new (self) } # [doc = "Bit 11 - Set UART Transmit Interrupt."] # [inline (always)] # [must_use] pub fn int_event0_iset_txint (& mut self) -> INT_EVENT0_ISET_TXINT_W < INT_EVENT0_ISET_SPEC , 11 > { INT_EVENT0_ISET_TXINT_W :: new (self) } # [doc = "Bit 12 - Set UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer."] # [inline (always)] # [must_use] pub fn int_event0_iset_eot (& mut self) -> INT_EVENT0_ISET_EOT_W < INT_EVENT0_ISET_SPEC , 12 > { INT_EVENT0_ISET_EOT_W :: new (self) } # [doc = "Bit 13 - Set Address Match Interrupt."] # [inline (always)] # [must_use] pub fn int_event0_iset_addr_match (& mut self) -> INT_EVENT0_ISET_ADDR_MATCH_W < INT_EVENT0_ISET_SPEC , 13 > { INT_EVENT0_ISET_ADDR_MATCH_W :: new (self) } # [doc = "Bit 14 - Set UART Clear to Send Modem Interrupt. 0 = Interrupt disabled"] # [inline (always)] # [must_use] pub fn int_event0_iset_cts (& mut self) -> INT_EVENT0_ISET_CTS_W < INT_EVENT0_ISET_SPEC , 14 > { INT_EVENT0_ISET_CTS_W :: new (self) } # [doc = "Bit 15 - Set DMA Done on RX Event Channel"] # [inline (always)] # [must_use] pub fn int_event0_iset_dma_done_rx (& mut self) -> INT_EVENT0_ISET_DMA_DONE_RX_W < INT_EVENT0_ISET_SPEC , 15 > { INT_EVENT0_ISET_DMA_DONE_RX_W :: new (self) } # [doc = "Bit 16 - Set DMA Done on TX Event Channel"] # [inline (always)] # [must_use] pub fn int_event0_iset_dma_done_tx (& mut self) -> INT_EVENT0_ISET_DMA_DONE_TX_W < INT_EVENT0_ISET_SPEC , 16 > { INT_EVENT0_ISET_DMA_DONE_TX_W :: new (self) } # [doc = "Bit 17 - Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal"] # [inline (always)] # [must_use] pub fn int_event0_iset_nerr (& mut self) -> INT_EVENT0_ISET_NERR_W < INT_EVENT0_ISET_SPEC , 17 > { INT_EVENT0_ISET_NERR_W :: new (self) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Interrupt set\n\nYou can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_event0_iset::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT_EVENT0_ISET_SPEC ; impl crate :: RegisterSpec for INT_EVENT0_ISET_SPEC { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`int_event0_iset::W`](W) writer structure"] impl crate :: Writable for INT_EVENT0_ISET_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT_EVENT0_ISET to value 0"] impl crate :: Resettable for INT_EVENT0_ISET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }