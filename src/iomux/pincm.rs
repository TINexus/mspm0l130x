# [doc = "Register `PINCM[%s]` reader"] pub type R = crate :: R < PINCM_SPEC > ; # [doc = "Register `PINCM[%s]` writer"] pub type W = crate :: W < PINCM_SPEC > ; # [doc = "Field `PINCM_PF` reader - P channel Function selection bits"] pub type PINCM_PF_R = crate :: FieldReader ; # [doc = "Field `PINCM_PF` writer - P channel Function selection bits"] pub type PINCM_PF_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 6 , O > ; # [doc = "Field `PINCM_PC` reader - Peripheral is Connected"] pub type PINCM_PC_R = crate :: BitReader < PINCM_PC_A > ; # [doc = "Peripheral is Connected\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum PINCM_PC_A { # [doc = "0: UNCONNECTED"] PINCM_PC_UNCONNECTED = 0 , # [doc = "1: CONNECTED"] PINCM_PC_CONNECTED = 1 , } impl From < PINCM_PC_A > for bool { # [inline (always)] fn from (variant : PINCM_PC_A) -> Self { variant as u8 != 0 } } impl PINCM_PC_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> PINCM_PC_A { match self . bits { false => PINCM_PC_A :: PINCM_PC_UNCONNECTED , true => PINCM_PC_A :: PINCM_PC_CONNECTED , } } # [doc = "UNCONNECTED"] # [inline (always)] pub fn is_pincm_pc_unconnected (& self) -> bool { * self == PINCM_PC_A :: PINCM_PC_UNCONNECTED } # [doc = "CONNECTED"] # [inline (always)] pub fn is_pincm_pc_connected (& self) -> bool { * self == PINCM_PC_A :: PINCM_PC_CONNECTED } } # [doc = "Field `PINCM_PC` writer - Peripheral is Connected"] pub type PINCM_PC_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , PINCM_PC_A > ; impl < 'a , REG , const O : u8 > PINCM_PC_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "UNCONNECTED"] # [inline (always)] pub fn pincm_pc_unconnected (self) -> & 'a mut crate :: W < REG > { self . variant (PINCM_PC_A :: PINCM_PC_UNCONNECTED) } # [doc = "CONNECTED"] # [inline (always)] pub fn pincm_pc_connected (self) -> & 'a mut crate :: W < REG > { self . variant (PINCM_PC_A :: PINCM_PC_CONNECTED) } } # [doc = "Field `PINCM_WAKESTAT` reader - This has the IOPAD WAKEUP signal as status bit."] pub type PINCM_WAKESTAT_R = crate :: BitReader < PINCM_WAKESTAT_A > ; # [doc = "This has the IOPAD WAKEUP signal as status bit.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum PINCM_WAKESTAT_A { # [doc = "0: DISABLE"] PINCM_WAKESTAT_DISABLE = 0 , # [doc = "1: ENABLE"] PINCM_WAKESTAT_ENABLE = 1 , } impl From < PINCM_WAKESTAT_A > for bool { # [inline (always)] fn from (variant : PINCM_WAKESTAT_A) -> Self { variant as u8 != 0 } } impl PINCM_WAKESTAT_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> PINCM_WAKESTAT_A { match self . bits { false => PINCM_WAKESTAT_A :: PINCM_WAKESTAT_DISABLE , true => PINCM_WAKESTAT_A :: PINCM_WAKESTAT_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_pincm_wakestat_disable (& self) -> bool { * self == PINCM_WAKESTAT_A :: PINCM_WAKESTAT_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_pincm_wakestat_enable (& self) -> bool { * self == PINCM_WAKESTAT_A :: PINCM_WAKESTAT_ENABLE } } # [doc = "Field `PINCM_PIPD` reader - Pull Down control selection"] pub type PINCM_PIPD_R = crate :: BitReader < PINCM_PIPD_A > ; # [doc = "Pull Down control selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum PINCM_PIPD_A { # [doc = "0: DISABLE"] PINCM_PIPD_DISABLE = 0 , # [doc = "1: ENABLE"] PINCM_PIPD_ENABLE = 1 , } impl From < PINCM_PIPD_A > for bool { # [inline (always)] fn from (variant : PINCM_PIPD_A) -> Self { variant as u8 != 0 } } impl PINCM_PIPD_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> PINCM_PIPD_A { match self . bits { false => PINCM_PIPD_A :: PINCM_PIPD_DISABLE , true => PINCM_PIPD_A :: PINCM_PIPD_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_pincm_pipd_disable (& self) -> bool { * self == PINCM_PIPD_A :: PINCM_PIPD_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_pincm_pipd_enable (& self) -> bool { * self == PINCM_PIPD_A :: PINCM_PIPD_ENABLE } } # [doc = "Field `PINCM_PIPD` writer - Pull Down control selection"] pub type PINCM_PIPD_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , PINCM_PIPD_A > ; impl < 'a , REG , const O : u8 > PINCM_PIPD_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn pincm_pipd_disable (self) -> & 'a mut crate :: W < REG > { self . variant (PINCM_PIPD_A :: PINCM_PIPD_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn pincm_pipd_enable (self) -> & 'a mut crate :: W < REG > { self . variant (PINCM_PIPD_A :: PINCM_PIPD_ENABLE) } } # [doc = "Field `PINCM_PIPU` reader - Pull Up control selection"] pub type PINCM_PIPU_R = crate :: BitReader < PINCM_PIPU_A > ; # [doc = "Pull Up control selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum PINCM_PIPU_A { # [doc = "0: DISABLE"] PINCM_PIPU_DISABLE = 0 , # [doc = "1: ENABLE"] PINCM_PIPU_ENABLE = 1 , } impl From < PINCM_PIPU_A > for bool { # [inline (always)] fn from (variant : PINCM_PIPU_A) -> Self { variant as u8 != 0 } } impl PINCM_PIPU_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> PINCM_PIPU_A { match self . bits { false => PINCM_PIPU_A :: PINCM_PIPU_DISABLE , true => PINCM_PIPU_A :: PINCM_PIPU_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_pincm_pipu_disable (& self) -> bool { * self == PINCM_PIPU_A :: PINCM_PIPU_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_pincm_pipu_enable (& self) -> bool { * self == PINCM_PIPU_A :: PINCM_PIPU_ENABLE } } # [doc = "Field `PINCM_PIPU` writer - Pull Up control selection"] pub type PINCM_PIPU_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , PINCM_PIPU_A > ; impl < 'a , REG , const O : u8 > PINCM_PIPU_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn pincm_pipu_disable (self) -> & 'a mut crate :: W < REG > { self . variant (PINCM_PIPU_A :: PINCM_PIPU_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn pincm_pipu_enable (self) -> & 'a mut crate :: W < REG > { self . variant (PINCM_PIPU_A :: PINCM_PIPU_ENABLE) } } # [doc = "Field `PINCM_INENA` reader - Input Enable Control Selection"] pub type PINCM_INENA_R = crate :: BitReader < PINCM_INENA_A > ; # [doc = "Input Enable Control Selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum PINCM_INENA_A { # [doc = "0: DISABLE"] PINCM_INENA_DISABLE = 0 , # [doc = "1: ENABLE"] PINCM_INENA_ENABLE = 1 , } impl From < PINCM_INENA_A > for bool { # [inline (always)] fn from (variant : PINCM_INENA_A) -> Self { variant as u8 != 0 } } impl PINCM_INENA_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> PINCM_INENA_A { match self . bits { false => PINCM_INENA_A :: PINCM_INENA_DISABLE , true => PINCM_INENA_A :: PINCM_INENA_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_pincm_inena_disable (& self) -> bool { * self == PINCM_INENA_A :: PINCM_INENA_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_pincm_inena_enable (& self) -> bool { * self == PINCM_INENA_A :: PINCM_INENA_ENABLE } } # [doc = "Field `PINCM_INENA` writer - Input Enable Control Selection"] pub type PINCM_INENA_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , PINCM_INENA_A > ; impl < 'a , REG , const O : u8 > PINCM_INENA_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn pincm_inena_disable (self) -> & 'a mut crate :: W < REG > { self . variant (PINCM_INENA_A :: PINCM_INENA_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn pincm_inena_enable (self) -> & 'a mut crate :: W < REG > { self . variant (PINCM_INENA_A :: PINCM_INENA_ENABLE) } } # [doc = "Field `PINCM_HYSTEN` reader - Hystersis Enable Control Selection"] pub type PINCM_HYSTEN_R = crate :: BitReader < PINCM_HYSTEN_A > ; # [doc = "Hystersis Enable Control Selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum PINCM_HYSTEN_A { # [doc = "0: DISABLE"] PINCM_HYSTEN_DISABLE = 0 , # [doc = "1: ENABLE"] PINCM_HYSTEN_ENABLE = 1 , } impl From < PINCM_HYSTEN_A > for bool { # [inline (always)] fn from (variant : PINCM_HYSTEN_A) -> Self { variant as u8 != 0 } } impl PINCM_HYSTEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> PINCM_HYSTEN_A { match self . bits { false => PINCM_HYSTEN_A :: PINCM_HYSTEN_DISABLE , true => PINCM_HYSTEN_A :: PINCM_HYSTEN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_pincm_hysten_disable (& self) -> bool { * self == PINCM_HYSTEN_A :: PINCM_HYSTEN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_pincm_hysten_enable (& self) -> bool { * self == PINCM_HYSTEN_A :: PINCM_HYSTEN_ENABLE } } # [doc = "Field `PINCM_HYSTEN` writer - Hystersis Enable Control Selection"] pub type PINCM_HYSTEN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , PINCM_HYSTEN_A > ; impl < 'a , REG , const O : u8 > PINCM_HYSTEN_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn pincm_hysten_disable (self) -> & 'a mut crate :: W < REG > { self . variant (PINCM_HYSTEN_A :: PINCM_HYSTEN_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn pincm_hysten_enable (self) -> & 'a mut crate :: W < REG > { self . variant (PINCM_HYSTEN_A :: PINCM_HYSTEN_ENABLE) } } # [doc = "Field `PINCM_DRV` reader - Drive strength control selection, for HS IOCELL only"] pub type PINCM_DRV_R = crate :: BitReader < PINCM_DRV_A > ; # [doc = "Drive strength control selection, for HS IOCELL only\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum PINCM_DRV_A { # [doc = "0: DRVVAL0"] PINCM_DRV_DRVVAL0 = 0 , # [doc = "1: DRVVAL1"] PINCM_DRV_DRVVAL1 = 1 , } impl From < PINCM_DRV_A > for bool { # [inline (always)] fn from (variant : PINCM_DRV_A) -> Self { variant as u8 != 0 } } impl PINCM_DRV_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> PINCM_DRV_A { match self . bits { false => PINCM_DRV_A :: PINCM_DRV_DRVVAL0 , true => PINCM_DRV_A :: PINCM_DRV_DRVVAL1 , } } # [doc = "DRVVAL0"] # [inline (always)] pub fn is_pincm_drv_drvval0 (& self) -> bool { * self == PINCM_DRV_A :: PINCM_DRV_DRVVAL0 } # [doc = "DRVVAL1"] # [inline (always)] pub fn is_pincm_drv_drvval1 (& self) -> bool { * self == PINCM_DRV_A :: PINCM_DRV_DRVVAL1 } } # [doc = "Field `PINCM_DRV` writer - Drive strength control selection, for HS IOCELL only"] pub type PINCM_DRV_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , PINCM_DRV_A > ; impl < 'a , REG , const O : u8 > PINCM_DRV_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DRVVAL0"] # [inline (always)] pub fn pincm_drv_drvval0 (self) -> & 'a mut crate :: W < REG > { self . variant (PINCM_DRV_A :: PINCM_DRV_DRVVAL0) } # [doc = "DRVVAL1"] # [inline (always)] pub fn pincm_drv_drvval1 (self) -> & 'a mut crate :: W < REG > { self . variant (PINCM_DRV_A :: PINCM_DRV_DRVVAL1) } } # [doc = "Field `PINCM_HIZ1` reader - High output value will tri-state the output when this bit is enabled"] pub type PINCM_HIZ1_R = crate :: BitReader < PINCM_HIZ1_A > ; # [doc = "High output value will tri-state the output when this bit is enabled\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum PINCM_HIZ1_A { # [doc = "0: DISABLE"] PINCM_HIZ1_DISABLE = 0 , # [doc = "1: ENABLE"] PINCM_HIZ1_ENABLE = 1 , } impl From < PINCM_HIZ1_A > for bool { # [inline (always)] fn from (variant : PINCM_HIZ1_A) -> Self { variant as u8 != 0 } } impl PINCM_HIZ1_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> PINCM_HIZ1_A { match self . bits { false => PINCM_HIZ1_A :: PINCM_HIZ1_DISABLE , true => PINCM_HIZ1_A :: PINCM_HIZ1_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_pincm_hiz1_disable (& self) -> bool { * self == PINCM_HIZ1_A :: PINCM_HIZ1_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_pincm_hiz1_enable (& self) -> bool { * self == PINCM_HIZ1_A :: PINCM_HIZ1_ENABLE } } # [doc = "Field `PINCM_HIZ1` writer - High output value will tri-state the output when this bit is enabled"] pub type PINCM_HIZ1_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , PINCM_HIZ1_A > ; impl < 'a , REG , const O : u8 > PINCM_HIZ1_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn pincm_hiz1_disable (self) -> & 'a mut crate :: W < REG > { self . variant (PINCM_HIZ1_A :: PINCM_HIZ1_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn pincm_hiz1_enable (self) -> & 'a mut crate :: W < REG > { self . variant (PINCM_HIZ1_A :: PINCM_HIZ1_ENABLE) } } # [doc = "Field `PINCM_INV` reader - Data inversion selection"] pub type PINCM_INV_R = crate :: BitReader < PINCM_INV_A > ; # [doc = "Data inversion selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum PINCM_INV_A { # [doc = "0: DISABLE"] PINCM_INV_DISABLE = 0 , # [doc = "1: ENABLE"] PINCM_INV_ENABLE = 1 , } impl From < PINCM_INV_A > for bool { # [inline (always)] fn from (variant : PINCM_INV_A) -> Self { variant as u8 != 0 } } impl PINCM_INV_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> PINCM_INV_A { match self . bits { false => PINCM_INV_A :: PINCM_INV_DISABLE , true => PINCM_INV_A :: PINCM_INV_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_pincm_inv_disable (& self) -> bool { * self == PINCM_INV_A :: PINCM_INV_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_pincm_inv_enable (& self) -> bool { * self == PINCM_INV_A :: PINCM_INV_ENABLE } } # [doc = "Field `PINCM_INV` writer - Data inversion selection"] pub type PINCM_INV_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , PINCM_INV_A > ; impl < 'a , REG , const O : u8 > PINCM_INV_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn pincm_inv_disable (self) -> & 'a mut crate :: W < REG > { self . variant (PINCM_INV_A :: PINCM_INV_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn pincm_inv_enable (self) -> & 'a mut crate :: W < REG > { self . variant (PINCM_INV_A :: PINCM_INV_ENABLE) } } # [doc = "Field `PINCM_WUEN` reader - Wakeup Enable bit"] pub type PINCM_WUEN_R = crate :: BitReader < PINCM_WUEN_A > ; # [doc = "Wakeup Enable bit\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum PINCM_WUEN_A { # [doc = "0: DISABLE"] PINCM_WUEN_DISABLE = 0 , # [doc = "1: ENABLE"] PINCM_WUEN_ENABLE = 1 , } impl From < PINCM_WUEN_A > for bool { # [inline (always)] fn from (variant : PINCM_WUEN_A) -> Self { variant as u8 != 0 } } impl PINCM_WUEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> PINCM_WUEN_A { match self . bits { false => PINCM_WUEN_A :: PINCM_WUEN_DISABLE , true => PINCM_WUEN_A :: PINCM_WUEN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_pincm_wuen_disable (& self) -> bool { * self == PINCM_WUEN_A :: PINCM_WUEN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_pincm_wuen_enable (& self) -> bool { * self == PINCM_WUEN_A :: PINCM_WUEN_ENABLE } } # [doc = "Field `PINCM_WUEN` writer - Wakeup Enable bit"] pub type PINCM_WUEN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , PINCM_WUEN_A > ; impl < 'a , REG , const O : u8 > PINCM_WUEN_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn pincm_wuen_disable (self) -> & 'a mut crate :: W < REG > { self . variant (PINCM_WUEN_A :: PINCM_WUEN_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn pincm_wuen_enable (self) -> & 'a mut crate :: W < REG > { self . variant (PINCM_WUEN_A :: PINCM_WUEN_ENABLE) } } # [doc = "Field `PINCM_WCOMP` reader - Wakeup Compare Value bit"] pub type PINCM_WCOMP_R = crate :: BitReader < PINCM_WCOMP_A > ; # [doc = "Wakeup Compare Value bit\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum PINCM_WCOMP_A { # [doc = "0: MATCH0"] PINCM_WCOMP_MATCH0 = 0 , # [doc = "1: MATCH1"] PINCM_WCOMP_MATCH1 = 1 , } impl From < PINCM_WCOMP_A > for bool { # [inline (always)] fn from (variant : PINCM_WCOMP_A) -> Self { variant as u8 != 0 } } impl PINCM_WCOMP_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> PINCM_WCOMP_A { match self . bits { false => PINCM_WCOMP_A :: PINCM_WCOMP_MATCH0 , true => PINCM_WCOMP_A :: PINCM_WCOMP_MATCH1 , } } # [doc = "MATCH0"] # [inline (always)] pub fn is_pincm_wcomp_match0 (& self) -> bool { * self == PINCM_WCOMP_A :: PINCM_WCOMP_MATCH0 } # [doc = "MATCH1"] # [inline (always)] pub fn is_pincm_wcomp_match1 (& self) -> bool { * self == PINCM_WCOMP_A :: PINCM_WCOMP_MATCH1 } } # [doc = "Field `PINCM_WCOMP` writer - Wakeup Compare Value bit"] pub type PINCM_WCOMP_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , PINCM_WCOMP_A > ; impl < 'a , REG , const O : u8 > PINCM_WCOMP_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "MATCH0"] # [inline (always)] pub fn pincm_wcomp_match0 (self) -> & 'a mut crate :: W < REG > { self . variant (PINCM_WCOMP_A :: PINCM_WCOMP_MATCH0) } # [doc = "MATCH1"] # [inline (always)] pub fn pincm_wcomp_match1 (self) -> & 'a mut crate :: W < REG > { self . variant (PINCM_WCOMP_A :: PINCM_WCOMP_MATCH1) } } impl R { # [doc = "Bits 0:5 - P channel Function selection bits"] # [inline (always)] pub fn pincm_pf (& self) -> PINCM_PF_R { PINCM_PF_R :: new ((self . bits & 0x3f) as u8) } # [doc = "Bit 7 - Peripheral is Connected"] # [inline (always)] pub fn pincm_pc (& self) -> PINCM_PC_R { PINCM_PC_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 13 - This has the IOPAD WAKEUP signal as status bit."] # [inline (always)] pub fn pincm_wakestat (& self) -> PINCM_WAKESTAT_R { PINCM_WAKESTAT_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 16 - Pull Down control selection"] # [inline (always)] pub fn pincm_pipd (& self) -> PINCM_PIPD_R { PINCM_PIPD_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Pull Up control selection"] # [inline (always)] pub fn pincm_pipu (& self) -> PINCM_PIPU_R { PINCM_PIPU_R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Input Enable Control Selection"] # [inline (always)] pub fn pincm_inena (& self) -> PINCM_INENA_R { PINCM_INENA_R :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Hystersis Enable Control Selection"] # [inline (always)] pub fn pincm_hysten (& self) -> PINCM_HYSTEN_R { PINCM_HYSTEN_R :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 20 - Drive strength control selection, for HS IOCELL only"] # [inline (always)] pub fn pincm_drv (& self) -> PINCM_DRV_R { PINCM_DRV_R :: new (((self . bits >> 20) & 1) != 0) } # [doc = "Bit 25 - High output value will tri-state the output when this bit is enabled"] # [inline (always)] pub fn pincm_hiz1 (& self) -> PINCM_HIZ1_R { PINCM_HIZ1_R :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - Data inversion selection"] # [inline (always)] pub fn pincm_inv (& self) -> PINCM_INV_R { PINCM_INV_R :: new (((self . bits >> 26) & 1) != 0) } # [doc = "Bit 27 - Wakeup Enable bit"] # [inline (always)] pub fn pincm_wuen (& self) -> PINCM_WUEN_R { PINCM_WUEN_R :: new (((self . bits >> 27) & 1) != 0) } # [doc = "Bit 28 - Wakeup Compare Value bit"] # [inline (always)] pub fn pincm_wcomp (& self) -> PINCM_WCOMP_R { PINCM_WCOMP_R :: new (((self . bits >> 28) & 1) != 0) } } impl W { # [doc = "Bits 0:5 - P channel Function selection bits"] # [inline (always)] # [must_use] pub fn pincm_pf (& mut self) -> PINCM_PF_W < PINCM_SPEC , 0 > { PINCM_PF_W :: new (self) } # [doc = "Bit 7 - Peripheral is Connected"] # [inline (always)] # [must_use] pub fn pincm_pc (& mut self) -> PINCM_PC_W < PINCM_SPEC , 7 > { PINCM_PC_W :: new (self) } # [doc = "Bit 16 - Pull Down control selection"] # [inline (always)] # [must_use] pub fn pincm_pipd (& mut self) -> PINCM_PIPD_W < PINCM_SPEC , 16 > { PINCM_PIPD_W :: new (self) } # [doc = "Bit 17 - Pull Up control selection"] # [inline (always)] # [must_use] pub fn pincm_pipu (& mut self) -> PINCM_PIPU_W < PINCM_SPEC , 17 > { PINCM_PIPU_W :: new (self) } # [doc = "Bit 18 - Input Enable Control Selection"] # [inline (always)] # [must_use] pub fn pincm_inena (& mut self) -> PINCM_INENA_W < PINCM_SPEC , 18 > { PINCM_INENA_W :: new (self) } # [doc = "Bit 19 - Hystersis Enable Control Selection"] # [inline (always)] # [must_use] pub fn pincm_hysten (& mut self) -> PINCM_HYSTEN_W < PINCM_SPEC , 19 > { PINCM_HYSTEN_W :: new (self) } # [doc = "Bit 20 - Drive strength control selection, for HS IOCELL only"] # [inline (always)] # [must_use] pub fn pincm_drv (& mut self) -> PINCM_DRV_W < PINCM_SPEC , 20 > { PINCM_DRV_W :: new (self) } # [doc = "Bit 25 - High output value will tri-state the output when this bit is enabled"] # [inline (always)] # [must_use] pub fn pincm_hiz1 (& mut self) -> PINCM_HIZ1_W < PINCM_SPEC , 25 > { PINCM_HIZ1_W :: new (self) } # [doc = "Bit 26 - Data inversion selection"] # [inline (always)] # [must_use] pub fn pincm_inv (& mut self) -> PINCM_INV_W < PINCM_SPEC , 26 > { PINCM_INV_W :: new (self) } # [doc = "Bit 27 - Wakeup Enable bit"] # [inline (always)] # [must_use] pub fn pincm_wuen (& mut self) -> PINCM_WUEN_W < PINCM_SPEC , 27 > { PINCM_WUEN_W :: new (self) } # [doc = "Bit 28 - Wakeup Compare Value bit"] # [inline (always)] # [must_use] pub fn pincm_wcomp (& mut self) -> PINCM_WCOMP_W < PINCM_SPEC , 28 > { PINCM_WCOMP_W :: new (self) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Pin Control Management Register in SECCFG region\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`pincm::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pincm::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PINCM_SPEC ; impl crate :: RegisterSpec for PINCM_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`pincm::R`](R) reader structure"] impl crate :: Readable for PINCM_SPEC { } # [doc = "`write(|w| ..)` method takes [`pincm::W`](W) writer structure"] impl crate :: Writable for PINCM_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PINCM[%s]
to value 0"] impl crate :: Resettable for PINCM_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }