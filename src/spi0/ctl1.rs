# [doc = "Register `CTL1` reader"] pub type R = crate :: R < CTL1_SPEC > ; # [doc = "Register `CTL1` writer"] pub type W = crate :: W < CTL1_SPEC > ; # [doc = "Field `CTL1_ENABLE` reader - SPI enable"] pub type CTL1_ENABLE_R = crate :: BitReader < CTL1_ENABLE_A > ; # [doc = "SPI enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL1_ENABLE_A { # [doc = "0: DISABLE"] CTL1_ENABLE_DISABLE = 0 , # [doc = "1: ENABLE"] CTL1_ENABLE_ENABLE = 1 , } impl From < CTL1_ENABLE_A > for bool { # [inline (always)] fn from (variant : CTL1_ENABLE_A) -> Self { variant as u8 != 0 } } impl CTL1_ENABLE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL1_ENABLE_A { match self . bits { false => CTL1_ENABLE_A :: CTL1_ENABLE_DISABLE , true => CTL1_ENABLE_A :: CTL1_ENABLE_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_ctl1_enable_disable (& self) -> bool { * self == CTL1_ENABLE_A :: CTL1_ENABLE_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_ctl1_enable_enable (& self) -> bool { * self == CTL1_ENABLE_A :: CTL1_ENABLE_ENABLE } } # [doc = "Field `CTL1_ENABLE` writer - SPI enable"] pub type CTL1_ENABLE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL1_ENABLE_A > ; impl < 'a , REG , const O : u8 > CTL1_ENABLE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn ctl1_enable_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL1_ENABLE_A :: CTL1_ENABLE_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn ctl1_enable_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL1_ENABLE_A :: CTL1_ENABLE_ENABLE) } } # [doc = "Field `CTL1_LBM` reader - Loop back mode"] pub type CTL1_LBM_R = crate :: BitReader < CTL1_LBM_A > ; # [doc = "Loop back mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL1_LBM_A { # [doc = "0: DISABLE"] CTL1_LBM_DISABLE = 0 , # [doc = "1: ENABLE"] CTL1_LBM_ENABLE = 1 , } impl From < CTL1_LBM_A > for bool { # [inline (always)] fn from (variant : CTL1_LBM_A) -> Self { variant as u8 != 0 } } impl CTL1_LBM_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL1_LBM_A { match self . bits { false => CTL1_LBM_A :: CTL1_LBM_DISABLE , true => CTL1_LBM_A :: CTL1_LBM_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_ctl1_lbm_disable (& self) -> bool { * self == CTL1_LBM_A :: CTL1_LBM_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_ctl1_lbm_enable (& self) -> bool { * self == CTL1_LBM_A :: CTL1_LBM_ENABLE } } # [doc = "Field `CTL1_LBM` writer - Loop back mode"] pub type CTL1_LBM_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL1_LBM_A > ; impl < 'a , REG , const O : u8 > CTL1_LBM_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn ctl1_lbm_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL1_LBM_A :: CTL1_LBM_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn ctl1_lbm_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL1_LBM_A :: CTL1_LBM_ENABLE) } } # [doc = "Field `CTL1_MS` reader - Controller or peripheral mode select. This bit can be modified only when SPI is disabled, CTL1.ENABLE=0."] pub type CTL1_MS_R = crate :: BitReader < CTL1_MS_A > ; # [doc = "Controller or peripheral mode select. This bit can be modified only when SPI is disabled, CTL1.ENABLE=0.\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL1_MS_A { # [doc = "0: DISABLE"] CTL1_MS_DISABLE = 0 , # [doc = "1: ENABLE"] CTL1_MS_ENABLE = 1 , } impl From < CTL1_MS_A > for bool { # [inline (always)] fn from (variant : CTL1_MS_A) -> Self { variant as u8 != 0 } } impl CTL1_MS_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL1_MS_A { match self . bits { false => CTL1_MS_A :: CTL1_MS_DISABLE , true => CTL1_MS_A :: CTL1_MS_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_ctl1_ms_disable (& self) -> bool { * self == CTL1_MS_A :: CTL1_MS_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_ctl1_ms_enable (& self) -> bool { * self == CTL1_MS_A :: CTL1_MS_ENABLE } } # [doc = "Field `CTL1_MS` writer - Controller or peripheral mode select. This bit can be modified only when SPI is disabled, CTL1.ENABLE=0."] pub type CTL1_MS_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL1_MS_A > ; impl < 'a , REG , const O : u8 > CTL1_MS_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn ctl1_ms_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL1_MS_A :: CTL1_MS_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn ctl1_ms_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL1_MS_A :: CTL1_MS_ENABLE) } } # [doc = "Field `CTL1_SOD` reader - Peripheral-mode: Data output disabled This bit is relevant only in the peripheral mode, CTL1.MS=1. In multiple-peripheral systems, it is possible for an SPI controller to broadcast a message to all peripherals in the system while ensuring that only one peripheral drives data onto its serial output line. In such systems the MISO lines from multiple peripherals could be tied together. To operate in such systems, this bitfield can be set if the SPI peripheral is not supposed to drive the MISO line:"] pub type CTL1_SOD_R = crate :: BitReader < CTL1_SOD_A > ; # [doc = "Peripheral-mode: Data output disabled This bit is relevant only in the peripheral mode, CTL1.MS=1. In multiple-peripheral systems, it is possible for an SPI controller to broadcast a message to all peripherals in the system while ensuring that only one peripheral drives data onto its serial output line. In such systems the MISO lines from multiple peripherals could be tied together. To operate in such systems, this bitfield can be set if the SPI peripheral is not supposed to drive the MISO line:\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL1_SOD_A { # [doc = "0: DISABLE"] CTL1_SOD_DISABLE = 0 , # [doc = "1: ENABLE"] CTL1_SOD_ENABLE = 1 , } impl From < CTL1_SOD_A > for bool { # [inline (always)] fn from (variant : CTL1_SOD_A) -> Self { variant as u8 != 0 } } impl CTL1_SOD_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL1_SOD_A { match self . bits { false => CTL1_SOD_A :: CTL1_SOD_DISABLE , true => CTL1_SOD_A :: CTL1_SOD_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_ctl1_sod_disable (& self) -> bool { * self == CTL1_SOD_A :: CTL1_SOD_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_ctl1_sod_enable (& self) -> bool { * self == CTL1_SOD_A :: CTL1_SOD_ENABLE } } # [doc = "Field `CTL1_SOD` writer - Peripheral-mode: Data output disabled This bit is relevant only in the peripheral mode, CTL1.MS=1. In multiple-peripheral systems, it is possible for an SPI controller to broadcast a message to all peripherals in the system while ensuring that only one peripheral drives data onto its serial output line. In such systems the MISO lines from multiple peripherals could be tied together. To operate in such systems, this bitfield can be set if the SPI peripheral is not supposed to drive the MISO line:"] pub type CTL1_SOD_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL1_SOD_A > ; impl < 'a , REG , const O : u8 > CTL1_SOD_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn ctl1_sod_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL1_SOD_A :: CTL1_SOD_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn ctl1_sod_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL1_SOD_A :: CTL1_SOD_ENABLE) } } # [doc = "Field `CTL1_MSB` reader - MSB first select. Controls the direction of the receive and transmit shift register."] pub type CTL1_MSB_R = crate :: BitReader < CTL1_MSB_A > ; # [doc = "MSB first select. Controls the direction of the receive and transmit shift register.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL1_MSB_A { # [doc = "0: DISABLE"] CTL1_MSB_DISABLE = 0 , # [doc = "1: ENABLE"] CTL1_MSB_ENABLE = 1 , } impl From < CTL1_MSB_A > for bool { # [inline (always)] fn from (variant : CTL1_MSB_A) -> Self { variant as u8 != 0 } } impl CTL1_MSB_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL1_MSB_A { match self . bits { false => CTL1_MSB_A :: CTL1_MSB_DISABLE , true => CTL1_MSB_A :: CTL1_MSB_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_ctl1_msb_disable (& self) -> bool { * self == CTL1_MSB_A :: CTL1_MSB_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_ctl1_msb_enable (& self) -> bool { * self == CTL1_MSB_A :: CTL1_MSB_ENABLE } } # [doc = "Field `CTL1_MSB` writer - MSB first select. Controls the direction of the receive and transmit shift register."] pub type CTL1_MSB_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL1_MSB_A > ; impl < 'a , REG , const O : u8 > CTL1_MSB_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn ctl1_msb_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL1_MSB_A :: CTL1_MSB_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn ctl1_msb_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL1_MSB_A :: CTL1_MSB_ENABLE) } } # [doc = "Field `CTL1_PREN` reader - Parity receive enable If enabled, parity reception check will be done for both controller and peripheral modes In case of a parity miss-match the parity error flag RIS.PER will be set."] pub type CTL1_PREN_R = crate :: BitReader < CTL1_PREN_A > ; # [doc = "Parity receive enable If enabled, parity reception check will be done for both controller and peripheral modes In case of a parity miss-match the parity error flag RIS.PER will be set.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL1_PREN_A { # [doc = "0: DISABLE"] CTL1_PREN_DISABLE = 0 , # [doc = "1: ENABLE"] CTL1_PREN_ENABLE = 1 , } impl From < CTL1_PREN_A > for bool { # [inline (always)] fn from (variant : CTL1_PREN_A) -> Self { variant as u8 != 0 } } impl CTL1_PREN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL1_PREN_A { match self . bits { false => CTL1_PREN_A :: CTL1_PREN_DISABLE , true => CTL1_PREN_A :: CTL1_PREN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_ctl1_pren_disable (& self) -> bool { * self == CTL1_PREN_A :: CTL1_PREN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_ctl1_pren_enable (& self) -> bool { * self == CTL1_PREN_A :: CTL1_PREN_ENABLE } } # [doc = "Field `CTL1_PREN` writer - Parity receive enable If enabled, parity reception check will be done for both controller and peripheral modes In case of a parity miss-match the parity error flag RIS.PER will be set."] pub type CTL1_PREN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL1_PREN_A > ; impl < 'a , REG , const O : u8 > CTL1_PREN_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn ctl1_pren_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL1_PREN_A :: CTL1_PREN_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn ctl1_pren_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL1_PREN_A :: CTL1_PREN_ENABLE) } } # [doc = "Field `CTL1_PES` reader - Even Parity Select"] pub type CTL1_PES_R = crate :: BitReader < CTL1_PES_A > ; # [doc = "Even Parity Select\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL1_PES_A { # [doc = "0: DISABLE"] CTL1_PES_DISABLE = 0 , # [doc = "1: ENABLE"] CTL1_PES_ENABLE = 1 , } impl From < CTL1_PES_A > for bool { # [inline (always)] fn from (variant : CTL1_PES_A) -> Self { variant as u8 != 0 } } impl CTL1_PES_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL1_PES_A { match self . bits { false => CTL1_PES_A :: CTL1_PES_DISABLE , true => CTL1_PES_A :: CTL1_PES_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_ctl1_pes_disable (& self) -> bool { * self == CTL1_PES_A :: CTL1_PES_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_ctl1_pes_enable (& self) -> bool { * self == CTL1_PES_A :: CTL1_PES_ENABLE } } # [doc = "Field `CTL1_PES` writer - Even Parity Select"] pub type CTL1_PES_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL1_PES_A > ; impl < 'a , REG , const O : u8 > CTL1_PES_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn ctl1_pes_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL1_PES_A :: CTL1_PES_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn ctl1_pes_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL1_PES_A :: CTL1_PES_ENABLE) } } # [doc = "Field `CTL1_PBS` reader - Parity Bit Select"] pub type CTL1_PBS_R = crate :: BitReader < CTL1_PBS_A > ; # [doc = "Parity Bit Select\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL1_PBS_A { # [doc = "0: DISABLE"] CTL1_PBS_DISABLE = 0 , # [doc = "1: ENABLE"] CTL1_PBS_ENABLE = 1 , } impl From < CTL1_PBS_A > for bool { # [inline (always)] fn from (variant : CTL1_PBS_A) -> Self { variant as u8 != 0 } } impl CTL1_PBS_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL1_PBS_A { match self . bits { false => CTL1_PBS_A :: CTL1_PBS_DISABLE , true => CTL1_PBS_A :: CTL1_PBS_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_ctl1_pbs_disable (& self) -> bool { * self == CTL1_PBS_A :: CTL1_PBS_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_ctl1_pbs_enable (& self) -> bool { * self == CTL1_PBS_A :: CTL1_PBS_ENABLE } } # [doc = "Field `CTL1_PBS` writer - Parity Bit Select"] pub type CTL1_PBS_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL1_PBS_A > ; impl < 'a , REG , const O : u8 > CTL1_PBS_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn ctl1_pbs_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL1_PBS_A :: CTL1_PBS_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn ctl1_pbs_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL1_PBS_A :: CTL1_PBS_ENABLE) } } # [doc = "Field `CTL1_PTEN` reader - Parity transmit enable If enabled, parity transmission will be done for both controller and peripheral modes."] pub type CTL1_PTEN_R = crate :: BitReader < CTL1_PTEN_A > ; # [doc = "Parity transmit enable If enabled, parity transmission will be done for both controller and peripheral modes.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL1_PTEN_A { # [doc = "0: DISABLE"] CTL1_PTEN_DISABLE = 0 , # [doc = "1: ENABLE"] CTL1_PTEN_ENABLE = 1 , } impl From < CTL1_PTEN_A > for bool { # [inline (always)] fn from (variant : CTL1_PTEN_A) -> Self { variant as u8 != 0 } } impl CTL1_PTEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL1_PTEN_A { match self . bits { false => CTL1_PTEN_A :: CTL1_PTEN_DISABLE , true => CTL1_PTEN_A :: CTL1_PTEN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_ctl1_pten_disable (& self) -> bool { * self == CTL1_PTEN_A :: CTL1_PTEN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_ctl1_pten_enable (& self) -> bool { * self == CTL1_PTEN_A :: CTL1_PTEN_ENABLE } } # [doc = "Field `CTL1_PTEN` writer - Parity transmit enable If enabled, parity transmission will be done for both controller and peripheral modes."] pub type CTL1_PTEN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL1_PTEN_A > ; impl < 'a , REG , const O : u8 > CTL1_PTEN_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn ctl1_pten_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL1_PTEN_A :: CTL1_PTEN_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn ctl1_pten_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL1_PTEN_A :: CTL1_PTEN_ENABLE) } } # [doc = "Field `CTL1_CDENABLE` reader - Command/Data Mode enable"] pub type CTL1_CDENABLE_R = crate :: BitReader < CTL1_CDENABLE_A > ; # [doc = "Command/Data Mode enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL1_CDENABLE_A { # [doc = "0: DISABLE"] CTL1_CDENABLE_DISABLE = 0 , # [doc = "1: ENABLE"] CTL1_CDENABLE_ENABLE = 1 , } impl From < CTL1_CDENABLE_A > for bool { # [inline (always)] fn from (variant : CTL1_CDENABLE_A) -> Self { variant as u8 != 0 } } impl CTL1_CDENABLE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL1_CDENABLE_A { match self . bits { false => CTL1_CDENABLE_A :: CTL1_CDENABLE_DISABLE , true => CTL1_CDENABLE_A :: CTL1_CDENABLE_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_ctl1_cdenable_disable (& self) -> bool { * self == CTL1_CDENABLE_A :: CTL1_CDENABLE_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_ctl1_cdenable_enable (& self) -> bool { * self == CTL1_CDENABLE_A :: CTL1_CDENABLE_ENABLE } } # [doc = "Field `CTL1_CDENABLE` writer - Command/Data Mode enable"] pub type CTL1_CDENABLE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL1_CDENABLE_A > ; impl < 'a , REG , const O : u8 > CTL1_CDENABLE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn ctl1_cdenable_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL1_CDENABLE_A :: CTL1_CDENABLE_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn ctl1_cdenable_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL1_CDENABLE_A :: CTL1_CDENABLE_ENABLE) } } # [doc = "Field `CTL1_CDMODE` reader - Command/Data Mode Value When CTL1.CDENABLE is 1, CS3 line is used as C/D signal to distinguish between Command (C/D low) and Data (C/D high) information. When a value is written into the CTL1.CDMODE bits, the C/D (CS3) line will go low for the given numbers of byte which are sent by the SPI, starting with the next value to be transmitted after which, C/D line will go high automatically 0: Manual mode with C/D signal as High 1-14: C/D is low while this number of bytes are being sent after which, this field sets to 0 and C/D goes high. Reading this field at any time returns the remaining number of command bytes. 15: Manual mode with C/D signal as Low."] pub type CTL1_CDMODE_R = crate :: FieldReader < CTL1_CDMODE_A > ; # [doc = "Command/Data Mode Value When CTL1.CDENABLE is 1, CS3 line is used as C/D signal to distinguish between Command (C/D low) and Data (C/D high) information. When a value is written into the CTL1.CDMODE bits, the C/D (CS3) line will go low for the given numbers of byte which are sent by the SPI, starting with the next value to be transmitted after which, C/D line will go high automatically 0: Manual mode with C/D signal as High 1-14: C/D is low while this number of bytes are being sent after which, this field sets to 0 and C/D goes high. Reading this field at any time returns the remaining number of command bytes. 15: Manual mode with C/D signal as Low.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CTL1_CDMODE_A { # [doc = "0: DATA"] CTL1_CDMODE_DATA = 0 , # [doc = "15: COMMAND"] CTL1_CDMODE_COMMAND = 15 , } impl From < CTL1_CDMODE_A > for u8 { # [inline (always)] fn from (variant : CTL1_CDMODE_A) -> Self { variant as _ } } impl crate :: FieldSpec for CTL1_CDMODE_A { type Ux = u8 ; } impl CTL1_CDMODE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CTL1_CDMODE_A > { match self . bits { 0 => Some (CTL1_CDMODE_A :: CTL1_CDMODE_DATA) , 15 => Some (CTL1_CDMODE_A :: CTL1_CDMODE_COMMAND) , _ => None , } } # [doc = "DATA"] # [inline (always)] pub fn is_ctl1_cdmode_data (& self) -> bool { * self == CTL1_CDMODE_A :: CTL1_CDMODE_DATA } # [doc = "COMMAND"] # [inline (always)] pub fn is_ctl1_cdmode_command (& self) -> bool { * self == CTL1_CDMODE_A :: CTL1_CDMODE_COMMAND } } # [doc = "Field `CTL1_CDMODE` writer - Command/Data Mode Value When CTL1.CDENABLE is 1, CS3 line is used as C/D signal to distinguish between Command (C/D low) and Data (C/D high) information. When a value is written into the CTL1.CDMODE bits, the C/D (CS3) line will go low for the given numbers of byte which are sent by the SPI, starting with the next value to be transmitted after which, C/D line will go high automatically 0: Manual mode with C/D signal as High 1-14: C/D is low while this number of bytes are being sent after which, this field sets to 0 and C/D goes high. Reading this field at any time returns the remaining number of command bytes. 15: Manual mode with C/D signal as Low."] pub type CTL1_CDMODE_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 4 , O , CTL1_CDMODE_A > ; impl < 'a , REG , const O : u8 > CTL1_CDMODE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "DATA"] # [inline (always)] pub fn ctl1_cdmode_data (self) -> & 'a mut crate :: W < REG > { self . variant (CTL1_CDMODE_A :: CTL1_CDMODE_DATA) } # [doc = "COMMAND"] # [inline (always)] pub fn ctl1_cdmode_command (self) -> & 'a mut crate :: W < REG > { self . variant (CTL1_CDMODE_A :: CTL1_CDMODE_COMMAND) } } # [doc = "Field `CTL1_REPEATTX` reader - Counter to repeat last transfer 0: repeat last transfer is disabled. x: repeat the last transfer with the given number. The transfer will be started with writing a data into the TX Buffer. Sending the data will be repeated with the given value, so the data will be transferred X+1 times in total. The behavior is identical as if the data would be written into the TX Buffer that many times as defined by the value here. It can be used to clean a transfer or to pull a certain amount of data by a peripheral."] pub type CTL1_REPEATTX_R = crate :: FieldReader < CTL1_REPEATTX_A > ; # [doc = "Counter to repeat last transfer 0: repeat last transfer is disabled. x: repeat the last transfer with the given number. The transfer will be started with writing a data into the TX Buffer. Sending the data will be repeated with the given value, so the data will be transferred X+1 times in total. The behavior is identical as if the data would be written into the TX Buffer that many times as defined by the value here. It can be used to clean a transfer or to pull a certain amount of data by a peripheral.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CTL1_REPEATTX_A { # [doc = "0: DISABLE"] CTL1_REPEATTX_DISABLE = 0 , } impl From < CTL1_REPEATTX_A > for u8 { # [inline (always)] fn from (variant : CTL1_REPEATTX_A) -> Self { variant as _ } } impl crate :: FieldSpec for CTL1_REPEATTX_A { type Ux = u8 ; } impl CTL1_REPEATTX_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CTL1_REPEATTX_A > { match self . bits { 0 => Some (CTL1_REPEATTX_A :: CTL1_REPEATTX_DISABLE) , _ => None , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_ctl1_repeattx_disable (& self) -> bool { * self == CTL1_REPEATTX_A :: CTL1_REPEATTX_DISABLE } } # [doc = "Field `CTL1_REPEATTX` writer - Counter to repeat last transfer 0: repeat last transfer is disabled. x: repeat the last transfer with the given number. The transfer will be started with writing a data into the TX Buffer. Sending the data will be repeated with the given value, so the data will be transferred X+1 times in total. The behavior is identical as if the data would be written into the TX Buffer that many times as defined by the value here. It can be used to clean a transfer or to pull a certain amount of data by a peripheral."] pub type CTL1_REPEATTX_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 8 , O , CTL1_REPEATTX_A > ; impl < 'a , REG , const O : u8 > CTL1_REPEATTX_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "DISABLE"] # [inline (always)] pub fn ctl1_repeattx_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL1_REPEATTX_A :: CTL1_REPEATTX_DISABLE) } } # [doc = "Field `CTL1_RXTIMEOUT` reader - Receive Timeout (only for Peripheral mode) Defines the number of Clock Cycles before after which the Receive Timeout flag RTOUT is set. The time is calculated using the control register for the clock selection and divider in the Controller mode configuration. A value of 0 disables this function."] pub type CTL1_RXTIMEOUT_R = crate :: FieldReader ; # [doc = "Field `CTL1_RXTIMEOUT` writer - Receive Timeout (only for Peripheral mode) Defines the number of Clock Cycles before after which the Receive Timeout flag RTOUT is set. The time is calculated using the control register for the clock selection and divider in the Controller mode configuration. A value of 0 disables this function."] pub type CTL1_RXTIMEOUT_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 6 , O > ; impl R { # [doc = "Bit 0 - SPI enable"] # [inline (always)] pub fn ctl1_enable (& self) -> CTL1_ENABLE_R { CTL1_ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Loop back mode"] # [inline (always)] pub fn ctl1_lbm (& self) -> CTL1_LBM_R { CTL1_LBM_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Controller or peripheral mode select. This bit can be modified only when SPI is disabled, CTL1.ENABLE=0."] # [inline (always)] pub fn ctl1_ms (& self) -> CTL1_MS_R { CTL1_MS_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Peripheral-mode: Data output disabled This bit is relevant only in the peripheral mode, CTL1.MS=1. In multiple-peripheral systems, it is possible for an SPI controller to broadcast a message to all peripherals in the system while ensuring that only one peripheral drives data onto its serial output line. In such systems the MISO lines from multiple peripherals could be tied together. To operate in such systems, this bitfield can be set if the SPI peripheral is not supposed to drive the MISO line:"] # [inline (always)] pub fn ctl1_sod (& self) -> CTL1_SOD_R { CTL1_SOD_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - MSB first select. Controls the direction of the receive and transmit shift register."] # [inline (always)] pub fn ctl1_msb (& self) -> CTL1_MSB_R { CTL1_MSB_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Parity receive enable If enabled, parity reception check will be done for both controller and peripheral modes In case of a parity miss-match the parity error flag RIS.PER will be set."] # [inline (always)] pub fn ctl1_pren (& self) -> CTL1_PREN_R { CTL1_PREN_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Even Parity Select"] # [inline (always)] pub fn ctl1_pes (& self) -> CTL1_PES_R { CTL1_PES_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Parity Bit Select"] # [inline (always)] pub fn ctl1_pbs (& self) -> CTL1_PBS_R { CTL1_PBS_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Parity transmit enable If enabled, parity transmission will be done for both controller and peripheral modes."] # [inline (always)] pub fn ctl1_pten (& self) -> CTL1_PTEN_R { CTL1_PTEN_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 11 - Command/Data Mode enable"] # [inline (always)] pub fn ctl1_cdenable (& self) -> CTL1_CDENABLE_R { CTL1_CDENABLE_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bits 12:15 - Command/Data Mode Value When CTL1.CDENABLE is 1, CS3 line is used as C/D signal to distinguish between Command (C/D low) and Data (C/D high) information. When a value is written into the CTL1.CDMODE bits, the C/D (CS3) line will go low for the given numbers of byte which are sent by the SPI, starting with the next value to be transmitted after which, C/D line will go high automatically 0: Manual mode with C/D signal as High 1-14: C/D is low while this number of bytes are being sent after which, this field sets to 0 and C/D goes high. Reading this field at any time returns the remaining number of command bytes. 15: Manual mode with C/D signal as Low."] # [inline (always)] pub fn ctl1_cdmode (& self) -> CTL1_CDMODE_R { CTL1_CDMODE_R :: new (((self . bits >> 12) & 0x0f) as u8) } # [doc = "Bits 16:23 - Counter to repeat last transfer 0: repeat last transfer is disabled. x: repeat the last transfer with the given number. The transfer will be started with writing a data into the TX Buffer. Sending the data will be repeated with the given value, so the data will be transferred X+1 times in total. The behavior is identical as if the data would be written into the TX Buffer that many times as defined by the value here. It can be used to clean a transfer or to pull a certain amount of data by a peripheral."] # [inline (always)] pub fn ctl1_repeattx (& self) -> CTL1_REPEATTX_R { CTL1_REPEATTX_R :: new (((self . bits >> 16) & 0xff) as u8) } # [doc = "Bits 24:29 - Receive Timeout (only for Peripheral mode) Defines the number of Clock Cycles before after which the Receive Timeout flag RTOUT is set. The time is calculated using the control register for the clock selection and divider in the Controller mode configuration. A value of 0 disables this function."] # [inline (always)] pub fn ctl1_rxtimeout (& self) -> CTL1_RXTIMEOUT_R { CTL1_RXTIMEOUT_R :: new (((self . bits >> 24) & 0x3f) as u8) } } impl W { # [doc = "Bit 0 - SPI enable"] # [inline (always)] # [must_use] pub fn ctl1_enable (& mut self) -> CTL1_ENABLE_W < CTL1_SPEC , 0 > { CTL1_ENABLE_W :: new (self) } # [doc = "Bit 1 - Loop back mode"] # [inline (always)] # [must_use] pub fn ctl1_lbm (& mut self) -> CTL1_LBM_W < CTL1_SPEC , 1 > { CTL1_LBM_W :: new (self) } # [doc = "Bit 2 - Controller or peripheral mode select. This bit can be modified only when SPI is disabled, CTL1.ENABLE=0."] # [inline (always)] # [must_use] pub fn ctl1_ms (& mut self) -> CTL1_MS_W < CTL1_SPEC , 2 > { CTL1_MS_W :: new (self) } # [doc = "Bit 3 - Peripheral-mode: Data output disabled This bit is relevant only in the peripheral mode, CTL1.MS=1. In multiple-peripheral systems, it is possible for an SPI controller to broadcast a message to all peripherals in the system while ensuring that only one peripheral drives data onto its serial output line. In such systems the MISO lines from multiple peripherals could be tied together. To operate in such systems, this bitfield can be set if the SPI peripheral is not supposed to drive the MISO line:"] # [inline (always)] # [must_use] pub fn ctl1_sod (& mut self) -> CTL1_SOD_W < CTL1_SPEC , 3 > { CTL1_SOD_W :: new (self) } # [doc = "Bit 4 - MSB first select. Controls the direction of the receive and transmit shift register."] # [inline (always)] # [must_use] pub fn ctl1_msb (& mut self) -> CTL1_MSB_W < CTL1_SPEC , 4 > { CTL1_MSB_W :: new (self) } # [doc = "Bit 5 - Parity receive enable If enabled, parity reception check will be done for both controller and peripheral modes In case of a parity miss-match the parity error flag RIS.PER will be set."] # [inline (always)] # [must_use] pub fn ctl1_pren (& mut self) -> CTL1_PREN_W < CTL1_SPEC , 5 > { CTL1_PREN_W :: new (self) } # [doc = "Bit 6 - Even Parity Select"] # [inline (always)] # [must_use] pub fn ctl1_pes (& mut self) -> CTL1_PES_W < CTL1_SPEC , 6 > { CTL1_PES_W :: new (self) } # [doc = "Bit 7 - Parity Bit Select"] # [inline (always)] # [must_use] pub fn ctl1_pbs (& mut self) -> CTL1_PBS_W < CTL1_SPEC , 7 > { CTL1_PBS_W :: new (self) } # [doc = "Bit 8 - Parity transmit enable If enabled, parity transmission will be done for both controller and peripheral modes."] # [inline (always)] # [must_use] pub fn ctl1_pten (& mut self) -> CTL1_PTEN_W < CTL1_SPEC , 8 > { CTL1_PTEN_W :: new (self) } # [doc = "Bit 11 - Command/Data Mode enable"] # [inline (always)] # [must_use] pub fn ctl1_cdenable (& mut self) -> CTL1_CDENABLE_W < CTL1_SPEC , 11 > { CTL1_CDENABLE_W :: new (self) } # [doc = "Bits 12:15 - Command/Data Mode Value When CTL1.CDENABLE is 1, CS3 line is used as C/D signal to distinguish between Command (C/D low) and Data (C/D high) information. When a value is written into the CTL1.CDMODE bits, the C/D (CS3) line will go low for the given numbers of byte which are sent by the SPI, starting with the next value to be transmitted after which, C/D line will go high automatically 0: Manual mode with C/D signal as High 1-14: C/D is low while this number of bytes are being sent after which, this field sets to 0 and C/D goes high. Reading this field at any time returns the remaining number of command bytes. 15: Manual mode with C/D signal as Low."] # [inline (always)] # [must_use] pub fn ctl1_cdmode (& mut self) -> CTL1_CDMODE_W < CTL1_SPEC , 12 > { CTL1_CDMODE_W :: new (self) } # [doc = "Bits 16:23 - Counter to repeat last transfer 0: repeat last transfer is disabled. x: repeat the last transfer with the given number. The transfer will be started with writing a data into the TX Buffer. Sending the data will be repeated with the given value, so the data will be transferred X+1 times in total. The behavior is identical as if the data would be written into the TX Buffer that many times as defined by the value here. It can be used to clean a transfer or to pull a certain amount of data by a peripheral."] # [inline (always)] # [must_use] pub fn ctl1_repeattx (& mut self) -> CTL1_REPEATTX_W < CTL1_SPEC , 16 > { CTL1_REPEATTX_W :: new (self) } # [doc = "Bits 24:29 - Receive Timeout (only for Peripheral mode) Defines the number of Clock Cycles before after which the Receive Timeout flag RTOUT is set. The time is calculated using the control register for the clock selection and divider in the Controller mode configuration. A value of 0 disables this function."] # [inline (always)] # [must_use] pub fn ctl1_rxtimeout (& mut self) -> CTL1_RXTIMEOUT_W < CTL1_SPEC , 24 > { CTL1_RXTIMEOUT_W :: new (self) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "SPI control register 1\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ctl1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctl1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CTL1_SPEC ; impl crate :: RegisterSpec for CTL1_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`ctl1::R`](R) reader structure"] impl crate :: Readable for CTL1_SPEC { } # [doc = "`write(|w| ..)` method takes [`ctl1::W`](W) writer structure"] impl crate :: Writable for CTL1_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTL1 to value 0x04"] impl crate :: Resettable for CTL1_SPEC { const RESET_VALUE : Self :: Ux = 0x04 ; }