# [doc = "Register `CTL0` reader"] pub type R = crate :: R < CTL0_SPEC > ; # [doc = "Register `CTL0` writer"] pub type W = crate :: W < CTL0_SPEC > ; # [doc = "Field `CTL0_DSS` reader - Data Size Select. Values 0 - 2 are reserved and shall not be used. 3h = 4_BIT : 4-bit data SPI allows only values up to 16 Bit"] pub type CTL0_DSS_R = crate :: FieldReader < CTL0_DSS_A > ; # [doc = "Data Size Select. Values 0 - 2 are reserved and shall not be used. 3h = 4_BIT : 4-bit data SPI allows only values up to 16 Bit\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CTL0_DSS_A { # [doc = "3: DSS_4"] CTL0_DSS_DSS_4 = 3 , # [doc = "4: DSS_5"] CTL0_DSS_DSS_5 = 4 , # [doc = "5: DSS_6"] CTL0_DSS_DSS_6 = 5 , # [doc = "6: DSS_7"] CTL0_DSS_DSS_7 = 6 , # [doc = "7: DSS_8"] CTL0_DSS_DSS_8 = 7 , # [doc = "8: DSS_9"] CTL0_DSS_DSS_9 = 8 , # [doc = "9: DSS_10"] CTL0_DSS_DSS_10 = 9 , # [doc = "10: DSS_11"] CTL0_DSS_DSS_11 = 10 , # [doc = "11: DSS_12"] CTL0_DSS_DSS_12 = 11 , # [doc = "12: DSS_13"] CTL0_DSS_DSS_13 = 12 , # [doc = "13: DSS_14"] CTL0_DSS_DSS_14 = 13 , # [doc = "14: DSS_15"] CTL0_DSS_DSS_15 = 14 , # [doc = "15: DSS_16"] CTL0_DSS_DSS_16 = 15 , # [doc = "31: DSS_32"] CTL0_DSS_DSS_32 = 31 , } impl From < CTL0_DSS_A > for u8 { # [inline (always)] fn from (variant : CTL0_DSS_A) -> Self { variant as _ } } impl crate :: FieldSpec for CTL0_DSS_A { type Ux = u8 ; } impl CTL0_DSS_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CTL0_DSS_A > { match self . bits { 3 => Some (CTL0_DSS_A :: CTL0_DSS_DSS_4) , 4 => Some (CTL0_DSS_A :: CTL0_DSS_DSS_5) , 5 => Some (CTL0_DSS_A :: CTL0_DSS_DSS_6) , 6 => Some (CTL0_DSS_A :: CTL0_DSS_DSS_7) , 7 => Some (CTL0_DSS_A :: CTL0_DSS_DSS_8) , 8 => Some (CTL0_DSS_A :: CTL0_DSS_DSS_9) , 9 => Some (CTL0_DSS_A :: CTL0_DSS_DSS_10) , 10 => Some (CTL0_DSS_A :: CTL0_DSS_DSS_11) , 11 => Some (CTL0_DSS_A :: CTL0_DSS_DSS_12) , 12 => Some (CTL0_DSS_A :: CTL0_DSS_DSS_13) , 13 => Some (CTL0_DSS_A :: CTL0_DSS_DSS_14) , 14 => Some (CTL0_DSS_A :: CTL0_DSS_DSS_15) , 15 => Some (CTL0_DSS_A :: CTL0_DSS_DSS_16) , 31 => Some (CTL0_DSS_A :: CTL0_DSS_DSS_32) , _ => None , } } # [doc = "DSS_4"] # [inline (always)] pub fn is_ctl0_dss_dss_4 (& self) -> bool { * self == CTL0_DSS_A :: CTL0_DSS_DSS_4 } # [doc = "DSS_5"] # [inline (always)] pub fn is_ctl0_dss_dss_5 (& self) -> bool { * self == CTL0_DSS_A :: CTL0_DSS_DSS_5 } # [doc = "DSS_6"] # [inline (always)] pub fn is_ctl0_dss_dss_6 (& self) -> bool { * self == CTL0_DSS_A :: CTL0_DSS_DSS_6 } # [doc = "DSS_7"] # [inline (always)] pub fn is_ctl0_dss_dss_7 (& self) -> bool { * self == CTL0_DSS_A :: CTL0_DSS_DSS_7 } # [doc = "DSS_8"] # [inline (always)] pub fn is_ctl0_dss_dss_8 (& self) -> bool { * self == CTL0_DSS_A :: CTL0_DSS_DSS_8 } # [doc = "DSS_9"] # [inline (always)] pub fn is_ctl0_dss_dss_9 (& self) -> bool { * self == CTL0_DSS_A :: CTL0_DSS_DSS_9 } # [doc = "DSS_10"] # [inline (always)] pub fn is_ctl0_dss_dss_10 (& self) -> bool { * self == CTL0_DSS_A :: CTL0_DSS_DSS_10 } # [doc = "DSS_11"] # [inline (always)] pub fn is_ctl0_dss_dss_11 (& self) -> bool { * self == CTL0_DSS_A :: CTL0_DSS_DSS_11 } # [doc = "DSS_12"] # [inline (always)] pub fn is_ctl0_dss_dss_12 (& self) -> bool { * self == CTL0_DSS_A :: CTL0_DSS_DSS_12 } # [doc = "DSS_13"] # [inline (always)] pub fn is_ctl0_dss_dss_13 (& self) -> bool { * self == CTL0_DSS_A :: CTL0_DSS_DSS_13 } # [doc = "DSS_14"] # [inline (always)] pub fn is_ctl0_dss_dss_14 (& self) -> bool { * self == CTL0_DSS_A :: CTL0_DSS_DSS_14 } # [doc = "DSS_15"] # [inline (always)] pub fn is_ctl0_dss_dss_15 (& self) -> bool { * self == CTL0_DSS_A :: CTL0_DSS_DSS_15 } # [doc = "DSS_16"] # [inline (always)] pub fn is_ctl0_dss_dss_16 (& self) -> bool { * self == CTL0_DSS_A :: CTL0_DSS_DSS_16 } # [doc = "DSS_32"] # [inline (always)] pub fn is_ctl0_dss_dss_32 (& self) -> bool { * self == CTL0_DSS_A :: CTL0_DSS_DSS_32 } } # [doc = "Field `CTL0_DSS` writer - Data Size Select. Values 0 - 2 are reserved and shall not be used. 3h = 4_BIT : 4-bit data SPI allows only values up to 16 Bit"] pub type CTL0_DSS_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 5 , O , CTL0_DSS_A > ; impl < 'a , REG , const O : u8 > CTL0_DSS_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "DSS_4"] # [inline (always)] pub fn ctl0_dss_dss_4 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_DSS_A :: CTL0_DSS_DSS_4) } # [doc = "DSS_5"] # [inline (always)] pub fn ctl0_dss_dss_5 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_DSS_A :: CTL0_DSS_DSS_5) } # [doc = "DSS_6"] # [inline (always)] pub fn ctl0_dss_dss_6 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_DSS_A :: CTL0_DSS_DSS_6) } # [doc = "DSS_7"] # [inline (always)] pub fn ctl0_dss_dss_7 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_DSS_A :: CTL0_DSS_DSS_7) } # [doc = "DSS_8"] # [inline (always)] pub fn ctl0_dss_dss_8 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_DSS_A :: CTL0_DSS_DSS_8) } # [doc = "DSS_9"] # [inline (always)] pub fn ctl0_dss_dss_9 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_DSS_A :: CTL0_DSS_DSS_9) } # [doc = "DSS_10"] # [inline (always)] pub fn ctl0_dss_dss_10 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_DSS_A :: CTL0_DSS_DSS_10) } # [doc = "DSS_11"] # [inline (always)] pub fn ctl0_dss_dss_11 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_DSS_A :: CTL0_DSS_DSS_11) } # [doc = "DSS_12"] # [inline (always)] pub fn ctl0_dss_dss_12 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_DSS_A :: CTL0_DSS_DSS_12) } # [doc = "DSS_13"] # [inline (always)] pub fn ctl0_dss_dss_13 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_DSS_A :: CTL0_DSS_DSS_13) } # [doc = "DSS_14"] # [inline (always)] pub fn ctl0_dss_dss_14 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_DSS_A :: CTL0_DSS_DSS_14) } # [doc = "DSS_15"] # [inline (always)] pub fn ctl0_dss_dss_15 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_DSS_A :: CTL0_DSS_DSS_15) } # [doc = "DSS_16"] # [inline (always)] pub fn ctl0_dss_dss_16 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_DSS_A :: CTL0_DSS_DSS_16) } # [doc = "DSS_32"] # [inline (always)] pub fn ctl0_dss_dss_32 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_DSS_A :: CTL0_DSS_DSS_32) } } # [doc = "Field `CTL0_FRF` reader - Frame format Select"] pub type CTL0_FRF_R = crate :: FieldReader < CTL0_FRF_A > ; # [doc = "Frame format Select\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CTL0_FRF_A { # [doc = "0: MOTOROLA_3WIRE"] CTL0_FRF_MOTOROLA_3WIRE = 0 , # [doc = "1: MOTOROLA_4WIRE"] CTL0_FRF_MOTOROLA_4WIRE = 1 , # [doc = "2: TI_SYNC"] CTL0_FRF_TI_SYNC = 2 , # [doc = "3: MIRCOWIRE"] CTL0_FRF_MIRCOWIRE = 3 , } impl From < CTL0_FRF_A > for u8 { # [inline (always)] fn from (variant : CTL0_FRF_A) -> Self { variant as _ } } impl crate :: FieldSpec for CTL0_FRF_A { type Ux = u8 ; } impl CTL0_FRF_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL0_FRF_A { match self . bits { 0 => CTL0_FRF_A :: CTL0_FRF_MOTOROLA_3WIRE , 1 => CTL0_FRF_A :: CTL0_FRF_MOTOROLA_4WIRE , 2 => CTL0_FRF_A :: CTL0_FRF_TI_SYNC , 3 => CTL0_FRF_A :: CTL0_FRF_MIRCOWIRE , _ => unreachable ! () , } } # [doc = "MOTOROLA_3WIRE"] # [inline (always)] pub fn is_ctl0_frf_motorola_3wire (& self) -> bool { * self == CTL0_FRF_A :: CTL0_FRF_MOTOROLA_3WIRE } # [doc = "MOTOROLA_4WIRE"] # [inline (always)] pub fn is_ctl0_frf_motorola_4wire (& self) -> bool { * self == CTL0_FRF_A :: CTL0_FRF_MOTOROLA_4WIRE } # [doc = "TI_SYNC"] # [inline (always)] pub fn is_ctl0_frf_ti_sync (& self) -> bool { * self == CTL0_FRF_A :: CTL0_FRF_TI_SYNC } # [doc = "MIRCOWIRE"] # [inline (always)] pub fn is_ctl0_frf_mircowire (& self) -> bool { * self == CTL0_FRF_A :: CTL0_FRF_MIRCOWIRE } } # [doc = "Field `CTL0_FRF` writer - Frame format Select"] pub type CTL0_FRF_W < 'a , REG , const O : u8 > = crate :: FieldWriterSafe < 'a , REG , 2 , O , CTL0_FRF_A > ; impl < 'a , REG , const O : u8 > CTL0_FRF_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "MOTOROLA_3WIRE"] # [inline (always)] pub fn ctl0_frf_motorola_3wire (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_FRF_A :: CTL0_FRF_MOTOROLA_3WIRE) } # [doc = "MOTOROLA_4WIRE"] # [inline (always)] pub fn ctl0_frf_motorola_4wire (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_FRF_A :: CTL0_FRF_MOTOROLA_4WIRE) } # [doc = "TI_SYNC"] # [inline (always)] pub fn ctl0_frf_ti_sync (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_FRF_A :: CTL0_FRF_TI_SYNC) } # [doc = "MIRCOWIRE"] # [inline (always)] pub fn ctl0_frf_mircowire (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_FRF_A :: CTL0_FRF_MIRCOWIRE) } } # [doc = "Field `CTL0_PACKEN` reader - Packing Enable. When 1, packing feature is enabled inside the IP When 0, packing feature is disabled inside the IP"] pub type CTL0_PACKEN_R = crate :: BitReader < CTL0_PACKEN_A > ; # [doc = "Packing Enable. When 1, packing feature is enabled inside the IP When 0, packing feature is disabled inside the IP\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL0_PACKEN_A { # [doc = "0: DISABLED"] CTL0_PACKEN_DISABLED = 0 , # [doc = "1: ENABLED"] CTL0_PACKEN_ENABLED = 1 , } impl From < CTL0_PACKEN_A > for bool { # [inline (always)] fn from (variant : CTL0_PACKEN_A) -> Self { variant as u8 != 0 } } impl CTL0_PACKEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL0_PACKEN_A { match self . bits { false => CTL0_PACKEN_A :: CTL0_PACKEN_DISABLED , true => CTL0_PACKEN_A :: CTL0_PACKEN_ENABLED , } } # [doc = "DISABLED"] # [inline (always)] pub fn is_ctl0_packen_disabled (& self) -> bool { * self == CTL0_PACKEN_A :: CTL0_PACKEN_DISABLED } # [doc = "ENABLED"] # [inline (always)] pub fn is_ctl0_packen_enabled (& self) -> bool { * self == CTL0_PACKEN_A :: CTL0_PACKEN_ENABLED } } # [doc = "Field `CTL0_PACKEN` writer - Packing Enable. When 1, packing feature is enabled inside the IP When 0, packing feature is disabled inside the IP"] pub type CTL0_PACKEN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL0_PACKEN_A > ; impl < 'a , REG , const O : u8 > CTL0_PACKEN_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLED"] # [inline (always)] pub fn ctl0_packen_disabled (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_PACKEN_A :: CTL0_PACKEN_DISABLED) } # [doc = "ENABLED"] # [inline (always)] pub fn ctl0_packen_enabled (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_PACKEN_A :: CTL0_PACKEN_ENABLED) } } # [doc = "Field `CTL0_SPO` reader - CLKOUT polarity (Motorola SPI frame format only)"] pub type CTL0_SPO_R = crate :: BitReader < CTL0_SPO_A > ; # [doc = "CLKOUT polarity (Motorola SPI frame format only)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL0_SPO_A { # [doc = "0: LOW"] CTL0_SPO_LOW = 0 , # [doc = "1: HIGH"] CTL0_SPO_HIGH = 1 , } impl From < CTL0_SPO_A > for bool { # [inline (always)] fn from (variant : CTL0_SPO_A) -> Self { variant as u8 != 0 } } impl CTL0_SPO_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL0_SPO_A { match self . bits { false => CTL0_SPO_A :: CTL0_SPO_LOW , true => CTL0_SPO_A :: CTL0_SPO_HIGH , } } # [doc = "LOW"] # [inline (always)] pub fn is_ctl0_spo_low (& self) -> bool { * self == CTL0_SPO_A :: CTL0_SPO_LOW } # [doc = "HIGH"] # [inline (always)] pub fn is_ctl0_spo_high (& self) -> bool { * self == CTL0_SPO_A :: CTL0_SPO_HIGH } } # [doc = "Field `CTL0_SPO` writer - CLKOUT polarity (Motorola SPI frame format only)"] pub type CTL0_SPO_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL0_SPO_A > ; impl < 'a , REG , const O : u8 > CTL0_SPO_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "LOW"] # [inline (always)] pub fn ctl0_spo_low (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_SPO_A :: CTL0_SPO_LOW) } # [doc = "HIGH"] # [inline (always)] pub fn ctl0_spo_high (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_SPO_A :: CTL0_SPO_HIGH) } } # [doc = "Field `CTL0_SPH` reader - CLKOUT phase (Motorola SPI frame format only) This bit selects the clock edge that captures data and enables it to change state. It has the most impact on the first bit transmitted by either permitting or not permitting a clock transition before the first data capture edge."] pub type CTL0_SPH_R = crate :: BitReader < CTL0_SPH_A > ; # [doc = "CLKOUT phase (Motorola SPI frame format only) This bit selects the clock edge that captures data and enables it to change state. It has the most impact on the first bit transmitted by either permitting or not permitting a clock transition before the first data capture edge.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL0_SPH_A { # [doc = "0: FIRST"] CTL0_SPH_FIRST = 0 , # [doc = "1: SECOND"] CTL0_SPH_SECOND = 1 , } impl From < CTL0_SPH_A > for bool { # [inline (always)] fn from (variant : CTL0_SPH_A) -> Self { variant as u8 != 0 } } impl CTL0_SPH_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL0_SPH_A { match self . bits { false => CTL0_SPH_A :: CTL0_SPH_FIRST , true => CTL0_SPH_A :: CTL0_SPH_SECOND , } } # [doc = "FIRST"] # [inline (always)] pub fn is_ctl0_sph_first (& self) -> bool { * self == CTL0_SPH_A :: CTL0_SPH_FIRST } # [doc = "SECOND"] # [inline (always)] pub fn is_ctl0_sph_second (& self) -> bool { * self == CTL0_SPH_A :: CTL0_SPH_SECOND } } # [doc = "Field `CTL0_SPH` writer - CLKOUT phase (Motorola SPI frame format only) This bit selects the clock edge that captures data and enables it to change state. It has the most impact on the first bit transmitted by either permitting or not permitting a clock transition before the first data capture edge."] pub type CTL0_SPH_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL0_SPH_A > ; impl < 'a , REG , const O : u8 > CTL0_SPH_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "FIRST"] # [inline (always)] pub fn ctl0_sph_first (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_SPH_A :: CTL0_SPH_FIRST) } # [doc = "SECOND"] # [inline (always)] pub fn ctl0_sph_second (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_SPH_A :: CTL0_SPH_SECOND) } } # [doc = "Field `CTL0_CSSEL` reader - Select the CS line to control on data transfer This bit is for controller mode only."] pub type CTL0_CSSEL_R = crate :: FieldReader < CTL0_CSSEL_A > ; # [doc = "Select the CS line to control on data transfer This bit is for controller mode only.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CTL0_CSSEL_A { # [doc = "0: CSSEL_0"] CTL0_CSSEL_CSSEL_0 = 0 , # [doc = "1: CSSEL_1"] CTL0_CSSEL_CSSEL_1 = 1 , # [doc = "2: CSSEL_2"] CTL0_CSSEL_CSSEL_2 = 2 , # [doc = "3: CSSEL_3"] CTL0_CSSEL_CSSEL_3 = 3 , } impl From < CTL0_CSSEL_A > for u8 { # [inline (always)] fn from (variant : CTL0_CSSEL_A) -> Self { variant as _ } } impl crate :: FieldSpec for CTL0_CSSEL_A { type Ux = u8 ; } impl CTL0_CSSEL_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL0_CSSEL_A { match self . bits { 0 => CTL0_CSSEL_A :: CTL0_CSSEL_CSSEL_0 , 1 => CTL0_CSSEL_A :: CTL0_CSSEL_CSSEL_1 , 2 => CTL0_CSSEL_A :: CTL0_CSSEL_CSSEL_2 , 3 => CTL0_CSSEL_A :: CTL0_CSSEL_CSSEL_3 , _ => unreachable ! () , } } # [doc = "CSSEL_0"] # [inline (always)] pub fn is_ctl0_cssel_cssel_0 (& self) -> bool { * self == CTL0_CSSEL_A :: CTL0_CSSEL_CSSEL_0 } # [doc = "CSSEL_1"] # [inline (always)] pub fn is_ctl0_cssel_cssel_1 (& self) -> bool { * self == CTL0_CSSEL_A :: CTL0_CSSEL_CSSEL_1 } # [doc = "CSSEL_2"] # [inline (always)] pub fn is_ctl0_cssel_cssel_2 (& self) -> bool { * self == CTL0_CSSEL_A :: CTL0_CSSEL_CSSEL_2 } # [doc = "CSSEL_3"] # [inline (always)] pub fn is_ctl0_cssel_cssel_3 (& self) -> bool { * self == CTL0_CSSEL_A :: CTL0_CSSEL_CSSEL_3 } } # [doc = "Field `CTL0_CSSEL` writer - Select the CS line to control on data transfer This bit is for controller mode only."] pub type CTL0_CSSEL_W < 'a , REG , const O : u8 > = crate :: FieldWriterSafe < 'a , REG , 2 , O , CTL0_CSSEL_A > ; impl < 'a , REG , const O : u8 > CTL0_CSSEL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "CSSEL_0"] # [inline (always)] pub fn ctl0_cssel_cssel_0 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_CSSEL_A :: CTL0_CSSEL_CSSEL_0) } # [doc = "CSSEL_1"] # [inline (always)] pub fn ctl0_cssel_cssel_1 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_CSSEL_A :: CTL0_CSSEL_CSSEL_1) } # [doc = "CSSEL_2"] # [inline (always)] pub fn ctl0_cssel_cssel_2 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_CSSEL_A :: CTL0_CSSEL_CSSEL_2) } # [doc = "CSSEL_3"] # [inline (always)] pub fn ctl0_cssel_cssel_3 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_CSSEL_A :: CTL0_CSSEL_CSSEL_3) } } # [doc = "Field `CTL0_CSCLR` reader - Clear shift register counter on CS inactive This bit is relevant only in the peripheral, CTL1.MS=0."] pub type CTL0_CSCLR_R = crate :: BitReader < CTL0_CSCLR_A > ; # [doc = "Clear shift register counter on CS inactive This bit is relevant only in the peripheral, CTL1.MS=0.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL0_CSCLR_A { # [doc = "0: DISABLE"] CTL0_CSCLR_DISABLE = 0 , # [doc = "1: ENABLE"] CTL0_CSCLR_ENABLE = 1 , } impl From < CTL0_CSCLR_A > for bool { # [inline (always)] fn from (variant : CTL0_CSCLR_A) -> Self { variant as u8 != 0 } } impl CTL0_CSCLR_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL0_CSCLR_A { match self . bits { false => CTL0_CSCLR_A :: CTL0_CSCLR_DISABLE , true => CTL0_CSCLR_A :: CTL0_CSCLR_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_ctl0_csclr_disable (& self) -> bool { * self == CTL0_CSCLR_A :: CTL0_CSCLR_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_ctl0_csclr_enable (& self) -> bool { * self == CTL0_CSCLR_A :: CTL0_CSCLR_ENABLE } } # [doc = "Field `CTL0_CSCLR` writer - Clear shift register counter on CS inactive This bit is relevant only in the peripheral, CTL1.MS=0."] pub type CTL0_CSCLR_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL0_CSCLR_A > ; impl < 'a , REG , const O : u8 > CTL0_CSCLR_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn ctl0_csclr_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_CSCLR_A :: CTL0_CSCLR_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn ctl0_csclr_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL0_CSCLR_A :: CTL0_CSCLR_ENABLE) } } impl R { # [doc = "Bits 0:4 - Data Size Select. Values 0 - 2 are reserved and shall not be used. 3h = 4_BIT : 4-bit data SPI allows only values up to 16 Bit"] # [inline (always)] pub fn ctl0_dss (& self) -> CTL0_DSS_R { CTL0_DSS_R :: new ((self . bits & 0x1f) as u8) } # [doc = "Bits 5:6 - Frame format Select"] # [inline (always)] pub fn ctl0_frf (& self) -> CTL0_FRF_R { CTL0_FRF_R :: new (((self . bits >> 5) & 3) as u8) } # [doc = "Bit 7 - Packing Enable. When 1, packing feature is enabled inside the IP When 0, packing feature is disabled inside the IP"] # [inline (always)] pub fn ctl0_packen (& self) -> CTL0_PACKEN_R { CTL0_PACKEN_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - CLKOUT polarity (Motorola SPI frame format only)"] # [inline (always)] pub fn ctl0_spo (& self) -> CTL0_SPO_R { CTL0_SPO_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - CLKOUT phase (Motorola SPI frame format only) This bit selects the clock edge that captures data and enables it to change state. It has the most impact on the first bit transmitted by either permitting or not permitting a clock transition before the first data capture edge."] # [inline (always)] pub fn ctl0_sph (& self) -> CTL0_SPH_R { CTL0_SPH_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bits 12:13 - Select the CS line to control on data transfer This bit is for controller mode only."] # [inline (always)] pub fn ctl0_cssel (& self) -> CTL0_CSSEL_R { CTL0_CSSEL_R :: new (((self . bits >> 12) & 3) as u8) } # [doc = "Bit 14 - Clear shift register counter on CS inactive This bit is relevant only in the peripheral, CTL1.MS=0."] # [inline (always)] pub fn ctl0_csclr (& self) -> CTL0_CSCLR_R { CTL0_CSCLR_R :: new (((self . bits >> 14) & 1) != 0) } } impl W { # [doc = "Bits 0:4 - Data Size Select. Values 0 - 2 are reserved and shall not be used. 3h = 4_BIT : 4-bit data SPI allows only values up to 16 Bit"] # [inline (always)] # [must_use] pub fn ctl0_dss (& mut self) -> CTL0_DSS_W < CTL0_SPEC , 0 > { CTL0_DSS_W :: new (self) } # [doc = "Bits 5:6 - Frame format Select"] # [inline (always)] # [must_use] pub fn ctl0_frf (& mut self) -> CTL0_FRF_W < CTL0_SPEC , 5 > { CTL0_FRF_W :: new (self) } # [doc = "Bit 7 - Packing Enable. When 1, packing feature is enabled inside the IP When 0, packing feature is disabled inside the IP"] # [inline (always)] # [must_use] pub fn ctl0_packen (& mut self) -> CTL0_PACKEN_W < CTL0_SPEC , 7 > { CTL0_PACKEN_W :: new (self) } # [doc = "Bit 8 - CLKOUT polarity (Motorola SPI frame format only)"] # [inline (always)] # [must_use] pub fn ctl0_spo (& mut self) -> CTL0_SPO_W < CTL0_SPEC , 8 > { CTL0_SPO_W :: new (self) } # [doc = "Bit 9 - CLKOUT phase (Motorola SPI frame format only) This bit selects the clock edge that captures data and enables it to change state. It has the most impact on the first bit transmitted by either permitting or not permitting a clock transition before the first data capture edge."] # [inline (always)] # [must_use] pub fn ctl0_sph (& mut self) -> CTL0_SPH_W < CTL0_SPEC , 9 > { CTL0_SPH_W :: new (self) } # [doc = "Bits 12:13 - Select the CS line to control on data transfer This bit is for controller mode only."] # [inline (always)] # [must_use] pub fn ctl0_cssel (& mut self) -> CTL0_CSSEL_W < CTL0_SPEC , 12 > { CTL0_CSSEL_W :: new (self) } # [doc = "Bit 14 - Clear shift register counter on CS inactive This bit is relevant only in the peripheral, CTL1.MS=0."] # [inline (always)] # [must_use] pub fn ctl0_csclr (& mut self) -> CTL0_CSCLR_W < CTL0_SPEC , 14 > { CTL0_CSCLR_W :: new (self) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "SPI control register 0\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ctl0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctl0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CTL0_SPEC ; impl crate :: RegisterSpec for CTL0_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`ctl0::R`](R) reader structure"] impl crate :: Readable for CTL0_SPEC { } # [doc = "`write(|w| ..)` method takes [`ctl0::W`](W) writer structure"] impl crate :: Writable for CTL0_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTL0 to value 0"] impl crate :: Resettable for CTL0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }