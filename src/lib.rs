# ! [doc = "Peripheral access API for MSPM0L130X microcontrollers (generated using svd2rust v0.30.2 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.30.2/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"] # ! [deny (dead_code)] # ! [deny (improper_ctypes)] # ! [deny (missing_docs)] # ! [deny (no_mangle_generic_items)] # ! [deny (non_shorthand_field_patterns)] # ! [deny (overflowing_literals)] # ! [deny (path_statements)] # ! [deny (patterns_in_fns_without_body)] # ! [deny (private_bounds)] # ! [deny (private_interfaces)] # ! [deny (unconditional_recursion)] # ! [deny (unused_allocation)] # ! [deny (unused_comparisons)] # ! [deny (unused_parens)] # ! [deny (while_true)] # ! [allow (non_camel_case_types)] # ! [allow (non_snake_case)] # ! [no_std] use core :: ops :: Deref ; use core :: marker :: PhantomData ; # [doc = r"Number available in the NVIC for configuring priority"] pub const NVIC_PRIO_BITS : u8 = 3 ; pub use cortex_m :: peripheral :: Peripherals as CorePeripherals ; # [cfg (feature = "rt")] pub use cortex_m_rt :: interrupt ; # [cfg (feature = "rt")] pub use self :: Interrupt as interrupt ; pub use cortex_m :: peripheral :: { CBP , CPUID , DCB , DWT , FPB , ITM , MPU , NVIC , SCB , SYST , TPIU , } ; # [allow (unused_imports)] use generic :: * ; # [doc = r"Common register and bit access and modify traits"] pub mod generic ; # [cfg (feature = "rt")] extern "C" { } # [doc (hidden)] pub union Vector { _handler : unsafe extern "C" fn () , _reserved : u32 , } # [cfg (feature = "rt")] # [doc (hidden)] # [link_section = ".vector_table.interrupts"] # [no_mangle] pub static __INTERRUPTS : [Vector ; 0] = [] ; # [doc = r"Enumeration of all the interrupts."] # [derive (Copy , Clone , Debug , PartialEq , Eq)] pub enum Interrupt { } unsafe impl cortex_m :: interrupt :: InterruptNumber for Interrupt { # [inline (always)] fn number (self) -> u16 { match self { } } } # [doc = "PERIPHERALREGION"] pub struct UART0 { _marker : PhantomData < * const () > } unsafe impl Send for UART0 { } impl UART0 { # [doc = r"Pointer to the register block"] pub const PTR : * const uart0 :: RegisterBlock = 0x4010_8000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const uart0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for UART0 { type Target = uart0 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for UART0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("UART0") . finish () } } # [doc = "PERIPHERALREGION"] pub mod uart0 ; # [doc = "F65NW"] pub struct FLASHCTL { _marker : PhantomData < * const () > } unsafe impl Send for FLASHCTL { } impl FLASHCTL { # [doc = r"Pointer to the register block"] pub const PTR : * const flashctl :: RegisterBlock = 0x400c_d000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const flashctl :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for FLASHCTL { type Target = flashctl :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for FLASHCTL { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("FLASHCTL") . finish () } } # [doc = "F65NW"] pub mod flashctl ; # [doc = "PERIPHERALREGION"] pub struct SPI0 { _marker : PhantomData < * const () > } unsafe impl Send for SPI0 { } impl SPI0 { # [doc = r"Pointer to the register block"] pub const PTR : * const spi0 :: RegisterBlock = 0x4046_8000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const spi0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for SPI0 { type Target = spi0 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SPI0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SPI0") . finish () } } # [doc = "PERIPHERALREGION"] pub mod spi0 ; # [doc = "PERIPHERALREGION"] pub struct I2C0 { _marker : PhantomData < * const () > } unsafe impl Send for I2C0 { } impl I2C0 { # [doc = r"Pointer to the register block"] pub const PTR : * const i2c0 :: RegisterBlock = 0x400f_0000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const i2c0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for I2C0 { type Target = i2c0 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for I2C0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("I2C0") . finish () } } # [doc = "PERIPHERALREGION"] pub mod i2c0 ; # [doc = "CPUSSMMR"] pub struct CPUSS { _marker : PhantomData < * const () > } unsafe impl Send for CPUSS { } impl CPUSS { # [doc = r"Pointer to the register block"] pub const PTR : * const cpuss :: RegisterBlock = 0x4040_0000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const cpuss :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for CPUSS { type Target = cpuss :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for CPUSS { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("CPUSS") . finish () } } # [doc = "CPUSSMMR"] pub mod cpuss ; # [doc = "PERIPHERALREGION"] pub struct GPIOA { _marker : PhantomData < * const () > } unsafe impl Send for GPIOA { } impl GPIOA { # [doc = r"Pointer to the register block"] pub const PTR : * const gpioa :: RegisterBlock = 0x400a_0000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const gpioa :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for GPIOA { type Target = gpioa :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for GPIOA { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("GPIOA") . finish () } } # [doc = "PERIPHERALREGION"] pub mod gpioa ; # [doc = "PERIPHERALREGION"] pub struct UART1 { _marker : PhantomData < * const () > } unsafe impl Send for UART1 { } impl UART1 { # [doc = r"Pointer to the register block"] pub const PTR : * const uart1 :: RegisterBlock = 0x4010_0000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const uart1 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for UART1 { type Target = uart1 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for UART1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("UART1") . finish () } } # [doc = "PERIPHERALREGION"] pub mod uart1 ; # [doc = "WWDT"] pub struct WWDT0 { _marker : PhantomData < * const () > } unsafe impl Send for WWDT0 { } impl WWDT0 { # [doc = r"Pointer to the register block"] pub const PTR : * const wwdt0 :: RegisterBlock = 0x4008_0000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const wwdt0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for WWDT0 { type Target = wwdt0 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for WWDT0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("WWDT0") . finish () } } # [doc = "WWDT"] pub mod wwdt0 ; # [doc = "DSSM"] pub struct DEBUGSS { _marker : PhantomData < * const () > } unsafe impl Send for DEBUGSS { } impl DEBUGSS { # [doc = r"Pointer to the register block"] pub const PTR : * const debugss :: RegisterBlock = 0x400c_7000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const debugss :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for DEBUGSS { type Target = debugss :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for DEBUGSS { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("DEBUGSS") . finish () } } # [doc = "DSSM"] pub mod debugss ; # [doc = "PERIPHERALREGION"] pub struct VREF { _marker : PhantomData < * const () > } unsafe impl Send for VREF { } impl VREF { # [doc = r"Pointer to the register block"] pub const PTR : * const vref :: RegisterBlock = 0x4003_0000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const vref :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for VREF { type Target = vref :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for VREF { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("VREF") . finish () } } # [doc = "PERIPHERALREGION"] pub mod vref ; # [doc = "PERIPHERALREGION"] pub struct CRC { _marker : PhantomData < * const () > } unsafe impl Send for CRC { } impl CRC { # [doc = r"Pointer to the register block"] pub const PTR : * const crc :: RegisterBlock = 0x4044_0000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const crc :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for CRC { type Target = crc :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for CRC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("CRC") . finish () } } # [doc = "PERIPHERALREGION"] pub mod crc ; # [doc = "PERIPHERALREGION"] pub struct OPA0 { _marker : PhantomData < * const () > } unsafe impl Send for OPA0 { } impl OPA0 { # [doc = r"Pointer to the register block"] pub const PTR : * const opa0 :: RegisterBlock = 0x4002_0000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const opa0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for OPA0 { type Target = opa0 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for OPA0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("OPA0") . finish () } } # [doc = "PERIPHERALREGION"] pub mod opa0 ; # [doc = "PERIPHERALREGION"] pub struct TIMG1 { _marker : PhantomData < * const () > } unsafe impl Send for TIMG1 { } impl TIMG1 { # [doc = r"Pointer to the register block"] pub const PTR : * const timg1 :: RegisterBlock = 0x4008_6000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const timg1 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for TIMG1 { type Target = timg1 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIMG1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIMG1") . finish () } } # [doc = "PERIPHERALREGION"] pub mod timg1 ; # [doc = "PERIPHERALREGION"] pub struct DMA { _marker : PhantomData < * const () > } unsafe impl Send for DMA { } impl DMA { # [doc = r"Pointer to the register block"] pub const PTR : * const dma :: RegisterBlock = 0x4042_a000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const dma :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for DMA { type Target = dma :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for DMA { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("DMA") . finish () } } # [doc = "PERIPHERALREGION"] pub mod dma ; # [doc = "PERIPHERALREGION"] pub struct COMP0 { _marker : PhantomData < * const () > } unsafe impl Send for COMP0 { } impl COMP0 { # [doc = r"Pointer to the register block"] pub const PTR : * const comp0 :: RegisterBlock = 0x4000_8000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const comp0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for COMP0 { type Target = comp0 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for COMP0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("COMP0") . finish () } } # [doc = "PERIPHERALREGION"] pub mod comp0 ; # [doc = "mem_map"] pub struct SYSCTL { _marker : PhantomData < * const () > } unsafe impl Send for SYSCTL { } impl SYSCTL { # [doc = r"Pointer to the register block"] pub const PTR : * const sysctl :: RegisterBlock = 0x400a_f000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const sysctl :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for SYSCTL { type Target = sysctl :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SYSCTL { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SYSCTL") . finish () } } # [doc = "mem_map"] pub mod sysctl ; # [doc = "PERIPHERALREGION"] pub struct OPA1 { _marker : PhantomData < * const () > } unsafe impl Send for OPA1 { } impl OPA1 { # [doc = r"Pointer to the register block"] pub const PTR : * const opa1 :: RegisterBlock = 0x4002_2000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const opa1 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for OPA1 { type Target = opa1 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for OPA1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("OPA1") . finish () } } # [doc = "PERIPHERALREGION"] pub mod opa1 ; # [doc = "PERIPHERALREGION"] pub struct I2C1 { _marker : PhantomData < * const () > } unsafe impl Send for I2C1 { } impl I2C1 { # [doc = r"Pointer to the register block"] pub const PTR : * const i2c1 :: RegisterBlock = 0x400f_2000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const i2c1 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for I2C1 { type Target = i2c1 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for I2C1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("I2C1") . finish () } } # [doc = "PERIPHERALREGION"] pub mod i2c1 ; # [doc = "PERIPHERALREGION"] pub struct IOMUX { _marker : PhantomData < * const () > } unsafe impl Send for IOMUX { } impl IOMUX { # [doc = r"Pointer to the register block"] pub const PTR : * const iomux :: RegisterBlock = 0x4042_8000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const iomux :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for IOMUX { type Target = iomux :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for IOMUX { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("IOMUX") . finish () } } # [doc = "PERIPHERALREGION"] pub mod iomux ; # [doc = "PERIPHERALREGION"] pub struct TIMG2 { _marker : PhantomData < * const () > } unsafe impl Send for TIMG2 { } impl TIMG2 { # [doc = r"Pointer to the register block"] pub const PTR : * const timg2 :: RegisterBlock = 0x4008_8000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const timg2 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for TIMG2 { type Target = timg2 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIMG2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIMG2") . finish () } } # [doc = "PERIPHERALREGION"] pub mod timg2 ; # [doc = "PERIPHERALREGION"] pub struct TIMG4 { _marker : PhantomData < * const () > } unsafe impl Send for TIMG4 { } impl TIMG4 { # [doc = r"Pointer to the register block"] pub const PTR : * const timg4 :: RegisterBlock = 0x4008_c000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const timg4 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for TIMG4 { type Target = timg4 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIMG4 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIMG4") . finish () } } # [doc = "PERIPHERALREGION"] pub mod timg4 ; # [doc = "PERIPHERALREGION"] pub struct ADC0 { _marker : PhantomData < * const () > } unsafe impl Send for ADC0 { } impl ADC0 { # [doc = r"Pointer to the register block"] pub const PTR : * const adc0 :: RegisterBlock = 0x4000_4000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const adc0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for ADC0 { type Target = adc0 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for ADC0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("ADC0") . finish () } } # [doc = "PERIPHERALREGION"] pub mod adc0 ; # [doc = "PERIPHERALREGIONSVT"] pub struct ADC0_SVT { _marker : PhantomData < * const () > } unsafe impl Send for ADC0_SVT { } impl ADC0_SVT { # [doc = r"Pointer to the register block"] pub const PTR : * const adc0_svt :: RegisterBlock = 0x4055_a000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const adc0_svt :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for ADC0_SVT { type Target = adc0_svt :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for ADC0_SVT { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("ADC0_SVT") . finish () } } # [doc = "PERIPHERALREGIONSVT"] pub mod adc0_svt ; # [doc = "PERIPHERALREGION"] pub struct WUC { _marker : PhantomData < * const () > } unsafe impl Send for WUC { } impl WUC { # [doc = r"Pointer to the register block"] pub const PTR : * const wuc :: RegisterBlock = 0x4042_4000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const wuc :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for WUC { type Target = wuc :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for WUC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("WUC") . finish () } } # [doc = "PERIPHERALREGION"] pub mod wuc ; # [doc = "PERIPHERALREGION"] pub struct TIMG0 { _marker : PhantomData < * const () > } unsafe impl Send for TIMG0 { } impl TIMG0 { # [doc = r"Pointer to the register block"] pub const PTR : * const timg0 :: RegisterBlock = 0x4008_4000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const timg0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for TIMG0 { type Target = timg0 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIMG0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIMG0") . finish () } } # [doc = "PERIPHERALREGION"] pub mod timg0 ; # [no_mangle] static mut DEVICE_PERIPHERALS : bool = false ; # [doc = r" All the peripherals."] # [allow (non_snake_case)] pub struct Peripherals { # [doc = "UART0"] pub UART0 : UART0 , # [doc = "FLASHCTL"] pub FLASHCTL : FLASHCTL , # [doc = "SPI0"] pub SPI0 : SPI0 , # [doc = "I2C0"] pub I2C0 : I2C0 , # [doc = "CPUSS"] pub CPUSS : CPUSS , # [doc = "GPIOA"] pub GPIOA : GPIOA , # [doc = "UART1"] pub UART1 : UART1 , # [doc = "WWDT0"] pub WWDT0 : WWDT0 , # [doc = "DEBUGSS"] pub DEBUGSS : DEBUGSS , # [doc = "VREF"] pub VREF : VREF , # [doc = "CRC"] pub CRC : CRC , # [doc = "OPA0"] pub OPA0 : OPA0 , # [doc = "TIMG1"] pub TIMG1 : TIMG1 , # [doc = "DMA"] pub DMA : DMA , # [doc = "COMP0"] pub COMP0 : COMP0 , # [doc = "SYSCTL"] pub SYSCTL : SYSCTL , # [doc = "OPA1"] pub OPA1 : OPA1 , # [doc = "I2C1"] pub I2C1 : I2C1 , # [doc = "IOMUX"] pub IOMUX : IOMUX , # [doc = "TIMG2"] pub TIMG2 : TIMG2 , # [doc = "TIMG4"] pub TIMG4 : TIMG4 , # [doc = "ADC0"] pub ADC0 : ADC0 , # [doc = "ADC0_SVT"] pub ADC0_SVT : ADC0_SVT , # [doc = "WUC"] pub WUC : WUC , # [doc = "TIMG0"] pub TIMG0 : TIMG0 , } impl Peripherals { # [doc = r" Returns all the peripherals *once*."] # [cfg (feature = "critical-section")] # [inline] pub fn take () -> Option < Self > { critical_section :: with (| _ | { if unsafe { DEVICE_PERIPHERALS } { return None } Some (unsafe { Peripherals :: steal () }) }) } # [doc = r" Unchecked version of `Peripherals::take`."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Each of the returned peripherals must be used at most once."] # [inline] pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { UART0 : UART0 { _marker : PhantomData } , FLASHCTL : FLASHCTL { _marker : PhantomData } , SPI0 : SPI0 { _marker : PhantomData } , I2C0 : I2C0 { _marker : PhantomData } , CPUSS : CPUSS { _marker : PhantomData } , GPIOA : GPIOA { _marker : PhantomData } , UART1 : UART1 { _marker : PhantomData } , WWDT0 : WWDT0 { _marker : PhantomData } , DEBUGSS : DEBUGSS { _marker : PhantomData } , VREF : VREF { _marker : PhantomData } , CRC : CRC { _marker : PhantomData } , OPA0 : OPA0 { _marker : PhantomData } , TIMG1 : TIMG1 { _marker : PhantomData } , DMA : DMA { _marker : PhantomData } , COMP0 : COMP0 { _marker : PhantomData } , SYSCTL : SYSCTL { _marker : PhantomData } , OPA1 : OPA1 { _marker : PhantomData } , I2C1 : I2C1 { _marker : PhantomData } , IOMUX : IOMUX { _marker : PhantomData } , TIMG2 : TIMG2 { _marker : PhantomData } , TIMG4 : TIMG4 { _marker : PhantomData } , ADC0 : ADC0 { _marker : PhantomData } , ADC0_SVT : ADC0_SVT { _marker : PhantomData } , WUC : WUC { _marker : PhantomData } , TIMG0 : TIMG0 { _marker : PhantomData } , } } }