# [doc = "Register `RIS` reader"] pub type R = crate :: R < RIS_SPEC > ; # [doc = "Field `RIS_DMACH0` reader - DMA Channel 0 interrupt signals that size counter reached zero (DMASZ=0)."] pub type RIS_DMACH0_R = crate :: BitReader < RIS_DMACH0_A > ; # [doc = "DMA Channel 0 interrupt signals that size counter reached zero (DMASZ=0).\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum RIS_DMACH0_A { # [doc = "0: CLR"] RIS_DMACH0_CLR = 0 , # [doc = "1: SET"] RIS_DMACH0_SET = 1 , } impl From < RIS_DMACH0_A > for bool { # [inline (always)] fn from (variant : RIS_DMACH0_A) -> Self { variant as u8 != 0 } } impl RIS_DMACH0_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> RIS_DMACH0_A { match self . bits { false => RIS_DMACH0_A :: RIS_DMACH0_CLR , true => RIS_DMACH0_A :: RIS_DMACH0_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_ris_dmach0_clr (& self) -> bool { * self == RIS_DMACH0_A :: RIS_DMACH0_CLR } # [doc = "SET"] # [inline (always)] pub fn is_ris_dmach0_set (& self) -> bool { * self == RIS_DMACH0_A :: RIS_DMACH0_SET } } # [doc = "Field `RIS_DMACH1` reader - DMA Channel 1 interrupt signals that size counter reached zero (DMASZ=0)."] pub type RIS_DMACH1_R = crate :: BitReader < RIS_DMACH1_A > ; # [doc = "DMA Channel 1 interrupt signals that size counter reached zero (DMASZ=0).\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum RIS_DMACH1_A { # [doc = "0: CLR"] RIS_DMACH1_CLR = 0 , # [doc = "1: SET"] RIS_DMACH1_SET = 1 , } impl From < RIS_DMACH1_A > for bool { # [inline (always)] fn from (variant : RIS_DMACH1_A) -> Self { variant as u8 != 0 } } impl RIS_DMACH1_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> RIS_DMACH1_A { match self . bits { false => RIS_DMACH1_A :: RIS_DMACH1_CLR , true => RIS_DMACH1_A :: RIS_DMACH1_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_ris_dmach1_clr (& self) -> bool { * self == RIS_DMACH1_A :: RIS_DMACH1_CLR } # [doc = "SET"] # [inline (always)] pub fn is_ris_dmach1_set (& self) -> bool { * self == RIS_DMACH1_A :: RIS_DMACH1_SET } } # [doc = "Field `RIS_DMACH2` reader - DMA Channel 2 interrupt signals that size counter reached zero (DMASZ=0)."] pub type RIS_DMACH2_R = crate :: BitReader < RIS_DMACH2_A > ; # [doc = "DMA Channel 2 interrupt signals that size counter reached zero (DMASZ=0).\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum RIS_DMACH2_A { # [doc = "0: CLR"] RIS_DMACH2_CLR = 0 , # [doc = "1: SET"] RIS_DMACH2_SET = 1 , } impl From < RIS_DMACH2_A > for bool { # [inline (always)] fn from (variant : RIS_DMACH2_A) -> Self { variant as u8 != 0 } } impl RIS_DMACH2_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> RIS_DMACH2_A { match self . bits { false => RIS_DMACH2_A :: RIS_DMACH2_CLR , true => RIS_DMACH2_A :: RIS_DMACH2_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_ris_dmach2_clr (& self) -> bool { * self == RIS_DMACH2_A :: RIS_DMACH2_CLR } # [doc = "SET"] # [inline (always)] pub fn is_ris_dmach2_set (& self) -> bool { * self == RIS_DMACH2_A :: RIS_DMACH2_SET } } # [doc = "Field `RIS_PREIRQCH0` reader - Pre-IRQ for Channel 0. Size counter reached Pre-IRQ threshold."] pub type RIS_PREIRQCH0_R = crate :: BitReader < RIS_PREIRQCH0_A > ; # [doc = "Pre-IRQ for Channel 0. Size counter reached Pre-IRQ threshold.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum RIS_PREIRQCH0_A { # [doc = "0: CLR"] RIS_PREIRQCH0_CLR = 0 , # [doc = "1: SET"] RIS_PREIRQCH0_SET = 1 , } impl From < RIS_PREIRQCH0_A > for bool { # [inline (always)] fn from (variant : RIS_PREIRQCH0_A) -> Self { variant as u8 != 0 } } impl RIS_PREIRQCH0_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> RIS_PREIRQCH0_A { match self . bits { false => RIS_PREIRQCH0_A :: RIS_PREIRQCH0_CLR , true => RIS_PREIRQCH0_A :: RIS_PREIRQCH0_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_ris_preirqch0_clr (& self) -> bool { * self == RIS_PREIRQCH0_A :: RIS_PREIRQCH0_CLR } # [doc = "SET"] # [inline (always)] pub fn is_ris_preirqch0_set (& self) -> bool { * self == RIS_PREIRQCH0_A :: RIS_PREIRQCH0_SET } } # [doc = "Field `RIS_ADDRERR` reader - DMA address error, SRC address not reachable."] pub type RIS_ADDRERR_R = crate :: BitReader < RIS_ADDRERR_A > ; # [doc = "DMA address error, SRC address not reachable.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum RIS_ADDRERR_A { # [doc = "0: CLR"] RIS_ADDRERR_CLR = 0 , # [doc = "1: SET"] RIS_ADDRERR_SET = 1 , } impl From < RIS_ADDRERR_A > for bool { # [inline (always)] fn from (variant : RIS_ADDRERR_A) -> Self { variant as u8 != 0 } } impl RIS_ADDRERR_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> RIS_ADDRERR_A { match self . bits { false => RIS_ADDRERR_A :: RIS_ADDRERR_CLR , true => RIS_ADDRERR_A :: RIS_ADDRERR_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_ris_addrerr_clr (& self) -> bool { * self == RIS_ADDRERR_A :: RIS_ADDRERR_CLR } # [doc = "SET"] # [inline (always)] pub fn is_ris_addrerr_set (& self) -> bool { * self == RIS_ADDRERR_A :: RIS_ADDRERR_SET } } # [doc = "Field `RIS_DATAERR` reader - DMA data error, SRC data might be corrupted (PAR or ECC error)."] pub type RIS_DATAERR_R = crate :: BitReader < RIS_DATAERR_A > ; # [doc = "DMA data error, SRC data might be corrupted (PAR or ECC error).\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum RIS_DATAERR_A { # [doc = "0: CLR"] RIS_DATAERR_CLR = 0 , # [doc = "1: SET"] RIS_DATAERR_SET = 1 , } impl From < RIS_DATAERR_A > for bool { # [inline (always)] fn from (variant : RIS_DATAERR_A) -> Self { variant as u8 != 0 } } impl RIS_DATAERR_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> RIS_DATAERR_A { match self . bits { false => RIS_DATAERR_A :: RIS_DATAERR_CLR , true => RIS_DATAERR_A :: RIS_DATAERR_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_ris_dataerr_clr (& self) -> bool { * self == RIS_DATAERR_A :: RIS_DATAERR_CLR } # [doc = "SET"] # [inline (always)] pub fn is_ris_dataerr_set (& self) -> bool { * self == RIS_DATAERR_A :: RIS_DATAERR_SET } } impl R { # [doc = "Bit 0 - DMA Channel 0 interrupt signals that size counter reached zero (DMASZ=0)."] # [inline (always)] pub fn ris_dmach0 (& self) -> RIS_DMACH0_R { RIS_DMACH0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - DMA Channel 1 interrupt signals that size counter reached zero (DMASZ=0)."] # [inline (always)] pub fn ris_dmach1 (& self) -> RIS_DMACH1_R { RIS_DMACH1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - DMA Channel 2 interrupt signals that size counter reached zero (DMASZ=0)."] # [inline (always)] pub fn ris_dmach2 (& self) -> RIS_DMACH2_R { RIS_DMACH2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 16 - Pre-IRQ for Channel 0. Size counter reached Pre-IRQ threshold."] # [inline (always)] pub fn ris_preirqch0 (& self) -> RIS_PREIRQCH0_R { RIS_PREIRQCH0_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 24 - DMA address error, SRC address not reachable."] # [inline (always)] pub fn ris_addrerr (& self) -> RIS_ADDRERR_R { RIS_ADDRERR_R :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 25 - DMA data error, SRC data might be corrupted (PAR or ECC error)."] # [inline (always)] pub fn ris_dataerr (& self) -> RIS_DATAERR_R { RIS_DATAERR_R :: new (((self . bits >> 25) & 1) != 0) } } # [doc = "Raw interrupt status\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ris::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RIS_SPEC ; impl crate :: RegisterSpec for RIS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`ris::R`](R) reader structure"] impl crate :: Readable for RIS_SPEC { } # [doc = "`reset()` method sets RIS to value 0"] impl crate :: Resettable for RIS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }