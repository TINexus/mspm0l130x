# [doc = "Register `DMACTL` reader"] pub type R = crate :: R < DMACTL_SPEC > ; # [doc = "Register `DMACTL` writer"] pub type W = crate :: W < DMACTL_SPEC > ; # [doc = "Field `DMACTL_DMAREQ` reader - DMA request. Software-controlled DMA start. DMAREQ is reset automatically."] pub type DMACTL_DMAREQ_R = crate :: BitReader < DMACTL_DMAREQ_A > ; # [doc = "DMA request. Software-controlled DMA start. DMAREQ is reset automatically.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum DMACTL_DMAREQ_A { # [doc = "0: IDLE"] DMACTL_DMAREQ_IDLE = 0 , # [doc = "1: REQUEST"] DMACTL_DMAREQ_REQUEST = 1 , } impl From < DMACTL_DMAREQ_A > for bool { # [inline (always)] fn from (variant : DMACTL_DMAREQ_A) -> Self { variant as u8 != 0 } } impl DMACTL_DMAREQ_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> DMACTL_DMAREQ_A { match self . bits { false => DMACTL_DMAREQ_A :: DMACTL_DMAREQ_IDLE , true => DMACTL_DMAREQ_A :: DMACTL_DMAREQ_REQUEST , } } # [doc = "IDLE"] # [inline (always)] pub fn is_dmactl_dmareq_idle (& self) -> bool { * self == DMACTL_DMAREQ_A :: DMACTL_DMAREQ_IDLE } # [doc = "REQUEST"] # [inline (always)] pub fn is_dmactl_dmareq_request (& self) -> bool { * self == DMACTL_DMAREQ_A :: DMACTL_DMAREQ_REQUEST } } # [doc = "Field `DMACTL_DMAREQ` writer - DMA request. Software-controlled DMA start. DMAREQ is reset automatically."] pub type DMACTL_DMAREQ_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , DMACTL_DMAREQ_A > ; impl < 'a , REG , const O : u8 > DMACTL_DMAREQ_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "IDLE"] # [inline (always)] pub fn dmactl_dmareq_idle (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMAREQ_A :: DMACTL_DMAREQ_IDLE) } # [doc = "REQUEST"] # [inline (always)] pub fn dmactl_dmareq_request (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMAREQ_A :: DMACTL_DMAREQ_REQUEST) } } # [doc = "Field `DMACTL_DMAEN` reader - DMA enable"] pub type DMACTL_DMAEN_R = crate :: BitReader < DMACTL_DMAEN_A > ; # [doc = "DMA enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum DMACTL_DMAEN_A { # [doc = "0: DISABLE"] DMACTL_DMAEN_DISABLE = 0 , # [doc = "1: ENABLE"] DMACTL_DMAEN_ENABLE = 1 , } impl From < DMACTL_DMAEN_A > for bool { # [inline (always)] fn from (variant : DMACTL_DMAEN_A) -> Self { variant as u8 != 0 } } impl DMACTL_DMAEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> DMACTL_DMAEN_A { match self . bits { false => DMACTL_DMAEN_A :: DMACTL_DMAEN_DISABLE , true => DMACTL_DMAEN_A :: DMACTL_DMAEN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_dmactl_dmaen_disable (& self) -> bool { * self == DMACTL_DMAEN_A :: DMACTL_DMAEN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_dmactl_dmaen_enable (& self) -> bool { * self == DMACTL_DMAEN_A :: DMACTL_DMAEN_ENABLE } } # [doc = "Field `DMACTL_DMAEN` writer - DMA enable"] pub type DMACTL_DMAEN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , DMACTL_DMAEN_A > ; impl < 'a , REG , const O : u8 > DMACTL_DMAEN_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn dmactl_dmaen_disable (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMAEN_A :: DMACTL_DMAEN_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn dmactl_dmaen_enable (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMAEN_A :: DMACTL_DMAEN_ENABLE) } } # [doc = "Field `DMACTL_DMAPREIRQ` reader - Enable an early IRQ event. This can help software to react quicker to and DMA done event or allows some additional configuration before the channel is complete. Note: This register is only available in a FULL-channel configuration. Please consult the datasheet of the specific device to map which channel number has FULL or BASIC capability. In a BASIC configuration this register is a read only value and always reads as 0x0."] pub type DMACTL_DMAPREIRQ_R = crate :: FieldReader < DMACTL_DMAPREIRQ_A > ; # [doc = "Enable an early IRQ event. This can help software to react quicker to and DMA done event or allows some additional configuration before the channel is complete. Note: This register is only available in a FULL-channel configuration. Please consult the datasheet of the specific device to map which channel number has FULL or BASIC capability. In a BASIC configuration this register is a read only value and always reads as 0x0.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum DMACTL_DMAPREIRQ_A { # [doc = "0: PREIRQ_DISABLE"] DMACTL_DMAPREIRQ_PREIRQ_DISABLE = 0 , # [doc = "1: PREIRQ_1"] DMACTL_DMAPREIRQ_PREIRQ_1 = 1 , # [doc = "2: PREIRQ_2"] DMACTL_DMAPREIRQ_PREIRQ_2 = 2 , # [doc = "3: PREIRQ_4"] DMACTL_DMAPREIRQ_PREIRQ_4 = 3 , # [doc = "4: PREIRQ_8"] DMACTL_DMAPREIRQ_PREIRQ_8 = 4 , # [doc = "5: PREIRQ_32"] DMACTL_DMAPREIRQ_PREIRQ_32 = 5 , # [doc = "6: PREIRQ_64"] DMACTL_DMAPREIRQ_PREIRQ_64 = 6 , # [doc = "7: PREIRQ_HALF"] DMACTL_DMAPREIRQ_PREIRQ_HALF = 7 , } impl From < DMACTL_DMAPREIRQ_A > for u8 { # [inline (always)] fn from (variant : DMACTL_DMAPREIRQ_A) -> Self { variant as _ } } impl crate :: FieldSpec for DMACTL_DMAPREIRQ_A { type Ux = u8 ; } impl DMACTL_DMAPREIRQ_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> DMACTL_DMAPREIRQ_A { match self . bits { 0 => DMACTL_DMAPREIRQ_A :: DMACTL_DMAPREIRQ_PREIRQ_DISABLE , 1 => DMACTL_DMAPREIRQ_A :: DMACTL_DMAPREIRQ_PREIRQ_1 , 2 => DMACTL_DMAPREIRQ_A :: DMACTL_DMAPREIRQ_PREIRQ_2 , 3 => DMACTL_DMAPREIRQ_A :: DMACTL_DMAPREIRQ_PREIRQ_4 , 4 => DMACTL_DMAPREIRQ_A :: DMACTL_DMAPREIRQ_PREIRQ_8 , 5 => DMACTL_DMAPREIRQ_A :: DMACTL_DMAPREIRQ_PREIRQ_32 , 6 => DMACTL_DMAPREIRQ_A :: DMACTL_DMAPREIRQ_PREIRQ_64 , 7 => DMACTL_DMAPREIRQ_A :: DMACTL_DMAPREIRQ_PREIRQ_HALF , _ => unreachable ! () , } } # [doc = "PREIRQ_DISABLE"] # [inline (always)] pub fn is_dmactl_dmapreirq_preirq_disable (& self) -> bool { * self == DMACTL_DMAPREIRQ_A :: DMACTL_DMAPREIRQ_PREIRQ_DISABLE } # [doc = "PREIRQ_1"] # [inline (always)] pub fn is_dmactl_dmapreirq_preirq_1 (& self) -> bool { * self == DMACTL_DMAPREIRQ_A :: DMACTL_DMAPREIRQ_PREIRQ_1 } # [doc = "PREIRQ_2"] # [inline (always)] pub fn is_dmactl_dmapreirq_preirq_2 (& self) -> bool { * self == DMACTL_DMAPREIRQ_A :: DMACTL_DMAPREIRQ_PREIRQ_2 } # [doc = "PREIRQ_4"] # [inline (always)] pub fn is_dmactl_dmapreirq_preirq_4 (& self) -> bool { * self == DMACTL_DMAPREIRQ_A :: DMACTL_DMAPREIRQ_PREIRQ_4 } # [doc = "PREIRQ_8"] # [inline (always)] pub fn is_dmactl_dmapreirq_preirq_8 (& self) -> bool { * self == DMACTL_DMAPREIRQ_A :: DMACTL_DMAPREIRQ_PREIRQ_8 } # [doc = "PREIRQ_32"] # [inline (always)] pub fn is_dmactl_dmapreirq_preirq_32 (& self) -> bool { * self == DMACTL_DMAPREIRQ_A :: DMACTL_DMAPREIRQ_PREIRQ_32 } # [doc = "PREIRQ_64"] # [inline (always)] pub fn is_dmactl_dmapreirq_preirq_64 (& self) -> bool { * self == DMACTL_DMAPREIRQ_A :: DMACTL_DMAPREIRQ_PREIRQ_64 } # [doc = "PREIRQ_HALF"] # [inline (always)] pub fn is_dmactl_dmapreirq_preirq_half (& self) -> bool { * self == DMACTL_DMAPREIRQ_A :: DMACTL_DMAPREIRQ_PREIRQ_HALF } } # [doc = "Field `DMACTL_DMAPREIRQ` writer - Enable an early IRQ event. This can help software to react quicker to and DMA done event or allows some additional configuration before the channel is complete. Note: This register is only available in a FULL-channel configuration. Please consult the datasheet of the specific device to map which channel number has FULL or BASIC capability. In a BASIC configuration this register is a read only value and always reads as 0x0."] pub type DMACTL_DMAPREIRQ_W < 'a , REG , const O : u8 > = crate :: FieldWriterSafe < 'a , REG , 3 , O , DMACTL_DMAPREIRQ_A > ; impl < 'a , REG , const O : u8 > DMACTL_DMAPREIRQ_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "PREIRQ_DISABLE"] # [inline (always)] pub fn dmactl_dmapreirq_preirq_disable (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMAPREIRQ_A :: DMACTL_DMAPREIRQ_PREIRQ_DISABLE) } # [doc = "PREIRQ_1"] # [inline (always)] pub fn dmactl_dmapreirq_preirq_1 (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMAPREIRQ_A :: DMACTL_DMAPREIRQ_PREIRQ_1) } # [doc = "PREIRQ_2"] # [inline (always)] pub fn dmactl_dmapreirq_preirq_2 (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMAPREIRQ_A :: DMACTL_DMAPREIRQ_PREIRQ_2) } # [doc = "PREIRQ_4"] # [inline (always)] pub fn dmactl_dmapreirq_preirq_4 (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMAPREIRQ_A :: DMACTL_DMAPREIRQ_PREIRQ_4) } # [doc = "PREIRQ_8"] # [inline (always)] pub fn dmactl_dmapreirq_preirq_8 (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMAPREIRQ_A :: DMACTL_DMAPREIRQ_PREIRQ_8) } # [doc = "PREIRQ_32"] # [inline (always)] pub fn dmactl_dmapreirq_preirq_32 (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMAPREIRQ_A :: DMACTL_DMAPREIRQ_PREIRQ_32) } # [doc = "PREIRQ_64"] # [inline (always)] pub fn dmactl_dmapreirq_preirq_64 (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMAPREIRQ_A :: DMACTL_DMAPREIRQ_PREIRQ_64) } # [doc = "PREIRQ_HALF"] # [inline (always)] pub fn dmactl_dmapreirq_preirq_half (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMAPREIRQ_A :: DMACTL_DMAPREIRQ_PREIRQ_HALF) } } # [doc = "Field `DMACTL_DMASRCWDTH` reader - DMA source width. This bit selects the source data width as a byte, half word, word or long word."] pub type DMACTL_DMASRCWDTH_R = crate :: FieldReader < DMACTL_DMASRCWDTH_A > ; # [doc = "DMA source width. This bit selects the source data width as a byte, half word, word or long word.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum DMACTL_DMASRCWDTH_A { # [doc = "0: BYTE"] DMACTL_DMASRCWDTH_BYTE = 0 , # [doc = "1: HALF"] DMACTL_DMASRCWDTH_HALF = 1 , # [doc = "2: WORD"] DMACTL_DMASRCWDTH_WORD = 2 , # [doc = "3: LONG"] DMACTL_DMASRCWDTH_LONG = 3 , } impl From < DMACTL_DMASRCWDTH_A > for u8 { # [inline (always)] fn from (variant : DMACTL_DMASRCWDTH_A) -> Self { variant as _ } } impl crate :: FieldSpec for DMACTL_DMASRCWDTH_A { type Ux = u8 ; } impl DMACTL_DMASRCWDTH_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> DMACTL_DMASRCWDTH_A { match self . bits { 0 => DMACTL_DMASRCWDTH_A :: DMACTL_DMASRCWDTH_BYTE , 1 => DMACTL_DMASRCWDTH_A :: DMACTL_DMASRCWDTH_HALF , 2 => DMACTL_DMASRCWDTH_A :: DMACTL_DMASRCWDTH_WORD , 3 => DMACTL_DMASRCWDTH_A :: DMACTL_DMASRCWDTH_LONG , _ => unreachable ! () , } } # [doc = "BYTE"] # [inline (always)] pub fn is_dmactl_dmasrcwdth_byte (& self) -> bool { * self == DMACTL_DMASRCWDTH_A :: DMACTL_DMASRCWDTH_BYTE } # [doc = "HALF"] # [inline (always)] pub fn is_dmactl_dmasrcwdth_half (& self) -> bool { * self == DMACTL_DMASRCWDTH_A :: DMACTL_DMASRCWDTH_HALF } # [doc = "WORD"] # [inline (always)] pub fn is_dmactl_dmasrcwdth_word (& self) -> bool { * self == DMACTL_DMASRCWDTH_A :: DMACTL_DMASRCWDTH_WORD } # [doc = "LONG"] # [inline (always)] pub fn is_dmactl_dmasrcwdth_long (& self) -> bool { * self == DMACTL_DMASRCWDTH_A :: DMACTL_DMASRCWDTH_LONG } } # [doc = "Field `DMACTL_DMASRCWDTH` writer - DMA source width. This bit selects the source data width as a byte, half word, word or long word."] pub type DMACTL_DMASRCWDTH_W < 'a , REG , const O : u8 > = crate :: FieldWriterSafe < 'a , REG , 2 , O , DMACTL_DMASRCWDTH_A > ; impl < 'a , REG , const O : u8 > DMACTL_DMASRCWDTH_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "BYTE"] # [inline (always)] pub fn dmactl_dmasrcwdth_byte (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMASRCWDTH_A :: DMACTL_DMASRCWDTH_BYTE) } # [doc = "HALF"] # [inline (always)] pub fn dmactl_dmasrcwdth_half (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMASRCWDTH_A :: DMACTL_DMASRCWDTH_HALF) } # [doc = "WORD"] # [inline (always)] pub fn dmactl_dmasrcwdth_word (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMASRCWDTH_A :: DMACTL_DMASRCWDTH_WORD) } # [doc = "LONG"] # [inline (always)] pub fn dmactl_dmasrcwdth_long (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMASRCWDTH_A :: DMACTL_DMASRCWDTH_LONG) } } # [doc = "Field `DMACTL_DMADSTWDTH` reader - DMA destination width. This bit selects the destination as a byte, half word, word or long word."] pub type DMACTL_DMADSTWDTH_R = crate :: FieldReader < DMACTL_DMADSTWDTH_A > ; # [doc = "DMA destination width. This bit selects the destination as a byte, half word, word or long word.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum DMACTL_DMADSTWDTH_A { # [doc = "0: BYTE"] DMACTL_DMADSTWDTH_BYTE = 0 , # [doc = "1: HALF"] DMACTL_DMADSTWDTH_HALF = 1 , # [doc = "2: WORD"] DMACTL_DMADSTWDTH_WORD = 2 , # [doc = "3: LONG"] DMACTL_DMADSTWDTH_LONG = 3 , } impl From < DMACTL_DMADSTWDTH_A > for u8 { # [inline (always)] fn from (variant : DMACTL_DMADSTWDTH_A) -> Self { variant as _ } } impl crate :: FieldSpec for DMACTL_DMADSTWDTH_A { type Ux = u8 ; } impl DMACTL_DMADSTWDTH_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> DMACTL_DMADSTWDTH_A { match self . bits { 0 => DMACTL_DMADSTWDTH_A :: DMACTL_DMADSTWDTH_BYTE , 1 => DMACTL_DMADSTWDTH_A :: DMACTL_DMADSTWDTH_HALF , 2 => DMACTL_DMADSTWDTH_A :: DMACTL_DMADSTWDTH_WORD , 3 => DMACTL_DMADSTWDTH_A :: DMACTL_DMADSTWDTH_LONG , _ => unreachable ! () , } } # [doc = "BYTE"] # [inline (always)] pub fn is_dmactl_dmadstwdth_byte (& self) -> bool { * self == DMACTL_DMADSTWDTH_A :: DMACTL_DMADSTWDTH_BYTE } # [doc = "HALF"] # [inline (always)] pub fn is_dmactl_dmadstwdth_half (& self) -> bool { * self == DMACTL_DMADSTWDTH_A :: DMACTL_DMADSTWDTH_HALF } # [doc = "WORD"] # [inline (always)] pub fn is_dmactl_dmadstwdth_word (& self) -> bool { * self == DMACTL_DMADSTWDTH_A :: DMACTL_DMADSTWDTH_WORD } # [doc = "LONG"] # [inline (always)] pub fn is_dmactl_dmadstwdth_long (& self) -> bool { * self == DMACTL_DMADSTWDTH_A :: DMACTL_DMADSTWDTH_LONG } } # [doc = "Field `DMACTL_DMADSTWDTH` writer - DMA destination width. This bit selects the destination as a byte, half word, word or long word."] pub type DMACTL_DMADSTWDTH_W < 'a , REG , const O : u8 > = crate :: FieldWriterSafe < 'a , REG , 2 , O , DMACTL_DMADSTWDTH_A > ; impl < 'a , REG , const O : u8 > DMACTL_DMADSTWDTH_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "BYTE"] # [inline (always)] pub fn dmactl_dmadstwdth_byte (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMADSTWDTH_A :: DMACTL_DMADSTWDTH_BYTE) } # [doc = "HALF"] # [inline (always)] pub fn dmactl_dmadstwdth_half (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMADSTWDTH_A :: DMACTL_DMADSTWDTH_HALF) } # [doc = "WORD"] # [inline (always)] pub fn dmactl_dmadstwdth_word (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMADSTWDTH_A :: DMACTL_DMADSTWDTH_WORD) } # [doc = "LONG"] # [inline (always)] pub fn dmactl_dmadstwdth_long (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMADSTWDTH_A :: DMACTL_DMADSTWDTH_LONG) } } # [doc = "Field `DMACTL_DMASRCINCR` reader - DMA source increment. This bit selects automatic incrementing or decrementing of the source address DMASA for each transfer. The amount of change to the DMASA is based on the definitin in the DMASRCWDTH. For example an increment of 1 (+1) on a WORD transfer will increment the DMASA by 4."] pub type DMACTL_DMASRCINCR_R = crate :: FieldReader < DMACTL_DMASRCINCR_A > ; # [doc = "DMA source increment. This bit selects automatic incrementing or decrementing of the source address DMASA for each transfer. The amount of change to the DMASA is based on the definitin in the DMASRCWDTH. For example an increment of 1 (+1) on a WORD transfer will increment the DMASA by 4.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum DMACTL_DMASRCINCR_A { # [doc = "0: UNCHANGED"] DMACTL_DMASRCINCR_UNCHANGED = 0 , # [doc = "2: DECREMENT"] DMACTL_DMASRCINCR_DECREMENT = 2 , # [doc = "3: INCREMENT"] DMACTL_DMASRCINCR_INCREMENT = 3 , # [doc = "8: STRIDE_2"] DMACTL_DMASRCINCR_STRIDE_2 = 8 , # [doc = "9: STRIDE_3"] DMACTL_DMASRCINCR_STRIDE_3 = 9 , # [doc = "10: STRIDE_4"] DMACTL_DMASRCINCR_STRIDE_4 = 10 , # [doc = "11: STRIDE_5"] DMACTL_DMASRCINCR_STRIDE_5 = 11 , # [doc = "12: STRIDE_6"] DMACTL_DMASRCINCR_STRIDE_6 = 12 , # [doc = "13: STRIDE_7"] DMACTL_DMASRCINCR_STRIDE_7 = 13 , # [doc = "14: STRIDE_8"] DMACTL_DMASRCINCR_STRIDE_8 = 14 , # [doc = "15: STRIDE_9"] DMACTL_DMASRCINCR_STRIDE_9 = 15 , } impl From < DMACTL_DMASRCINCR_A > for u8 { # [inline (always)] fn from (variant : DMACTL_DMASRCINCR_A) -> Self { variant as _ } } impl crate :: FieldSpec for DMACTL_DMASRCINCR_A { type Ux = u8 ; } impl DMACTL_DMASRCINCR_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < DMACTL_DMASRCINCR_A > { match self . bits { 0 => Some (DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_UNCHANGED) , 2 => Some (DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_DECREMENT) , 3 => Some (DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_INCREMENT) , 8 => Some (DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_STRIDE_2) , 9 => Some (DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_STRIDE_3) , 10 => Some (DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_STRIDE_4) , 11 => Some (DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_STRIDE_5) , 12 => Some (DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_STRIDE_6) , 13 => Some (DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_STRIDE_7) , 14 => Some (DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_STRIDE_8) , 15 => Some (DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_STRIDE_9) , _ => None , } } # [doc = "UNCHANGED"] # [inline (always)] pub fn is_dmactl_dmasrcincr_unchanged (& self) -> bool { * self == DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_UNCHANGED } # [doc = "DECREMENT"] # [inline (always)] pub fn is_dmactl_dmasrcincr_decrement (& self) -> bool { * self == DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_DECREMENT } # [doc = "INCREMENT"] # [inline (always)] pub fn is_dmactl_dmasrcincr_increment (& self) -> bool { * self == DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_INCREMENT } # [doc = "STRIDE_2"] # [inline (always)] pub fn is_dmactl_dmasrcincr_stride_2 (& self) -> bool { * self == DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_STRIDE_2 } # [doc = "STRIDE_3"] # [inline (always)] pub fn is_dmactl_dmasrcincr_stride_3 (& self) -> bool { * self == DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_STRIDE_3 } # [doc = "STRIDE_4"] # [inline (always)] pub fn is_dmactl_dmasrcincr_stride_4 (& self) -> bool { * self == DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_STRIDE_4 } # [doc = "STRIDE_5"] # [inline (always)] pub fn is_dmactl_dmasrcincr_stride_5 (& self) -> bool { * self == DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_STRIDE_5 } # [doc = "STRIDE_6"] # [inline (always)] pub fn is_dmactl_dmasrcincr_stride_6 (& self) -> bool { * self == DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_STRIDE_6 } # [doc = "STRIDE_7"] # [inline (always)] pub fn is_dmactl_dmasrcincr_stride_7 (& self) -> bool { * self == DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_STRIDE_7 } # [doc = "STRIDE_8"] # [inline (always)] pub fn is_dmactl_dmasrcincr_stride_8 (& self) -> bool { * self == DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_STRIDE_8 } # [doc = "STRIDE_9"] # [inline (always)] pub fn is_dmactl_dmasrcincr_stride_9 (& self) -> bool { * self == DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_STRIDE_9 } } # [doc = "Field `DMACTL_DMASRCINCR` writer - DMA source increment. This bit selects automatic incrementing or decrementing of the source address DMASA for each transfer. The amount of change to the DMASA is based on the definitin in the DMASRCWDTH. For example an increment of 1 (+1) on a WORD transfer will increment the DMASA by 4."] pub type DMACTL_DMASRCINCR_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 4 , O , DMACTL_DMASRCINCR_A > ; impl < 'a , REG , const O : u8 > DMACTL_DMASRCINCR_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "UNCHANGED"] # [inline (always)] pub fn dmactl_dmasrcincr_unchanged (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_UNCHANGED) } # [doc = "DECREMENT"] # [inline (always)] pub fn dmactl_dmasrcincr_decrement (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_DECREMENT) } # [doc = "INCREMENT"] # [inline (always)] pub fn dmactl_dmasrcincr_increment (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_INCREMENT) } # [doc = "STRIDE_2"] # [inline (always)] pub fn dmactl_dmasrcincr_stride_2 (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_STRIDE_2) } # [doc = "STRIDE_3"] # [inline (always)] pub fn dmactl_dmasrcincr_stride_3 (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_STRIDE_3) } # [doc = "STRIDE_4"] # [inline (always)] pub fn dmactl_dmasrcincr_stride_4 (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_STRIDE_4) } # [doc = "STRIDE_5"] # [inline (always)] pub fn dmactl_dmasrcincr_stride_5 (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_STRIDE_5) } # [doc = "STRIDE_6"] # [inline (always)] pub fn dmactl_dmasrcincr_stride_6 (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_STRIDE_6) } # [doc = "STRIDE_7"] # [inline (always)] pub fn dmactl_dmasrcincr_stride_7 (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_STRIDE_7) } # [doc = "STRIDE_8"] # [inline (always)] pub fn dmactl_dmasrcincr_stride_8 (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_STRIDE_8) } # [doc = "STRIDE_9"] # [inline (always)] pub fn dmactl_dmasrcincr_stride_9 (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMASRCINCR_A :: DMACTL_DMASRCINCR_STRIDE_9) } } # [doc = "Field `DMACTL_DMADSTINCR` reader - DMA destination increment. This bit selects automatic incrementing or decrementing of the destination address DMADA for each transfer. The amount of change to the DMADA is based on the definitin in the DMADSTWDTH. For example an increment of 1 (+1) on a WORD transfer will increment the DMADA by 4."] pub type DMACTL_DMADSTINCR_R = crate :: FieldReader < DMACTL_DMADSTINCR_A > ; # [doc = "DMA destination increment. This bit selects automatic incrementing or decrementing of the destination address DMADA for each transfer. The amount of change to the DMADA is based on the definitin in the DMADSTWDTH. For example an increment of 1 (+1) on a WORD transfer will increment the DMADA by 4.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum DMACTL_DMADSTINCR_A { # [doc = "0: UNCHANGED"] DMACTL_DMADSTINCR_UNCHANGED = 0 , # [doc = "2: DECREMENT"] DMACTL_DMADSTINCR_DECREMENT = 2 , # [doc = "3: INCREMENT"] DMACTL_DMADSTINCR_INCREMENT = 3 , # [doc = "8: STRIDE_2"] DMACTL_DMADSTINCR_STRIDE_2 = 8 , # [doc = "9: STRIDE_3"] DMACTL_DMADSTINCR_STRIDE_3 = 9 , # [doc = "10: STRIDE_4"] DMACTL_DMADSTINCR_STRIDE_4 = 10 , # [doc = "11: STRIDE_5"] DMACTL_DMADSTINCR_STRIDE_5 = 11 , # [doc = "12: STRIDE_6"] DMACTL_DMADSTINCR_STRIDE_6 = 12 , # [doc = "13: STRIDE_7"] DMACTL_DMADSTINCR_STRIDE_7 = 13 , # [doc = "14: STRIDE_8"] DMACTL_DMADSTINCR_STRIDE_8 = 14 , # [doc = "15: STRIDE_9"] DMACTL_DMADSTINCR_STRIDE_9 = 15 , } impl From < DMACTL_DMADSTINCR_A > for u8 { # [inline (always)] fn from (variant : DMACTL_DMADSTINCR_A) -> Self { variant as _ } } impl crate :: FieldSpec for DMACTL_DMADSTINCR_A { type Ux = u8 ; } impl DMACTL_DMADSTINCR_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < DMACTL_DMADSTINCR_A > { match self . bits { 0 => Some (DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_UNCHANGED) , 2 => Some (DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_DECREMENT) , 3 => Some (DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_INCREMENT) , 8 => Some (DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_STRIDE_2) , 9 => Some (DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_STRIDE_3) , 10 => Some (DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_STRIDE_4) , 11 => Some (DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_STRIDE_5) , 12 => Some (DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_STRIDE_6) , 13 => Some (DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_STRIDE_7) , 14 => Some (DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_STRIDE_8) , 15 => Some (DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_STRIDE_9) , _ => None , } } # [doc = "UNCHANGED"] # [inline (always)] pub fn is_dmactl_dmadstincr_unchanged (& self) -> bool { * self == DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_UNCHANGED } # [doc = "DECREMENT"] # [inline (always)] pub fn is_dmactl_dmadstincr_decrement (& self) -> bool { * self == DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_DECREMENT } # [doc = "INCREMENT"] # [inline (always)] pub fn is_dmactl_dmadstincr_increment (& self) -> bool { * self == DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_INCREMENT } # [doc = "STRIDE_2"] # [inline (always)] pub fn is_dmactl_dmadstincr_stride_2 (& self) -> bool { * self == DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_STRIDE_2 } # [doc = "STRIDE_3"] # [inline (always)] pub fn is_dmactl_dmadstincr_stride_3 (& self) -> bool { * self == DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_STRIDE_3 } # [doc = "STRIDE_4"] # [inline (always)] pub fn is_dmactl_dmadstincr_stride_4 (& self) -> bool { * self == DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_STRIDE_4 } # [doc = "STRIDE_5"] # [inline (always)] pub fn is_dmactl_dmadstincr_stride_5 (& self) -> bool { * self == DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_STRIDE_5 } # [doc = "STRIDE_6"] # [inline (always)] pub fn is_dmactl_dmadstincr_stride_6 (& self) -> bool { * self == DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_STRIDE_6 } # [doc = "STRIDE_7"] # [inline (always)] pub fn is_dmactl_dmadstincr_stride_7 (& self) -> bool { * self == DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_STRIDE_7 } # [doc = "STRIDE_8"] # [inline (always)] pub fn is_dmactl_dmadstincr_stride_8 (& self) -> bool { * self == DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_STRIDE_8 } # [doc = "STRIDE_9"] # [inline (always)] pub fn is_dmactl_dmadstincr_stride_9 (& self) -> bool { * self == DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_STRIDE_9 } } # [doc = "Field `DMACTL_DMADSTINCR` writer - DMA destination increment. This bit selects automatic incrementing or decrementing of the destination address DMADA for each transfer. The amount of change to the DMADA is based on the definitin in the DMADSTWDTH. For example an increment of 1 (+1) on a WORD transfer will increment the DMADA by 4."] pub type DMACTL_DMADSTINCR_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 4 , O , DMACTL_DMADSTINCR_A > ; impl < 'a , REG , const O : u8 > DMACTL_DMADSTINCR_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "UNCHANGED"] # [inline (always)] pub fn dmactl_dmadstincr_unchanged (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_UNCHANGED) } # [doc = "DECREMENT"] # [inline (always)] pub fn dmactl_dmadstincr_decrement (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_DECREMENT) } # [doc = "INCREMENT"] # [inline (always)] pub fn dmactl_dmadstincr_increment (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_INCREMENT) } # [doc = "STRIDE_2"] # [inline (always)] pub fn dmactl_dmadstincr_stride_2 (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_STRIDE_2) } # [doc = "STRIDE_3"] # [inline (always)] pub fn dmactl_dmadstincr_stride_3 (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_STRIDE_3) } # [doc = "STRIDE_4"] # [inline (always)] pub fn dmactl_dmadstincr_stride_4 (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_STRIDE_4) } # [doc = "STRIDE_5"] # [inline (always)] pub fn dmactl_dmadstincr_stride_5 (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_STRIDE_5) } # [doc = "STRIDE_6"] # [inline (always)] pub fn dmactl_dmadstincr_stride_6 (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_STRIDE_6) } # [doc = "STRIDE_7"] # [inline (always)] pub fn dmactl_dmadstincr_stride_7 (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_STRIDE_7) } # [doc = "STRIDE_8"] # [inline (always)] pub fn dmactl_dmadstincr_stride_8 (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_STRIDE_8) } # [doc = "STRIDE_9"] # [inline (always)] pub fn dmactl_dmadstincr_stride_9 (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMADSTINCR_A :: DMACTL_DMADSTINCR_STRIDE_9) } } # [doc = "Field `DMACTL_DMAEM` reader - DMA extended mode Note: The extended transfer modes are only available in a FULL-channel configuration. Please consult the datasheet of the specific device to map which channel number has FULL or BASIC capability. In a BASIC channel configuration this register is a read-only register and reads 0x0."] pub type DMACTL_DMAEM_R = crate :: FieldReader < DMACTL_DMAEM_A > ; # [doc = "DMA extended mode Note: The extended transfer modes are only available in a FULL-channel configuration. Please consult the datasheet of the specific device to map which channel number has FULL or BASIC capability. In a BASIC channel configuration this register is a read-only register and reads 0x0.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum DMACTL_DMAEM_A { # [doc = "0: NORMAL"] DMACTL_DMAEM_NORMAL = 0 , # [doc = "2: FILLMODE"] DMACTL_DMAEM_FILLMODE = 2 , # [doc = "3: TABLEMODE"] DMACTL_DMAEM_TABLEMODE = 3 , } impl From < DMACTL_DMAEM_A > for u8 { # [inline (always)] fn from (variant : DMACTL_DMAEM_A) -> Self { variant as _ } } impl crate :: FieldSpec for DMACTL_DMAEM_A { type Ux = u8 ; } impl DMACTL_DMAEM_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < DMACTL_DMAEM_A > { match self . bits { 0 => Some (DMACTL_DMAEM_A :: DMACTL_DMAEM_NORMAL) , 2 => Some (DMACTL_DMAEM_A :: DMACTL_DMAEM_FILLMODE) , 3 => Some (DMACTL_DMAEM_A :: DMACTL_DMAEM_TABLEMODE) , _ => None , } } # [doc = "NORMAL"] # [inline (always)] pub fn is_dmactl_dmaem_normal (& self) -> bool { * self == DMACTL_DMAEM_A :: DMACTL_DMAEM_NORMAL } # [doc = "FILLMODE"] # [inline (always)] pub fn is_dmactl_dmaem_fillmode (& self) -> bool { * self == DMACTL_DMAEM_A :: DMACTL_DMAEM_FILLMODE } # [doc = "TABLEMODE"] # [inline (always)] pub fn is_dmactl_dmaem_tablemode (& self) -> bool { * self == DMACTL_DMAEM_A :: DMACTL_DMAEM_TABLEMODE } } # [doc = "Field `DMACTL_DMAEM` writer - DMA extended mode Note: The extended transfer modes are only available in a FULL-channel configuration. Please consult the datasheet of the specific device to map which channel number has FULL or BASIC capability. In a BASIC channel configuration this register is a read-only register and reads 0x0."] pub type DMACTL_DMAEM_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 2 , O , DMACTL_DMAEM_A > ; impl < 'a , REG , const O : u8 > DMACTL_DMAEM_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "NORMAL"] # [inline (always)] pub fn dmactl_dmaem_normal (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMAEM_A :: DMACTL_DMAEM_NORMAL) } # [doc = "FILLMODE"] # [inline (always)] pub fn dmactl_dmaem_fillmode (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMAEM_A :: DMACTL_DMAEM_FILLMODE) } # [doc = "TABLEMODE"] # [inline (always)] pub fn dmactl_dmaem_tablemode (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMAEM_A :: DMACTL_DMAEM_TABLEMODE) } } # [doc = "Field `DMACTL_DMATM` reader - DMA transfer mode register Note: The repeat-single (2h) and repeat-block (3h) transfer are only available in a FULL-channel configuration. Please consult the datasheet of the specific device to map which channel number has FULL or BASIC capability. In a BASIC channel configuration only the values for single (0h) and block (1h) transfer can be set."] pub type DMACTL_DMATM_R = crate :: FieldReader < DMACTL_DMATM_A > ; # [doc = "DMA transfer mode register Note: The repeat-single (2h) and repeat-block (3h) transfer are only available in a FULL-channel configuration. Please consult the datasheet of the specific device to map which channel number has FULL or BASIC capability. In a BASIC channel configuration only the values for single (0h) and block (1h) transfer can be set.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum DMACTL_DMATM_A { # [doc = "0: SINGLE"] DMACTL_DMATM_SINGLE = 0 , # [doc = "1: BLOCK"] DMACTL_DMATM_BLOCK = 1 , # [doc = "2: RPTSNGL"] DMACTL_DMATM_RPTSNGL = 2 , # [doc = "3: RPTBLCK"] DMACTL_DMATM_RPTBLCK = 3 , } impl From < DMACTL_DMATM_A > for u8 { # [inline (always)] fn from (variant : DMACTL_DMATM_A) -> Self { variant as _ } } impl crate :: FieldSpec for DMACTL_DMATM_A { type Ux = u8 ; } impl DMACTL_DMATM_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> DMACTL_DMATM_A { match self . bits { 0 => DMACTL_DMATM_A :: DMACTL_DMATM_SINGLE , 1 => DMACTL_DMATM_A :: DMACTL_DMATM_BLOCK , 2 => DMACTL_DMATM_A :: DMACTL_DMATM_RPTSNGL , 3 => DMACTL_DMATM_A :: DMACTL_DMATM_RPTBLCK , _ => unreachable ! () , } } # [doc = "SINGLE"] # [inline (always)] pub fn is_dmactl_dmatm_single (& self) -> bool { * self == DMACTL_DMATM_A :: DMACTL_DMATM_SINGLE } # [doc = "BLOCK"] # [inline (always)] pub fn is_dmactl_dmatm_block (& self) -> bool { * self == DMACTL_DMATM_A :: DMACTL_DMATM_BLOCK } # [doc = "RPTSNGL"] # [inline (always)] pub fn is_dmactl_dmatm_rptsngl (& self) -> bool { * self == DMACTL_DMATM_A :: DMACTL_DMATM_RPTSNGL } # [doc = "RPTBLCK"] # [inline (always)] pub fn is_dmactl_dmatm_rptblck (& self) -> bool { * self == DMACTL_DMATM_A :: DMACTL_DMATM_RPTBLCK } } # [doc = "Field `DMACTL_DMATM` writer - DMA transfer mode register Note: The repeat-single (2h) and repeat-block (3h) transfer are only available in a FULL-channel configuration. Please consult the datasheet of the specific device to map which channel number has FULL or BASIC capability. In a BASIC channel configuration only the values for single (0h) and block (1h) transfer can be set."] pub type DMACTL_DMATM_W < 'a , REG , const O : u8 > = crate :: FieldWriterSafe < 'a , REG , 2 , O , DMACTL_DMATM_A > ; impl < 'a , REG , const O : u8 > DMACTL_DMATM_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "SINGLE"] # [inline (always)] pub fn dmactl_dmatm_single (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMATM_A :: DMACTL_DMATM_SINGLE) } # [doc = "BLOCK"] # [inline (always)] pub fn dmactl_dmatm_block (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMATM_A :: DMACTL_DMATM_BLOCK) } # [doc = "RPTSNGL"] # [inline (always)] pub fn dmactl_dmatm_rptsngl (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMATM_A :: DMACTL_DMATM_RPTSNGL) } # [doc = "RPTBLCK"] # [inline (always)] pub fn dmactl_dmatm_rptblck (self) -> & 'a mut crate :: W < REG > { self . variant (DMACTL_DMATM_A :: DMACTL_DMATM_RPTBLCK) } } impl R { # [doc = "Bit 0 - DMA request. Software-controlled DMA start. DMAREQ is reset automatically."] # [inline (always)] pub fn dmactl_dmareq (& self) -> DMACTL_DMAREQ_R { DMACTL_DMAREQ_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - DMA enable"] # [inline (always)] pub fn dmactl_dmaen (& self) -> DMACTL_DMAEN_R { DMACTL_DMAEN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 4:6 - Enable an early IRQ event. This can help software to react quicker to and DMA done event or allows some additional configuration before the channel is complete. Note: This register is only available in a FULL-channel configuration. Please consult the datasheet of the specific device to map which channel number has FULL or BASIC capability. In a BASIC configuration this register is a read only value and always reads as 0x0."] # [inline (always)] pub fn dmactl_dmapreirq (& self) -> DMACTL_DMAPREIRQ_R { DMACTL_DMAPREIRQ_R :: new (((self . bits >> 4) & 7) as u8) } # [doc = "Bits 8:9 - DMA source width. This bit selects the source data width as a byte, half word, word or long word."] # [inline (always)] pub fn dmactl_dmasrcwdth (& self) -> DMACTL_DMASRCWDTH_R { DMACTL_DMASRCWDTH_R :: new (((self . bits >> 8) & 3) as u8) } # [doc = "Bits 12:13 - DMA destination width. This bit selects the destination as a byte, half word, word or long word."] # [inline (always)] pub fn dmactl_dmadstwdth (& self) -> DMACTL_DMADSTWDTH_R { DMACTL_DMADSTWDTH_R :: new (((self . bits >> 12) & 3) as u8) } # [doc = "Bits 16:19 - DMA source increment. This bit selects automatic incrementing or decrementing of the source address DMASA for each transfer. The amount of change to the DMASA is based on the definitin in the DMASRCWDTH. For example an increment of 1 (+1) on a WORD transfer will increment the DMASA by 4."] # [inline (always)] pub fn dmactl_dmasrcincr (& self) -> DMACTL_DMASRCINCR_R { DMACTL_DMASRCINCR_R :: new (((self . bits >> 16) & 0x0f) as u8) } # [doc = "Bits 20:23 - DMA destination increment. This bit selects automatic incrementing or decrementing of the destination address DMADA for each transfer. The amount of change to the DMADA is based on the definitin in the DMADSTWDTH. For example an increment of 1 (+1) on a WORD transfer will increment the DMADA by 4."] # [inline (always)] pub fn dmactl_dmadstincr (& self) -> DMACTL_DMADSTINCR_R { DMACTL_DMADSTINCR_R :: new (((self . bits >> 20) & 0x0f) as u8) } # [doc = "Bits 24:25 - DMA extended mode Note: The extended transfer modes are only available in a FULL-channel configuration. Please consult the datasheet of the specific device to map which channel number has FULL or BASIC capability. In a BASIC channel configuration this register is a read-only register and reads 0x0."] # [inline (always)] pub fn dmactl_dmaem (& self) -> DMACTL_DMAEM_R { DMACTL_DMAEM_R :: new (((self . bits >> 24) & 3) as u8) } # [doc = "Bits 28:29 - DMA transfer mode register Note: The repeat-single (2h) and repeat-block (3h) transfer are only available in a FULL-channel configuration. Please consult the datasheet of the specific device to map which channel number has FULL or BASIC capability. In a BASIC channel configuration only the values for single (0h) and block (1h) transfer can be set."] # [inline (always)] pub fn dmactl_dmatm (& self) -> DMACTL_DMATM_R { DMACTL_DMATM_R :: new (((self . bits >> 28) & 3) as u8) } } impl W { # [doc = "Bit 0 - DMA request. Software-controlled DMA start. DMAREQ is reset automatically."] # [inline (always)] # [must_use] pub fn dmactl_dmareq (& mut self) -> DMACTL_DMAREQ_W < DMACTL_SPEC , 0 > { DMACTL_DMAREQ_W :: new (self) } # [doc = "Bit 1 - DMA enable"] # [inline (always)] # [must_use] pub fn dmactl_dmaen (& mut self) -> DMACTL_DMAEN_W < DMACTL_SPEC , 1 > { DMACTL_DMAEN_W :: new (self) } # [doc = "Bits 4:6 - Enable an early IRQ event. This can help software to react quicker to and DMA done event or allows some additional configuration before the channel is complete. Note: This register is only available in a FULL-channel configuration. Please consult the datasheet of the specific device to map which channel number has FULL or BASIC capability. In a BASIC configuration this register is a read only value and always reads as 0x0."] # [inline (always)] # [must_use] pub fn dmactl_dmapreirq (& mut self) -> DMACTL_DMAPREIRQ_W < DMACTL_SPEC , 4 > { DMACTL_DMAPREIRQ_W :: new (self) } # [doc = "Bits 8:9 - DMA source width. This bit selects the source data width as a byte, half word, word or long word."] # [inline (always)] # [must_use] pub fn dmactl_dmasrcwdth (& mut self) -> DMACTL_DMASRCWDTH_W < DMACTL_SPEC , 8 > { DMACTL_DMASRCWDTH_W :: new (self) } # [doc = "Bits 12:13 - DMA destination width. This bit selects the destination as a byte, half word, word or long word."] # [inline (always)] # [must_use] pub fn dmactl_dmadstwdth (& mut self) -> DMACTL_DMADSTWDTH_W < DMACTL_SPEC , 12 > { DMACTL_DMADSTWDTH_W :: new (self) } # [doc = "Bits 16:19 - DMA source increment. This bit selects automatic incrementing or decrementing of the source address DMASA for each transfer. The amount of change to the DMASA is based on the definitin in the DMASRCWDTH. For example an increment of 1 (+1) on a WORD transfer will increment the DMASA by 4."] # [inline (always)] # [must_use] pub fn dmactl_dmasrcincr (& mut self) -> DMACTL_DMASRCINCR_W < DMACTL_SPEC , 16 > { DMACTL_DMASRCINCR_W :: new (self) } # [doc = "Bits 20:23 - DMA destination increment. This bit selects automatic incrementing or decrementing of the destination address DMADA for each transfer. The amount of change to the DMADA is based on the definitin in the DMADSTWDTH. For example an increment of 1 (+1) on a WORD transfer will increment the DMADA by 4."] # [inline (always)] # [must_use] pub fn dmactl_dmadstincr (& mut self) -> DMACTL_DMADSTINCR_W < DMACTL_SPEC , 20 > { DMACTL_DMADSTINCR_W :: new (self) } # [doc = "Bits 24:25 - DMA extended mode Note: The extended transfer modes are only available in a FULL-channel configuration. Please consult the datasheet of the specific device to map which channel number has FULL or BASIC capability. In a BASIC channel configuration this register is a read-only register and reads 0x0."] # [inline (always)] # [must_use] pub fn dmactl_dmaem (& mut self) -> DMACTL_DMAEM_W < DMACTL_SPEC , 24 > { DMACTL_DMAEM_W :: new (self) } # [doc = "Bits 28:29 - DMA transfer mode register Note: The repeat-single (2h) and repeat-block (3h) transfer are only available in a FULL-channel configuration. Please consult the datasheet of the specific device to map which channel number has FULL or BASIC capability. In a BASIC channel configuration only the values for single (0h) and block (1h) transfer can be set."] # [inline (always)] # [must_use] pub fn dmactl_dmatm (& mut self) -> DMACTL_DMATM_W < DMACTL_SPEC , 28 > { DMACTL_DMATM_W :: new (self) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "DMA Channel Control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dmactl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dmactl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DMACTL_SPEC ; impl crate :: RegisterSpec for DMACTL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dmactl::R`](R) reader structure"] impl crate :: Readable for DMACTL_SPEC { } # [doc = "`write(|w| ..)` method takes [`dmactl::W`](W) writer structure"] impl crate :: Writable for DMACTL_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DMACTL to value 0"] impl crate :: Resettable for DMACTL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }