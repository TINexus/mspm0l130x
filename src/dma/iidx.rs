# [doc = "Register `IIDX` reader"] pub type R = crate :: R < IIDX_SPEC > ; # [doc = "Field `IIDX_STAT` reader - Interrupt index status"] pub type IIDX_STAT_R = crate :: FieldReader < IIDX_STAT_A > ; # [doc = "Interrupt index status\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum IIDX_STAT_A { # [doc = "0: NO_INTR"] IIDX_STAT_NO_INTR = 0 , # [doc = "1: DMACH0"] IIDX_STAT_DMACH0 = 1 , # [doc = "2: DMACH1"] IIDX_STAT_DMACH1 = 2 , # [doc = "3: DMACH2"] IIDX_STAT_DMACH2 = 3 , # [doc = "4: DMACH3"] IIDX_STAT_DMACH3 = 4 , # [doc = "5: DMACH4"] IIDX_STAT_DMACH4 = 5 , # [doc = "6: DMACH5"] IIDX_STAT_DMACH5 = 6 , # [doc = "7: DMACH6"] IIDX_STAT_DMACH6 = 7 , # [doc = "8: DMACH7"] IIDX_STAT_DMACH7 = 8 , # [doc = "9: DMACH8"] IIDX_STAT_DMACH8 = 9 , # [doc = "10: DMACH9"] IIDX_STAT_DMACH9 = 10 , # [doc = "11: DMACH10"] IIDX_STAT_DMACH10 = 11 , # [doc = "12: DMACH11"] IIDX_STAT_DMACH11 = 12 , # [doc = "13: DMACH12"] IIDX_STAT_DMACH12 = 13 , # [doc = "14: DMACH13"] IIDX_STAT_DMACH13 = 14 , # [doc = "15: DMACH14"] IIDX_STAT_DMACH14 = 15 , # [doc = "16: DMACH15"] IIDX_STAT_DMACH15 = 16 , # [doc = "17: PREIRQCH0"] IIDX_STAT_PREIRQCH0 = 17 , # [doc = "18: PREIRQCH1"] IIDX_STAT_PREIRQCH1 = 18 , # [doc = "19: PREIRQCH2"] IIDX_STAT_PREIRQCH2 = 19 , # [doc = "20: PREIRQCH3"] IIDX_STAT_PREIRQCH3 = 20 , # [doc = "21: PREIRQCH4"] IIDX_STAT_PREIRQCH4 = 21 , # [doc = "22: PREIRQCH5"] IIDX_STAT_PREIRQCH5 = 22 , # [doc = "23: PREIRQCH6"] IIDX_STAT_PREIRQCH6 = 23 , # [doc = "24: PREIRQCH7"] IIDX_STAT_PREIRQCH7 = 24 , # [doc = "25: ADDRERR"] IIDX_STAT_ADDRERR = 25 , # [doc = "26: DATAERR"] IIDX_STAT_DATAERR = 26 , } impl From < IIDX_STAT_A > for u8 { # [inline (always)] fn from (variant : IIDX_STAT_A) -> Self { variant as _ } } impl crate :: FieldSpec for IIDX_STAT_A { type Ux = u8 ; } impl IIDX_STAT_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < IIDX_STAT_A > { match self . bits { 0 => Some (IIDX_STAT_A :: IIDX_STAT_NO_INTR) , 1 => Some (IIDX_STAT_A :: IIDX_STAT_DMACH0) , 2 => Some (IIDX_STAT_A :: IIDX_STAT_DMACH1) , 3 => Some (IIDX_STAT_A :: IIDX_STAT_DMACH2) , 4 => Some (IIDX_STAT_A :: IIDX_STAT_DMACH3) , 5 => Some (IIDX_STAT_A :: IIDX_STAT_DMACH4) , 6 => Some (IIDX_STAT_A :: IIDX_STAT_DMACH5) , 7 => Some (IIDX_STAT_A :: IIDX_STAT_DMACH6) , 8 => Some (IIDX_STAT_A :: IIDX_STAT_DMACH7) , 9 => Some (IIDX_STAT_A :: IIDX_STAT_DMACH8) , 10 => Some (IIDX_STAT_A :: IIDX_STAT_DMACH9) , 11 => Some (IIDX_STAT_A :: IIDX_STAT_DMACH10) , 12 => Some (IIDX_STAT_A :: IIDX_STAT_DMACH11) , 13 => Some (IIDX_STAT_A :: IIDX_STAT_DMACH12) , 14 => Some (IIDX_STAT_A :: IIDX_STAT_DMACH13) , 15 => Some (IIDX_STAT_A :: IIDX_STAT_DMACH14) , 16 => Some (IIDX_STAT_A :: IIDX_STAT_DMACH15) , 17 => Some (IIDX_STAT_A :: IIDX_STAT_PREIRQCH0) , 18 => Some (IIDX_STAT_A :: IIDX_STAT_PREIRQCH1) , 19 => Some (IIDX_STAT_A :: IIDX_STAT_PREIRQCH2) , 20 => Some (IIDX_STAT_A :: IIDX_STAT_PREIRQCH3) , 21 => Some (IIDX_STAT_A :: IIDX_STAT_PREIRQCH4) , 22 => Some (IIDX_STAT_A :: IIDX_STAT_PREIRQCH5) , 23 => Some (IIDX_STAT_A :: IIDX_STAT_PREIRQCH6) , 24 => Some (IIDX_STAT_A :: IIDX_STAT_PREIRQCH7) , 25 => Some (IIDX_STAT_A :: IIDX_STAT_ADDRERR) , 26 => Some (IIDX_STAT_A :: IIDX_STAT_DATAERR) , _ => None , } } # [doc = "NO_INTR"] # [inline (always)] pub fn is_iidx_stat_no_intr (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_NO_INTR } # [doc = "DMACH0"] # [inline (always)] pub fn is_iidx_stat_dmach0 (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_DMACH0 } # [doc = "DMACH1"] # [inline (always)] pub fn is_iidx_stat_dmach1 (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_DMACH1 } # [doc = "DMACH2"] # [inline (always)] pub fn is_iidx_stat_dmach2 (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_DMACH2 } # [doc = "DMACH3"] # [inline (always)] pub fn is_iidx_stat_dmach3 (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_DMACH3 } # [doc = "DMACH4"] # [inline (always)] pub fn is_iidx_stat_dmach4 (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_DMACH4 } # [doc = "DMACH5"] # [inline (always)] pub fn is_iidx_stat_dmach5 (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_DMACH5 } # [doc = "DMACH6"] # [inline (always)] pub fn is_iidx_stat_dmach6 (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_DMACH6 } # [doc = "DMACH7"] # [inline (always)] pub fn is_iidx_stat_dmach7 (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_DMACH7 } # [doc = "DMACH8"] # [inline (always)] pub fn is_iidx_stat_dmach8 (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_DMACH8 } # [doc = "DMACH9"] # [inline (always)] pub fn is_iidx_stat_dmach9 (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_DMACH9 } # [doc = "DMACH10"] # [inline (always)] pub fn is_iidx_stat_dmach10 (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_DMACH10 } # [doc = "DMACH11"] # [inline (always)] pub fn is_iidx_stat_dmach11 (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_DMACH11 } # [doc = "DMACH12"] # [inline (always)] pub fn is_iidx_stat_dmach12 (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_DMACH12 } # [doc = "DMACH13"] # [inline (always)] pub fn is_iidx_stat_dmach13 (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_DMACH13 } # [doc = "DMACH14"] # [inline (always)] pub fn is_iidx_stat_dmach14 (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_DMACH14 } # [doc = "DMACH15"] # [inline (always)] pub fn is_iidx_stat_dmach15 (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_DMACH15 } # [doc = "PREIRQCH0"] # [inline (always)] pub fn is_iidx_stat_preirqch0 (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_PREIRQCH0 } # [doc = "PREIRQCH1"] # [inline (always)] pub fn is_iidx_stat_preirqch1 (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_PREIRQCH1 } # [doc = "PREIRQCH2"] # [inline (always)] pub fn is_iidx_stat_preirqch2 (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_PREIRQCH2 } # [doc = "PREIRQCH3"] # [inline (always)] pub fn is_iidx_stat_preirqch3 (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_PREIRQCH3 } # [doc = "PREIRQCH4"] # [inline (always)] pub fn is_iidx_stat_preirqch4 (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_PREIRQCH4 } # [doc = "PREIRQCH5"] # [inline (always)] pub fn is_iidx_stat_preirqch5 (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_PREIRQCH5 } # [doc = "PREIRQCH6"] # [inline (always)] pub fn is_iidx_stat_preirqch6 (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_PREIRQCH6 } # [doc = "PREIRQCH7"] # [inline (always)] pub fn is_iidx_stat_preirqch7 (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_PREIRQCH7 } # [doc = "ADDRERR"] # [inline (always)] pub fn is_iidx_stat_addrerr (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_ADDRERR } # [doc = "DATAERR"] # [inline (always)] pub fn is_iidx_stat_dataerr (& self) -> bool { * self == IIDX_STAT_A :: IIDX_STAT_DATAERR } } impl R { # [doc = "Bits 0:7 - Interrupt index status"] # [inline (always)] pub fn iidx_stat (& self) -> IIDX_STAT_R { IIDX_STAT_R :: new ((self . bits & 0xff) as u8) } } # [doc = "Interrupt index\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`iidx::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IIDX_SPEC ; impl crate :: RegisterSpec for IIDX_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`iidx::R`](R) reader structure"] impl crate :: Readable for IIDX_SPEC { } # [doc = "`reset()` method sets IIDX to value 0"] impl crate :: Resettable for IIDX_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }