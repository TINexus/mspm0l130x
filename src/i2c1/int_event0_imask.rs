# [doc = "Register `INT_EVENT0_IMASK` reader"] pub type R = crate :: R < INT_EVENT0_IMASK_SPEC > ; # [doc = "Register `INT_EVENT0_IMASK` writer"] pub type W = crate :: W < INT_EVENT0_IMASK_SPEC > ; # [doc = "Field `INT_EVENT0_IMASK_MRXDONE` reader - Master Receive Transaction completed Interrupt"] pub type INT_EVENT0_IMASK_MRXDONE_R = crate :: BitReader < INT_EVENT0_IMASK_MRXDONE_A > ; # [doc = "Master Receive Transaction completed Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_MRXDONE_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_MRXDONE_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_MRXDONE_SET = 1 , } impl From < INT_EVENT0_IMASK_MRXDONE_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_MRXDONE_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_MRXDONE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_MRXDONE_A { match self . bits { false => INT_EVENT0_IMASK_MRXDONE_A :: INT_EVENT0_IMASK_MRXDONE_CLR , true => INT_EVENT0_IMASK_MRXDONE_A :: INT_EVENT0_IMASK_MRXDONE_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_mrxdone_clr (& self) -> bool { * self == INT_EVENT0_IMASK_MRXDONE_A :: INT_EVENT0_IMASK_MRXDONE_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_mrxdone_set (& self) -> bool { * self == INT_EVENT0_IMASK_MRXDONE_A :: INT_EVENT0_IMASK_MRXDONE_SET } } # [doc = "Field `INT_EVENT0_IMASK_MRXDONE` writer - Master Receive Transaction completed Interrupt"] pub type INT_EVENT0_IMASK_MRXDONE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_MRXDONE_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_MRXDONE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_mrxdone_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MRXDONE_A :: INT_EVENT0_IMASK_MRXDONE_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_mrxdone_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MRXDONE_A :: INT_EVENT0_IMASK_MRXDONE_SET) } } # [doc = "Field `INT_EVENT0_IMASK_MTXDONE` reader - Master Transmit Transaction completed Interrupt"] pub type INT_EVENT0_IMASK_MTXDONE_R = crate :: BitReader < INT_EVENT0_IMASK_MTXDONE_A > ; # [doc = "Master Transmit Transaction completed Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_MTXDONE_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_MTXDONE_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_MTXDONE_SET = 1 , } impl From < INT_EVENT0_IMASK_MTXDONE_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_MTXDONE_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_MTXDONE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_MTXDONE_A { match self . bits { false => INT_EVENT0_IMASK_MTXDONE_A :: INT_EVENT0_IMASK_MTXDONE_CLR , true => INT_EVENT0_IMASK_MTXDONE_A :: INT_EVENT0_IMASK_MTXDONE_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_mtxdone_clr (& self) -> bool { * self == INT_EVENT0_IMASK_MTXDONE_A :: INT_EVENT0_IMASK_MTXDONE_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_mtxdone_set (& self) -> bool { * self == INT_EVENT0_IMASK_MTXDONE_A :: INT_EVENT0_IMASK_MTXDONE_SET } } # [doc = "Field `INT_EVENT0_IMASK_MTXDONE` writer - Master Transmit Transaction completed Interrupt"] pub type INT_EVENT0_IMASK_MTXDONE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_MTXDONE_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_MTXDONE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_mtxdone_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MTXDONE_A :: INT_EVENT0_IMASK_MTXDONE_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_mtxdone_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MTXDONE_A :: INT_EVENT0_IMASK_MTXDONE_SET) } } # [doc = "Field `INT_EVENT0_IMASK_MRXFIFOTRG` reader - Master Receive FIFO Trigger Trigger when RX FIFO contains &amp;gt;= defined bytes"] pub type INT_EVENT0_IMASK_MRXFIFOTRG_R = crate :: BitReader < INT_EVENT0_IMASK_MRXFIFOTRG_A > ; # [doc = "Master Receive FIFO Trigger Trigger when RX FIFO contains &amp;gt;= defined bytes\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_MRXFIFOTRG_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_MRXFIFOTRG_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_MRXFIFOTRG_SET = 1 , } impl From < INT_EVENT0_IMASK_MRXFIFOTRG_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_MRXFIFOTRG_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_MRXFIFOTRG_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_MRXFIFOTRG_A { match self . bits { false => INT_EVENT0_IMASK_MRXFIFOTRG_A :: INT_EVENT0_IMASK_MRXFIFOTRG_CLR , true => INT_EVENT0_IMASK_MRXFIFOTRG_A :: INT_EVENT0_IMASK_MRXFIFOTRG_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_mrxfifotrg_clr (& self) -> bool { * self == INT_EVENT0_IMASK_MRXFIFOTRG_A :: INT_EVENT0_IMASK_MRXFIFOTRG_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_mrxfifotrg_set (& self) -> bool { * self == INT_EVENT0_IMASK_MRXFIFOTRG_A :: INT_EVENT0_IMASK_MRXFIFOTRG_SET } } # [doc = "Field `INT_EVENT0_IMASK_MRXFIFOTRG` writer - Master Receive FIFO Trigger Trigger when RX FIFO contains &amp;gt;= defined bytes"] pub type INT_EVENT0_IMASK_MRXFIFOTRG_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_MRXFIFOTRG_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_MRXFIFOTRG_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_mrxfifotrg_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MRXFIFOTRG_A :: INT_EVENT0_IMASK_MRXFIFOTRG_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_mrxfifotrg_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MRXFIFOTRG_A :: INT_EVENT0_IMASK_MRXFIFOTRG_SET) } } # [doc = "Field `INT_EVENT0_IMASK_MTXFIFOTRG` reader - Master Transmit FIFO Trigger Trigger when Transmit FIFO contains &amp;lt;= defined bytes"] pub type INT_EVENT0_IMASK_MTXFIFOTRG_R = crate :: BitReader < INT_EVENT0_IMASK_MTXFIFOTRG_A > ; # [doc = "Master Transmit FIFO Trigger Trigger when Transmit FIFO contains &amp;lt;= defined bytes\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_MTXFIFOTRG_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_MTXFIFOTRG_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_MTXFIFOTRG_SET = 1 , } impl From < INT_EVENT0_IMASK_MTXFIFOTRG_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_MTXFIFOTRG_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_MTXFIFOTRG_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_MTXFIFOTRG_A { match self . bits { false => INT_EVENT0_IMASK_MTXFIFOTRG_A :: INT_EVENT0_IMASK_MTXFIFOTRG_CLR , true => INT_EVENT0_IMASK_MTXFIFOTRG_A :: INT_EVENT0_IMASK_MTXFIFOTRG_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_mtxfifotrg_clr (& self) -> bool { * self == INT_EVENT0_IMASK_MTXFIFOTRG_A :: INT_EVENT0_IMASK_MTXFIFOTRG_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_mtxfifotrg_set (& self) -> bool { * self == INT_EVENT0_IMASK_MTXFIFOTRG_A :: INT_EVENT0_IMASK_MTXFIFOTRG_SET } } # [doc = "Field `INT_EVENT0_IMASK_MTXFIFOTRG` writer - Master Transmit FIFO Trigger Trigger when Transmit FIFO contains &amp;lt;= defined bytes"] pub type INT_EVENT0_IMASK_MTXFIFOTRG_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_MTXFIFOTRG_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_MTXFIFOTRG_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_mtxfifotrg_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MTXFIFOTRG_A :: INT_EVENT0_IMASK_MTXFIFOTRG_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_mtxfifotrg_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MTXFIFOTRG_A :: INT_EVENT0_IMASK_MTXFIFOTRG_SET) } } # [doc = "Field `INT_EVENT0_IMASK_MRXFIFOFULL` reader - RXFIFO full event. This interrupt is set if an RX FIFO is full."] pub type INT_EVENT0_IMASK_MRXFIFOFULL_R = crate :: BitReader < INT_EVENT0_IMASK_MRXFIFOFULL_A > ; # [doc = "RXFIFO full event. This interrupt is set if an RX FIFO is full.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_MRXFIFOFULL_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_MRXFIFOFULL_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_MRXFIFOFULL_SET = 1 , } impl From < INT_EVENT0_IMASK_MRXFIFOFULL_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_MRXFIFOFULL_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_MRXFIFOFULL_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_MRXFIFOFULL_A { match self . bits { false => INT_EVENT0_IMASK_MRXFIFOFULL_A :: INT_EVENT0_IMASK_MRXFIFOFULL_CLR , true => INT_EVENT0_IMASK_MRXFIFOFULL_A :: INT_EVENT0_IMASK_MRXFIFOFULL_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_mrxfifofull_clr (& self) -> bool { * self == INT_EVENT0_IMASK_MRXFIFOFULL_A :: INT_EVENT0_IMASK_MRXFIFOFULL_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_mrxfifofull_set (& self) -> bool { * self == INT_EVENT0_IMASK_MRXFIFOFULL_A :: INT_EVENT0_IMASK_MRXFIFOFULL_SET } } # [doc = "Field `INT_EVENT0_IMASK_MRXFIFOFULL` writer - RXFIFO full event. This interrupt is set if an RX FIFO is full."] pub type INT_EVENT0_IMASK_MRXFIFOFULL_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_MRXFIFOFULL_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_MRXFIFOFULL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_mrxfifofull_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MRXFIFOFULL_A :: INT_EVENT0_IMASK_MRXFIFOFULL_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_mrxfifofull_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MRXFIFOFULL_A :: INT_EVENT0_IMASK_MRXFIFOFULL_SET) } } # [doc = "Field `INT_EVENT0_IMASK_MTXEMPTY` reader - Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode."] pub type INT_EVENT0_IMASK_MTXEMPTY_R = crate :: BitReader < INT_EVENT0_IMASK_MTXEMPTY_A > ; # [doc = "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_MTXEMPTY_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_MTXEMPTY_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_MTXEMPTY_SET = 1 , } impl From < INT_EVENT0_IMASK_MTXEMPTY_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_MTXEMPTY_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_MTXEMPTY_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_MTXEMPTY_A { match self . bits { false => INT_EVENT0_IMASK_MTXEMPTY_A :: INT_EVENT0_IMASK_MTXEMPTY_CLR , true => INT_EVENT0_IMASK_MTXEMPTY_A :: INT_EVENT0_IMASK_MTXEMPTY_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_mtxempty_clr (& self) -> bool { * self == INT_EVENT0_IMASK_MTXEMPTY_A :: INT_EVENT0_IMASK_MTXEMPTY_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_mtxempty_set (& self) -> bool { * self == INT_EVENT0_IMASK_MTXEMPTY_A :: INT_EVENT0_IMASK_MTXEMPTY_SET } } # [doc = "Field `INT_EVENT0_IMASK_MTXEMPTY` writer - Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode."] pub type INT_EVENT0_IMASK_MTXEMPTY_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_MTXEMPTY_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_MTXEMPTY_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_mtxempty_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MTXEMPTY_A :: INT_EVENT0_IMASK_MTXEMPTY_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_mtxempty_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MTXEMPTY_A :: INT_EVENT0_IMASK_MTXEMPTY_SET) } } # [doc = "Field `INT_EVENT0_IMASK_MNACK` reader - Address/Data NACK Interrupt"] pub type INT_EVENT0_IMASK_MNACK_R = crate :: BitReader < INT_EVENT0_IMASK_MNACK_A > ; # [doc = "Address/Data NACK Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_MNACK_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_MNACK_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_MNACK_SET = 1 , } impl From < INT_EVENT0_IMASK_MNACK_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_MNACK_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_MNACK_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_MNACK_A { match self . bits { false => INT_EVENT0_IMASK_MNACK_A :: INT_EVENT0_IMASK_MNACK_CLR , true => INT_EVENT0_IMASK_MNACK_A :: INT_EVENT0_IMASK_MNACK_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_mnack_clr (& self) -> bool { * self == INT_EVENT0_IMASK_MNACK_A :: INT_EVENT0_IMASK_MNACK_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_mnack_set (& self) -> bool { * self == INT_EVENT0_IMASK_MNACK_A :: INT_EVENT0_IMASK_MNACK_SET } } # [doc = "Field `INT_EVENT0_IMASK_MNACK` writer - Address/Data NACK Interrupt"] pub type INT_EVENT0_IMASK_MNACK_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_MNACK_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_MNACK_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_mnack_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MNACK_A :: INT_EVENT0_IMASK_MNACK_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_mnack_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MNACK_A :: INT_EVENT0_IMASK_MNACK_SET) } } # [doc = "Field `INT_EVENT0_IMASK_MSTART` reader - START Detection Interrupt"] pub type INT_EVENT0_IMASK_MSTART_R = crate :: BitReader < INT_EVENT0_IMASK_MSTART_A > ; # [doc = "START Detection Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_MSTART_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_MSTART_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_MSTART_SET = 1 , } impl From < INT_EVENT0_IMASK_MSTART_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_MSTART_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_MSTART_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_MSTART_A { match self . bits { false => INT_EVENT0_IMASK_MSTART_A :: INT_EVENT0_IMASK_MSTART_CLR , true => INT_EVENT0_IMASK_MSTART_A :: INT_EVENT0_IMASK_MSTART_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_mstart_clr (& self) -> bool { * self == INT_EVENT0_IMASK_MSTART_A :: INT_EVENT0_IMASK_MSTART_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_mstart_set (& self) -> bool { * self == INT_EVENT0_IMASK_MSTART_A :: INT_EVENT0_IMASK_MSTART_SET } } # [doc = "Field `INT_EVENT0_IMASK_MSTART` writer - START Detection Interrupt"] pub type INT_EVENT0_IMASK_MSTART_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_MSTART_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_MSTART_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_mstart_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MSTART_A :: INT_EVENT0_IMASK_MSTART_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_mstart_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MSTART_A :: INT_EVENT0_IMASK_MSTART_SET) } } # [doc = "Field `INT_EVENT0_IMASK_MSTOP` reader - STOP Detection Interrupt"] pub type INT_EVENT0_IMASK_MSTOP_R = crate :: BitReader < INT_EVENT0_IMASK_MSTOP_A > ; # [doc = "STOP Detection Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_MSTOP_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_MSTOP_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_MSTOP_SET = 1 , } impl From < INT_EVENT0_IMASK_MSTOP_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_MSTOP_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_MSTOP_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_MSTOP_A { match self . bits { false => INT_EVENT0_IMASK_MSTOP_A :: INT_EVENT0_IMASK_MSTOP_CLR , true => INT_EVENT0_IMASK_MSTOP_A :: INT_EVENT0_IMASK_MSTOP_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_mstop_clr (& self) -> bool { * self == INT_EVENT0_IMASK_MSTOP_A :: INT_EVENT0_IMASK_MSTOP_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_mstop_set (& self) -> bool { * self == INT_EVENT0_IMASK_MSTOP_A :: INT_EVENT0_IMASK_MSTOP_SET } } # [doc = "Field `INT_EVENT0_IMASK_MSTOP` writer - STOP Detection Interrupt"] pub type INT_EVENT0_IMASK_MSTOP_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_MSTOP_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_MSTOP_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_mstop_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MSTOP_A :: INT_EVENT0_IMASK_MSTOP_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_mstop_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MSTOP_A :: INT_EVENT0_IMASK_MSTOP_SET) } } # [doc = "Field `INT_EVENT0_IMASK_MARBLOST` reader - Arbitration Lost Interrupt"] pub type INT_EVENT0_IMASK_MARBLOST_R = crate :: BitReader < INT_EVENT0_IMASK_MARBLOST_A > ; # [doc = "Arbitration Lost Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_MARBLOST_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_MARBLOST_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_MARBLOST_SET = 1 , } impl From < INT_EVENT0_IMASK_MARBLOST_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_MARBLOST_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_MARBLOST_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_MARBLOST_A { match self . bits { false => INT_EVENT0_IMASK_MARBLOST_A :: INT_EVENT0_IMASK_MARBLOST_CLR , true => INT_EVENT0_IMASK_MARBLOST_A :: INT_EVENT0_IMASK_MARBLOST_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_marblost_clr (& self) -> bool { * self == INT_EVENT0_IMASK_MARBLOST_A :: INT_EVENT0_IMASK_MARBLOST_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_marblost_set (& self) -> bool { * self == INT_EVENT0_IMASK_MARBLOST_A :: INT_EVENT0_IMASK_MARBLOST_SET } } # [doc = "Field `INT_EVENT0_IMASK_MARBLOST` writer - Arbitration Lost Interrupt"] pub type INT_EVENT0_IMASK_MARBLOST_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_MARBLOST_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_MARBLOST_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_marblost_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MARBLOST_A :: INT_EVENT0_IMASK_MARBLOST_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_marblost_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MARBLOST_A :: INT_EVENT0_IMASK_MARBLOST_SET) } } # [doc = "Field `INT_EVENT0_IMASK_MDMA_DONE1_2` reader - DMA Done 1 on Event Channel 2"] pub type INT_EVENT0_IMASK_MDMA_DONE1_2_R = crate :: BitReader < INT_EVENT0_IMASK_MDMA_DONE1_2_A > ; # [doc = "DMA Done 1 on Event Channel 2\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_MDMA_DONE1_2_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_MDMA_DONE1_2_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_MDMA_DONE1_2_SET = 1 , } impl From < INT_EVENT0_IMASK_MDMA_DONE1_2_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_MDMA_DONE1_2_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_MDMA_DONE1_2_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_MDMA_DONE1_2_A { match self . bits { false => INT_EVENT0_IMASK_MDMA_DONE1_2_A :: INT_EVENT0_IMASK_MDMA_DONE1_2_CLR , true => INT_EVENT0_IMASK_MDMA_DONE1_2_A :: INT_EVENT0_IMASK_MDMA_DONE1_2_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_mdma_done1_2_clr (& self) -> bool { * self == INT_EVENT0_IMASK_MDMA_DONE1_2_A :: INT_EVENT0_IMASK_MDMA_DONE1_2_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_mdma_done1_2_set (& self) -> bool { * self == INT_EVENT0_IMASK_MDMA_DONE1_2_A :: INT_EVENT0_IMASK_MDMA_DONE1_2_SET } } # [doc = "Field `INT_EVENT0_IMASK_MDMA_DONE1_2` writer - DMA Done 1 on Event Channel 2"] pub type INT_EVENT0_IMASK_MDMA_DONE1_2_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_MDMA_DONE1_2_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_MDMA_DONE1_2_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_mdma_done1_2_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MDMA_DONE1_2_A :: INT_EVENT0_IMASK_MDMA_DONE1_2_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_mdma_done1_2_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MDMA_DONE1_2_A :: INT_EVENT0_IMASK_MDMA_DONE1_2_SET) } } # [doc = "Field `INT_EVENT0_IMASK_MDMA_DONE1_3` reader - DMA Done 1 on Event Channel 3"] pub type INT_EVENT0_IMASK_MDMA_DONE1_3_R = crate :: BitReader < INT_EVENT0_IMASK_MDMA_DONE1_3_A > ; # [doc = "DMA Done 1 on Event Channel 3\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_MDMA_DONE1_3_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_MDMA_DONE1_3_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_MDMA_DONE1_3_SET = 1 , } impl From < INT_EVENT0_IMASK_MDMA_DONE1_3_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_MDMA_DONE1_3_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_MDMA_DONE1_3_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_MDMA_DONE1_3_A { match self . bits { false => INT_EVENT0_IMASK_MDMA_DONE1_3_A :: INT_EVENT0_IMASK_MDMA_DONE1_3_CLR , true => INT_EVENT0_IMASK_MDMA_DONE1_3_A :: INT_EVENT0_IMASK_MDMA_DONE1_3_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_mdma_done1_3_clr (& self) -> bool { * self == INT_EVENT0_IMASK_MDMA_DONE1_3_A :: INT_EVENT0_IMASK_MDMA_DONE1_3_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_mdma_done1_3_set (& self) -> bool { * self == INT_EVENT0_IMASK_MDMA_DONE1_3_A :: INT_EVENT0_IMASK_MDMA_DONE1_3_SET } } # [doc = "Field `INT_EVENT0_IMASK_MDMA_DONE1_3` writer - DMA Done 1 on Event Channel 3"] pub type INT_EVENT0_IMASK_MDMA_DONE1_3_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_MDMA_DONE1_3_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_MDMA_DONE1_3_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_mdma_done1_3_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MDMA_DONE1_3_A :: INT_EVENT0_IMASK_MDMA_DONE1_3_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_mdma_done1_3_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MDMA_DONE1_3_A :: INT_EVENT0_IMASK_MDMA_DONE1_3_SET) } } # [doc = "Field `INT_EVENT0_IMASK_MPEC_RX_ERR` reader - Master RX Pec Error Interrupt"] pub type INT_EVENT0_IMASK_MPEC_RX_ERR_R = crate :: BitReader < INT_EVENT0_IMASK_MPEC_RX_ERR_A > ; # [doc = "Master RX Pec Error Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_MPEC_RX_ERR_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_MPEC_RX_ERR_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_MPEC_RX_ERR_SET = 1 , } impl From < INT_EVENT0_IMASK_MPEC_RX_ERR_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_MPEC_RX_ERR_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_MPEC_RX_ERR_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_MPEC_RX_ERR_A { match self . bits { false => INT_EVENT0_IMASK_MPEC_RX_ERR_A :: INT_EVENT0_IMASK_MPEC_RX_ERR_CLR , true => INT_EVENT0_IMASK_MPEC_RX_ERR_A :: INT_EVENT0_IMASK_MPEC_RX_ERR_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_mpec_rx_err_clr (& self) -> bool { * self == INT_EVENT0_IMASK_MPEC_RX_ERR_A :: INT_EVENT0_IMASK_MPEC_RX_ERR_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_mpec_rx_err_set (& self) -> bool { * self == INT_EVENT0_IMASK_MPEC_RX_ERR_A :: INT_EVENT0_IMASK_MPEC_RX_ERR_SET } } # [doc = "Field `INT_EVENT0_IMASK_MPEC_RX_ERR` writer - Master RX Pec Error Interrupt"] pub type INT_EVENT0_IMASK_MPEC_RX_ERR_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_MPEC_RX_ERR_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_MPEC_RX_ERR_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_mpec_rx_err_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MPEC_RX_ERR_A :: INT_EVENT0_IMASK_MPEC_RX_ERR_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_mpec_rx_err_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_MPEC_RX_ERR_A :: INT_EVENT0_IMASK_MPEC_RX_ERR_SET) } } # [doc = "Field `INT_EVENT0_IMASK_TIMEOUTA` reader - Timeout A Interrupt"] pub type INT_EVENT0_IMASK_TIMEOUTA_R = crate :: BitReader < INT_EVENT0_IMASK_TIMEOUTA_A > ; # [doc = "Timeout A Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_TIMEOUTA_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_TIMEOUTA_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_TIMEOUTA_SET = 1 , } impl From < INT_EVENT0_IMASK_TIMEOUTA_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_TIMEOUTA_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_TIMEOUTA_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_TIMEOUTA_A { match self . bits { false => INT_EVENT0_IMASK_TIMEOUTA_A :: INT_EVENT0_IMASK_TIMEOUTA_CLR , true => INT_EVENT0_IMASK_TIMEOUTA_A :: INT_EVENT0_IMASK_TIMEOUTA_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_timeouta_clr (& self) -> bool { * self == INT_EVENT0_IMASK_TIMEOUTA_A :: INT_EVENT0_IMASK_TIMEOUTA_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_timeouta_set (& self) -> bool { * self == INT_EVENT0_IMASK_TIMEOUTA_A :: INT_EVENT0_IMASK_TIMEOUTA_SET } } # [doc = "Field `INT_EVENT0_IMASK_TIMEOUTA` writer - Timeout A Interrupt"] pub type INT_EVENT0_IMASK_TIMEOUTA_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_TIMEOUTA_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_TIMEOUTA_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_timeouta_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_TIMEOUTA_A :: INT_EVENT0_IMASK_TIMEOUTA_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_timeouta_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_TIMEOUTA_A :: INT_EVENT0_IMASK_TIMEOUTA_SET) } } # [doc = "Field `INT_EVENT0_IMASK_TIMEOUTB` reader - Timeout B Interrupt"] pub type INT_EVENT0_IMASK_TIMEOUTB_R = crate :: BitReader < INT_EVENT0_IMASK_TIMEOUTB_A > ; # [doc = "Timeout B Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_TIMEOUTB_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_TIMEOUTB_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_TIMEOUTB_SET = 1 , } impl From < INT_EVENT0_IMASK_TIMEOUTB_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_TIMEOUTB_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_TIMEOUTB_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_TIMEOUTB_A { match self . bits { false => INT_EVENT0_IMASK_TIMEOUTB_A :: INT_EVENT0_IMASK_TIMEOUTB_CLR , true => INT_EVENT0_IMASK_TIMEOUTB_A :: INT_EVENT0_IMASK_TIMEOUTB_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_timeoutb_clr (& self) -> bool { * self == INT_EVENT0_IMASK_TIMEOUTB_A :: INT_EVENT0_IMASK_TIMEOUTB_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_timeoutb_set (& self) -> bool { * self == INT_EVENT0_IMASK_TIMEOUTB_A :: INT_EVENT0_IMASK_TIMEOUTB_SET } } # [doc = "Field `INT_EVENT0_IMASK_TIMEOUTB` writer - Timeout B Interrupt"] pub type INT_EVENT0_IMASK_TIMEOUTB_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_TIMEOUTB_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_TIMEOUTB_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_timeoutb_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_TIMEOUTB_A :: INT_EVENT0_IMASK_TIMEOUTB_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_timeoutb_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_TIMEOUTB_A :: INT_EVENT0_IMASK_TIMEOUTB_SET) } } # [doc = "Field `INT_EVENT0_IMASK_SRXDONE` reader - Slave Receive Data Interrupt Signals that a byte has been received"] pub type INT_EVENT0_IMASK_SRXDONE_R = crate :: BitReader < INT_EVENT0_IMASK_SRXDONE_A > ; # [doc = "Slave Receive Data Interrupt Signals that a byte has been received\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_SRXDONE_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_SRXDONE_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_SRXDONE_SET = 1 , } impl From < INT_EVENT0_IMASK_SRXDONE_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_SRXDONE_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_SRXDONE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_SRXDONE_A { match self . bits { false => INT_EVENT0_IMASK_SRXDONE_A :: INT_EVENT0_IMASK_SRXDONE_CLR , true => INT_EVENT0_IMASK_SRXDONE_A :: INT_EVENT0_IMASK_SRXDONE_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_srxdone_clr (& self) -> bool { * self == INT_EVENT0_IMASK_SRXDONE_A :: INT_EVENT0_IMASK_SRXDONE_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_srxdone_set (& self) -> bool { * self == INT_EVENT0_IMASK_SRXDONE_A :: INT_EVENT0_IMASK_SRXDONE_SET } } # [doc = "Field `INT_EVENT0_IMASK_SRXDONE` writer - Slave Receive Data Interrupt Signals that a byte has been received"] pub type INT_EVENT0_IMASK_SRXDONE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_SRXDONE_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_SRXDONE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_srxdone_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_SRXDONE_A :: INT_EVENT0_IMASK_SRXDONE_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_srxdone_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_SRXDONE_A :: INT_EVENT0_IMASK_SRXDONE_SET) } } # [doc = "Field `INT_EVENT0_IMASK_STXDONE` reader - Slave Transmit Transaction completed Interrupt"] pub type INT_EVENT0_IMASK_STXDONE_R = crate :: BitReader < INT_EVENT0_IMASK_STXDONE_A > ; # [doc = "Slave Transmit Transaction completed Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_STXDONE_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_STXDONE_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_STXDONE_SET = 1 , } impl From < INT_EVENT0_IMASK_STXDONE_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_STXDONE_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_STXDONE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_STXDONE_A { match self . bits { false => INT_EVENT0_IMASK_STXDONE_A :: INT_EVENT0_IMASK_STXDONE_CLR , true => INT_EVENT0_IMASK_STXDONE_A :: INT_EVENT0_IMASK_STXDONE_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_stxdone_clr (& self) -> bool { * self == INT_EVENT0_IMASK_STXDONE_A :: INT_EVENT0_IMASK_STXDONE_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_stxdone_set (& self) -> bool { * self == INT_EVENT0_IMASK_STXDONE_A :: INT_EVENT0_IMASK_STXDONE_SET } } # [doc = "Field `INT_EVENT0_IMASK_STXDONE` writer - Slave Transmit Transaction completed Interrupt"] pub type INT_EVENT0_IMASK_STXDONE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_STXDONE_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_STXDONE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_stxdone_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_STXDONE_A :: INT_EVENT0_IMASK_STXDONE_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_stxdone_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_STXDONE_A :: INT_EVENT0_IMASK_STXDONE_SET) } } # [doc = "Field `INT_EVENT0_IMASK_SRXFIFOTRG` reader - Slave Receive FIFO Trigger"] pub type INT_EVENT0_IMASK_SRXFIFOTRG_R = crate :: BitReader < INT_EVENT0_IMASK_SRXFIFOTRG_A > ; # [doc = "Slave Receive FIFO Trigger\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_SRXFIFOTRG_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_SRXFIFOTRG_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_SRXFIFOTRG_SET = 1 , } impl From < INT_EVENT0_IMASK_SRXFIFOTRG_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_SRXFIFOTRG_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_SRXFIFOTRG_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_SRXFIFOTRG_A { match self . bits { false => INT_EVENT0_IMASK_SRXFIFOTRG_A :: INT_EVENT0_IMASK_SRXFIFOTRG_CLR , true => INT_EVENT0_IMASK_SRXFIFOTRG_A :: INT_EVENT0_IMASK_SRXFIFOTRG_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_srxfifotrg_clr (& self) -> bool { * self == INT_EVENT0_IMASK_SRXFIFOTRG_A :: INT_EVENT0_IMASK_SRXFIFOTRG_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_srxfifotrg_set (& self) -> bool { * self == INT_EVENT0_IMASK_SRXFIFOTRG_A :: INT_EVENT0_IMASK_SRXFIFOTRG_SET } } # [doc = "Field `INT_EVENT0_IMASK_SRXFIFOTRG` writer - Slave Receive FIFO Trigger"] pub type INT_EVENT0_IMASK_SRXFIFOTRG_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_SRXFIFOTRG_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_SRXFIFOTRG_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_srxfifotrg_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_SRXFIFOTRG_A :: INT_EVENT0_IMASK_SRXFIFOTRG_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_srxfifotrg_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_SRXFIFOTRG_A :: INT_EVENT0_IMASK_SRXFIFOTRG_SET) } } # [doc = "Field `INT_EVENT0_IMASK_STXFIFOTRG` reader - Slave Transmit FIFO Trigger"] pub type INT_EVENT0_IMASK_STXFIFOTRG_R = crate :: BitReader < INT_EVENT0_IMASK_STXFIFOTRG_A > ; # [doc = "Slave Transmit FIFO Trigger\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_STXFIFOTRG_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_STXFIFOTRG_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_STXFIFOTRG_SET = 1 , } impl From < INT_EVENT0_IMASK_STXFIFOTRG_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_STXFIFOTRG_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_STXFIFOTRG_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_STXFIFOTRG_A { match self . bits { false => INT_EVENT0_IMASK_STXFIFOTRG_A :: INT_EVENT0_IMASK_STXFIFOTRG_CLR , true => INT_EVENT0_IMASK_STXFIFOTRG_A :: INT_EVENT0_IMASK_STXFIFOTRG_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_stxfifotrg_clr (& self) -> bool { * self == INT_EVENT0_IMASK_STXFIFOTRG_A :: INT_EVENT0_IMASK_STXFIFOTRG_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_stxfifotrg_set (& self) -> bool { * self == INT_EVENT0_IMASK_STXFIFOTRG_A :: INT_EVENT0_IMASK_STXFIFOTRG_SET } } # [doc = "Field `INT_EVENT0_IMASK_STXFIFOTRG` writer - Slave Transmit FIFO Trigger"] pub type INT_EVENT0_IMASK_STXFIFOTRG_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_STXFIFOTRG_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_STXFIFOTRG_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_stxfifotrg_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_STXFIFOTRG_A :: INT_EVENT0_IMASK_STXFIFOTRG_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_stxfifotrg_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_STXFIFOTRG_A :: INT_EVENT0_IMASK_STXFIFOTRG_SET) } } # [doc = "Field `INT_EVENT0_IMASK_SRXFIFOFULL` reader - RXFIFO full event. This interrupt is set if an Slave RX FIFO is full."] pub type INT_EVENT0_IMASK_SRXFIFOFULL_R = crate :: BitReader < INT_EVENT0_IMASK_SRXFIFOFULL_A > ; # [doc = "RXFIFO full event. This interrupt is set if an Slave RX FIFO is full.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_SRXFIFOFULL_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_SRXFIFOFULL_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_SRXFIFOFULL_SET = 1 , } impl From < INT_EVENT0_IMASK_SRXFIFOFULL_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_SRXFIFOFULL_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_SRXFIFOFULL_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_SRXFIFOFULL_A { match self . bits { false => INT_EVENT0_IMASK_SRXFIFOFULL_A :: INT_EVENT0_IMASK_SRXFIFOFULL_CLR , true => INT_EVENT0_IMASK_SRXFIFOFULL_A :: INT_EVENT0_IMASK_SRXFIFOFULL_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_srxfifofull_clr (& self) -> bool { * self == INT_EVENT0_IMASK_SRXFIFOFULL_A :: INT_EVENT0_IMASK_SRXFIFOFULL_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_srxfifofull_set (& self) -> bool { * self == INT_EVENT0_IMASK_SRXFIFOFULL_A :: INT_EVENT0_IMASK_SRXFIFOFULL_SET } } # [doc = "Field `INT_EVENT0_IMASK_SRXFIFOFULL` writer - RXFIFO full event. This interrupt is set if an Slave RX FIFO is full."] pub type INT_EVENT0_IMASK_SRXFIFOFULL_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_SRXFIFOFULL_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_SRXFIFOFULL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_srxfifofull_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_SRXFIFOFULL_A :: INT_EVENT0_IMASK_SRXFIFOFULL_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_srxfifofull_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_SRXFIFOFULL_A :: INT_EVENT0_IMASK_SRXFIFOFULL_SET) } } # [doc = "Field `INT_EVENT0_IMASK_STXEMPTY` reader - Slave Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode."] pub type INT_EVENT0_IMASK_STXEMPTY_R = crate :: BitReader < INT_EVENT0_IMASK_STXEMPTY_A > ; # [doc = "Slave Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_STXEMPTY_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_STXEMPTY_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_STXEMPTY_SET = 1 , } impl From < INT_EVENT0_IMASK_STXEMPTY_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_STXEMPTY_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_STXEMPTY_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_STXEMPTY_A { match self . bits { false => INT_EVENT0_IMASK_STXEMPTY_A :: INT_EVENT0_IMASK_STXEMPTY_CLR , true => INT_EVENT0_IMASK_STXEMPTY_A :: INT_EVENT0_IMASK_STXEMPTY_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_stxempty_clr (& self) -> bool { * self == INT_EVENT0_IMASK_STXEMPTY_A :: INT_EVENT0_IMASK_STXEMPTY_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_stxempty_set (& self) -> bool { * self == INT_EVENT0_IMASK_STXEMPTY_A :: INT_EVENT0_IMASK_STXEMPTY_SET } } # [doc = "Field `INT_EVENT0_IMASK_STXEMPTY` writer - Slave Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode."] pub type INT_EVENT0_IMASK_STXEMPTY_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_STXEMPTY_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_STXEMPTY_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_stxempty_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_STXEMPTY_A :: INT_EVENT0_IMASK_STXEMPTY_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_stxempty_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_STXEMPTY_A :: INT_EVENT0_IMASK_STXEMPTY_SET) } } # [doc = "Field `INT_EVENT0_IMASK_SSTART` reader - Start Condition Interrupt"] pub type INT_EVENT0_IMASK_SSTART_R = crate :: BitReader < INT_EVENT0_IMASK_SSTART_A > ; # [doc = "Start Condition Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_SSTART_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_SSTART_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_SSTART_SET = 1 , } impl From < INT_EVENT0_IMASK_SSTART_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_SSTART_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_SSTART_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_SSTART_A { match self . bits { false => INT_EVENT0_IMASK_SSTART_A :: INT_EVENT0_IMASK_SSTART_CLR , true => INT_EVENT0_IMASK_SSTART_A :: INT_EVENT0_IMASK_SSTART_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_sstart_clr (& self) -> bool { * self == INT_EVENT0_IMASK_SSTART_A :: INT_EVENT0_IMASK_SSTART_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_sstart_set (& self) -> bool { * self == INT_EVENT0_IMASK_SSTART_A :: INT_EVENT0_IMASK_SSTART_SET } } # [doc = "Field `INT_EVENT0_IMASK_SSTART` writer - Start Condition Interrupt"] pub type INT_EVENT0_IMASK_SSTART_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_SSTART_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_SSTART_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_sstart_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_SSTART_A :: INT_EVENT0_IMASK_SSTART_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_sstart_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_SSTART_A :: INT_EVENT0_IMASK_SSTART_SET) } } # [doc = "Field `INT_EVENT0_IMASK_SSTOP` reader - Stop Condition Interrupt"] pub type INT_EVENT0_IMASK_SSTOP_R = crate :: BitReader < INT_EVENT0_IMASK_SSTOP_A > ; # [doc = "Stop Condition Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_SSTOP_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_SSTOP_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_SSTOP_SET = 1 , } impl From < INT_EVENT0_IMASK_SSTOP_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_SSTOP_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_SSTOP_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_SSTOP_A { match self . bits { false => INT_EVENT0_IMASK_SSTOP_A :: INT_EVENT0_IMASK_SSTOP_CLR , true => INT_EVENT0_IMASK_SSTOP_A :: INT_EVENT0_IMASK_SSTOP_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_sstop_clr (& self) -> bool { * self == INT_EVENT0_IMASK_SSTOP_A :: INT_EVENT0_IMASK_SSTOP_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_sstop_set (& self) -> bool { * self == INT_EVENT0_IMASK_SSTOP_A :: INT_EVENT0_IMASK_SSTOP_SET } } # [doc = "Field `INT_EVENT0_IMASK_SSTOP` writer - Stop Condition Interrupt"] pub type INT_EVENT0_IMASK_SSTOP_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_SSTOP_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_SSTOP_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_sstop_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_SSTOP_A :: INT_EVENT0_IMASK_SSTOP_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_sstop_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_SSTOP_A :: INT_EVENT0_IMASK_SSTOP_SET) } } # [doc = "Field `INT_EVENT0_IMASK_SGENCALL` reader - General Call Interrupt"] pub type INT_EVENT0_IMASK_SGENCALL_R = crate :: BitReader < INT_EVENT0_IMASK_SGENCALL_A > ; # [doc = "General Call Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_SGENCALL_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_SGENCALL_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_SGENCALL_SET = 1 , } impl From < INT_EVENT0_IMASK_SGENCALL_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_SGENCALL_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_SGENCALL_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_SGENCALL_A { match self . bits { false => INT_EVENT0_IMASK_SGENCALL_A :: INT_EVENT0_IMASK_SGENCALL_CLR , true => INT_EVENT0_IMASK_SGENCALL_A :: INT_EVENT0_IMASK_SGENCALL_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_sgencall_clr (& self) -> bool { * self == INT_EVENT0_IMASK_SGENCALL_A :: INT_EVENT0_IMASK_SGENCALL_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_sgencall_set (& self) -> bool { * self == INT_EVENT0_IMASK_SGENCALL_A :: INT_EVENT0_IMASK_SGENCALL_SET } } # [doc = "Field `INT_EVENT0_IMASK_SGENCALL` writer - General Call Interrupt"] pub type INT_EVENT0_IMASK_SGENCALL_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_SGENCALL_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_SGENCALL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_sgencall_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_SGENCALL_A :: INT_EVENT0_IMASK_SGENCALL_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_sgencall_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_SGENCALL_A :: INT_EVENT0_IMASK_SGENCALL_SET) } } # [doc = "Field `INT_EVENT0_IMASK_SDMA_DONE1_2` reader - Slave DMA Done 1 on Event Channel 2"] pub type INT_EVENT0_IMASK_SDMA_DONE1_2_R = crate :: BitReader < INT_EVENT0_IMASK_SDMA_DONE1_2_A > ; # [doc = "Slave DMA Done 1 on Event Channel 2\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_SDMA_DONE1_2_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_SDMA_DONE1_2_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_SDMA_DONE1_2_SET = 1 , } impl From < INT_EVENT0_IMASK_SDMA_DONE1_2_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_SDMA_DONE1_2_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_SDMA_DONE1_2_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_SDMA_DONE1_2_A { match self . bits { false => INT_EVENT0_IMASK_SDMA_DONE1_2_A :: INT_EVENT0_IMASK_SDMA_DONE1_2_CLR , true => INT_EVENT0_IMASK_SDMA_DONE1_2_A :: INT_EVENT0_IMASK_SDMA_DONE1_2_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_sdma_done1_2_clr (& self) -> bool { * self == INT_EVENT0_IMASK_SDMA_DONE1_2_A :: INT_EVENT0_IMASK_SDMA_DONE1_2_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_sdma_done1_2_set (& self) -> bool { * self == INT_EVENT0_IMASK_SDMA_DONE1_2_A :: INT_EVENT0_IMASK_SDMA_DONE1_2_SET } } # [doc = "Field `INT_EVENT0_IMASK_SDMA_DONE1_2` writer - Slave DMA Done 1 on Event Channel 2"] pub type INT_EVENT0_IMASK_SDMA_DONE1_2_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_SDMA_DONE1_2_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_SDMA_DONE1_2_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_sdma_done1_2_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_SDMA_DONE1_2_A :: INT_EVENT0_IMASK_SDMA_DONE1_2_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_sdma_done1_2_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_SDMA_DONE1_2_A :: INT_EVENT0_IMASK_SDMA_DONE1_2_SET) } } # [doc = "Field `INT_EVENT0_IMASK_SDMA_DONE1_3` reader - Slave DMA Done 1 on Event Channel 3"] pub type INT_EVENT0_IMASK_SDMA_DONE1_3_R = crate :: BitReader < INT_EVENT0_IMASK_SDMA_DONE1_3_A > ; # [doc = "Slave DMA Done 1 on Event Channel 3\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_SDMA_DONE1_3_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_SDMA_DONE1_3_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_SDMA_DONE1_3_SET = 1 , } impl From < INT_EVENT0_IMASK_SDMA_DONE1_3_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_SDMA_DONE1_3_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_SDMA_DONE1_3_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_SDMA_DONE1_3_A { match self . bits { false => INT_EVENT0_IMASK_SDMA_DONE1_3_A :: INT_EVENT0_IMASK_SDMA_DONE1_3_CLR , true => INT_EVENT0_IMASK_SDMA_DONE1_3_A :: INT_EVENT0_IMASK_SDMA_DONE1_3_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_sdma_done1_3_clr (& self) -> bool { * self == INT_EVENT0_IMASK_SDMA_DONE1_3_A :: INT_EVENT0_IMASK_SDMA_DONE1_3_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_sdma_done1_3_set (& self) -> bool { * self == INT_EVENT0_IMASK_SDMA_DONE1_3_A :: INT_EVENT0_IMASK_SDMA_DONE1_3_SET } } # [doc = "Field `INT_EVENT0_IMASK_SDMA_DONE1_3` writer - Slave DMA Done 1 on Event Channel 3"] pub type INT_EVENT0_IMASK_SDMA_DONE1_3_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_SDMA_DONE1_3_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_SDMA_DONE1_3_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_sdma_done1_3_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_SDMA_DONE1_3_A :: INT_EVENT0_IMASK_SDMA_DONE1_3_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_sdma_done1_3_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_SDMA_DONE1_3_A :: INT_EVENT0_IMASK_SDMA_DONE1_3_SET) } } # [doc = "Field `INT_EVENT0_IMASK_SPEC_RX_ERR` reader - Slave RX Pec Error Interrupt"] pub type INT_EVENT0_IMASK_SPEC_RX_ERR_R = crate :: BitReader < INT_EVENT0_IMASK_SPEC_RX_ERR_A > ; # [doc = "Slave RX Pec Error Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_SPEC_RX_ERR_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_SPEC_RX_ERR_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_SPEC_RX_ERR_SET = 1 , } impl From < INT_EVENT0_IMASK_SPEC_RX_ERR_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_SPEC_RX_ERR_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_SPEC_RX_ERR_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_SPEC_RX_ERR_A { match self . bits { false => INT_EVENT0_IMASK_SPEC_RX_ERR_A :: INT_EVENT0_IMASK_SPEC_RX_ERR_CLR , true => INT_EVENT0_IMASK_SPEC_RX_ERR_A :: INT_EVENT0_IMASK_SPEC_RX_ERR_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_spec_rx_err_clr (& self) -> bool { * self == INT_EVENT0_IMASK_SPEC_RX_ERR_A :: INT_EVENT0_IMASK_SPEC_RX_ERR_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_spec_rx_err_set (& self) -> bool { * self == INT_EVENT0_IMASK_SPEC_RX_ERR_A :: INT_EVENT0_IMASK_SPEC_RX_ERR_SET } } # [doc = "Field `INT_EVENT0_IMASK_SPEC_RX_ERR` writer - Slave RX Pec Error Interrupt"] pub type INT_EVENT0_IMASK_SPEC_RX_ERR_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_SPEC_RX_ERR_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_SPEC_RX_ERR_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_spec_rx_err_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_SPEC_RX_ERR_A :: INT_EVENT0_IMASK_SPEC_RX_ERR_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_spec_rx_err_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_SPEC_RX_ERR_A :: INT_EVENT0_IMASK_SPEC_RX_ERR_SET) } } # [doc = "Field `INT_EVENT0_IMASK_STX_UNFL` reader - Slave TX FIFO underflow"] pub type INT_EVENT0_IMASK_STX_UNFL_R = crate :: BitReader < INT_EVENT0_IMASK_STX_UNFL_A > ; # [doc = "Slave TX FIFO underflow\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_STX_UNFL_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_STX_UNFL_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_STX_UNFL_SET = 1 , } impl From < INT_EVENT0_IMASK_STX_UNFL_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_STX_UNFL_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_STX_UNFL_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_STX_UNFL_A { match self . bits { false => INT_EVENT0_IMASK_STX_UNFL_A :: INT_EVENT0_IMASK_STX_UNFL_CLR , true => INT_EVENT0_IMASK_STX_UNFL_A :: INT_EVENT0_IMASK_STX_UNFL_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_stx_unfl_clr (& self) -> bool { * self == INT_EVENT0_IMASK_STX_UNFL_A :: INT_EVENT0_IMASK_STX_UNFL_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_stx_unfl_set (& self) -> bool { * self == INT_EVENT0_IMASK_STX_UNFL_A :: INT_EVENT0_IMASK_STX_UNFL_SET } } # [doc = "Field `INT_EVENT0_IMASK_STX_UNFL` writer - Slave TX FIFO underflow"] pub type INT_EVENT0_IMASK_STX_UNFL_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_STX_UNFL_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_STX_UNFL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_stx_unfl_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_STX_UNFL_A :: INT_EVENT0_IMASK_STX_UNFL_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_stx_unfl_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_STX_UNFL_A :: INT_EVENT0_IMASK_STX_UNFL_SET) } } # [doc = "Field `INT_EVENT0_IMASK_SRX_OVFL` reader - Slave RX FIFO overflow"] pub type INT_EVENT0_IMASK_SRX_OVFL_R = crate :: BitReader < INT_EVENT0_IMASK_SRX_OVFL_A > ; # [doc = "Slave RX FIFO overflow\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_SRX_OVFL_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_SRX_OVFL_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_SRX_OVFL_SET = 1 , } impl From < INT_EVENT0_IMASK_SRX_OVFL_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_SRX_OVFL_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_SRX_OVFL_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_SRX_OVFL_A { match self . bits { false => INT_EVENT0_IMASK_SRX_OVFL_A :: INT_EVENT0_IMASK_SRX_OVFL_CLR , true => INT_EVENT0_IMASK_SRX_OVFL_A :: INT_EVENT0_IMASK_SRX_OVFL_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_srx_ovfl_clr (& self) -> bool { * self == INT_EVENT0_IMASK_SRX_OVFL_A :: INT_EVENT0_IMASK_SRX_OVFL_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_srx_ovfl_set (& self) -> bool { * self == INT_EVENT0_IMASK_SRX_OVFL_A :: INT_EVENT0_IMASK_SRX_OVFL_SET } } # [doc = "Field `INT_EVENT0_IMASK_SRX_OVFL` writer - Slave RX FIFO overflow"] pub type INT_EVENT0_IMASK_SRX_OVFL_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_SRX_OVFL_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_SRX_OVFL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_srx_ovfl_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_SRX_OVFL_A :: INT_EVENT0_IMASK_SRX_OVFL_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_srx_ovfl_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_SRX_OVFL_A :: INT_EVENT0_IMASK_SRX_OVFL_SET) } } # [doc = "Field `INT_EVENT0_IMASK_SARBLOST` reader - Slave Arbitration Lost"] pub type INT_EVENT0_IMASK_SARBLOST_R = crate :: BitReader < INT_EVENT0_IMASK_SARBLOST_A > ; # [doc = "Slave Arbitration Lost\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_SARBLOST_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_SARBLOST_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_SARBLOST_SET = 1 , } impl From < INT_EVENT0_IMASK_SARBLOST_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_SARBLOST_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_SARBLOST_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_SARBLOST_A { match self . bits { false => INT_EVENT0_IMASK_SARBLOST_A :: INT_EVENT0_IMASK_SARBLOST_CLR , true => INT_EVENT0_IMASK_SARBLOST_A :: INT_EVENT0_IMASK_SARBLOST_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_sarblost_clr (& self) -> bool { * self == INT_EVENT0_IMASK_SARBLOST_A :: INT_EVENT0_IMASK_SARBLOST_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_sarblost_set (& self) -> bool { * self == INT_EVENT0_IMASK_SARBLOST_A :: INT_EVENT0_IMASK_SARBLOST_SET } } # [doc = "Field `INT_EVENT0_IMASK_SARBLOST` writer - Slave Arbitration Lost"] pub type INT_EVENT0_IMASK_SARBLOST_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_SARBLOST_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_SARBLOST_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_sarblost_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_SARBLOST_A :: INT_EVENT0_IMASK_SARBLOST_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_sarblost_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_SARBLOST_A :: INT_EVENT0_IMASK_SARBLOST_SET) } } # [doc = "Field `INT_EVENT0_IMASK_INTR_OVFL` reader - Interrupt Overflow Interrupt Mask"] pub type INT_EVENT0_IMASK_INTR_OVFL_R = crate :: BitReader < INT_EVENT0_IMASK_INTR_OVFL_A > ; # [doc = "Interrupt Overflow Interrupt Mask\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_IMASK_INTR_OVFL_A { # [doc = "0: CLR"] INT_EVENT0_IMASK_INTR_OVFL_CLR = 0 , # [doc = "1: SET"] INT_EVENT0_IMASK_INTR_OVFL_SET = 1 , } impl From < INT_EVENT0_IMASK_INTR_OVFL_A > for bool { # [inline (always)] fn from (variant : INT_EVENT0_IMASK_INTR_OVFL_A) -> Self { variant as u8 != 0 } } impl INT_EVENT0_IMASK_INTR_OVFL_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> INT_EVENT0_IMASK_INTR_OVFL_A { match self . bits { false => INT_EVENT0_IMASK_INTR_OVFL_A :: INT_EVENT0_IMASK_INTR_OVFL_CLR , true => INT_EVENT0_IMASK_INTR_OVFL_A :: INT_EVENT0_IMASK_INTR_OVFL_SET , } } # [doc = "CLR"] # [inline (always)] pub fn is_int_event0_imask_intr_ovfl_clr (& self) -> bool { * self == INT_EVENT0_IMASK_INTR_OVFL_A :: INT_EVENT0_IMASK_INTR_OVFL_CLR } # [doc = "SET"] # [inline (always)] pub fn is_int_event0_imask_intr_ovfl_set (& self) -> bool { * self == INT_EVENT0_IMASK_INTR_OVFL_A :: INT_EVENT0_IMASK_INTR_OVFL_SET } } # [doc = "Field `INT_EVENT0_IMASK_INTR_OVFL` writer - Interrupt Overflow Interrupt Mask"] pub type INT_EVENT0_IMASK_INTR_OVFL_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_IMASK_INTR_OVFL_A > ; impl < 'a , REG , const O : u8 > INT_EVENT0_IMASK_INTR_OVFL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CLR"] # [inline (always)] pub fn int_event0_imask_intr_ovfl_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_INTR_OVFL_A :: INT_EVENT0_IMASK_INTR_OVFL_CLR) } # [doc = "SET"] # [inline (always)] pub fn int_event0_imask_intr_ovfl_set (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_IMASK_INTR_OVFL_A :: INT_EVENT0_IMASK_INTR_OVFL_SET) } } impl R { # [doc = "Bit 0 - Master Receive Transaction completed Interrupt"] # [inline (always)] pub fn int_event0_imask_mrxdone (& self) -> INT_EVENT0_IMASK_MRXDONE_R { INT_EVENT0_IMASK_MRXDONE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Master Transmit Transaction completed Interrupt"] # [inline (always)] pub fn int_event0_imask_mtxdone (& self) -> INT_EVENT0_IMASK_MTXDONE_R { INT_EVENT0_IMASK_MTXDONE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Master Receive FIFO Trigger Trigger when RX FIFO contains &amp;gt;= defined bytes"] # [inline (always)] pub fn int_event0_imask_mrxfifotrg (& self) -> INT_EVENT0_IMASK_MRXFIFOTRG_R { INT_EVENT0_IMASK_MRXFIFOTRG_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Master Transmit FIFO Trigger Trigger when Transmit FIFO contains &amp;lt;= defined bytes"] # [inline (always)] pub fn int_event0_imask_mtxfifotrg (& self) -> INT_EVENT0_IMASK_MTXFIFOTRG_R { INT_EVENT0_IMASK_MTXFIFOTRG_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - RXFIFO full event. This interrupt is set if an RX FIFO is full."] # [inline (always)] pub fn int_event0_imask_mrxfifofull (& self) -> INT_EVENT0_IMASK_MRXFIFOFULL_R { INT_EVENT0_IMASK_MRXFIFOFULL_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode."] # [inline (always)] pub fn int_event0_imask_mtxempty (& self) -> INT_EVENT0_IMASK_MTXEMPTY_R { INT_EVENT0_IMASK_MTXEMPTY_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 7 - Address/Data NACK Interrupt"] # [inline (always)] pub fn int_event0_imask_mnack (& self) -> INT_EVENT0_IMASK_MNACK_R { INT_EVENT0_IMASK_MNACK_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - START Detection Interrupt"] # [inline (always)] pub fn int_event0_imask_mstart (& self) -> INT_EVENT0_IMASK_MSTART_R { INT_EVENT0_IMASK_MSTART_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - STOP Detection Interrupt"] # [inline (always)] pub fn int_event0_imask_mstop (& self) -> INT_EVENT0_IMASK_MSTOP_R { INT_EVENT0_IMASK_MSTOP_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Arbitration Lost Interrupt"] # [inline (always)] pub fn int_event0_imask_marblost (& self) -> INT_EVENT0_IMASK_MARBLOST_R { INT_EVENT0_IMASK_MARBLOST_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - DMA Done 1 on Event Channel 2"] # [inline (always)] pub fn int_event0_imask_mdma_done1_2 (& self) -> INT_EVENT0_IMASK_MDMA_DONE1_2_R { INT_EVENT0_IMASK_MDMA_DONE1_2_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - DMA Done 1 on Event Channel 3"] # [inline (always)] pub fn int_event0_imask_mdma_done1_3 (& self) -> INT_EVENT0_IMASK_MDMA_DONE1_3_R { INT_EVENT0_IMASK_MDMA_DONE1_3_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Master RX Pec Error Interrupt"] # [inline (always)] pub fn int_event0_imask_mpec_rx_err (& self) -> INT_EVENT0_IMASK_MPEC_RX_ERR_R { INT_EVENT0_IMASK_MPEC_RX_ERR_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Timeout A Interrupt"] # [inline (always)] pub fn int_event0_imask_timeouta (& self) -> INT_EVENT0_IMASK_TIMEOUTA_R { INT_EVENT0_IMASK_TIMEOUTA_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Timeout B Interrupt"] # [inline (always)] pub fn int_event0_imask_timeoutb (& self) -> INT_EVENT0_IMASK_TIMEOUTB_R { INT_EVENT0_IMASK_TIMEOUTB_R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - Slave Receive Data Interrupt Signals that a byte has been received"] # [inline (always)] pub fn int_event0_imask_srxdone (& self) -> INT_EVENT0_IMASK_SRXDONE_R { INT_EVENT0_IMASK_SRXDONE_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Slave Transmit Transaction completed Interrupt"] # [inline (always)] pub fn int_event0_imask_stxdone (& self) -> INT_EVENT0_IMASK_STXDONE_R { INT_EVENT0_IMASK_STXDONE_R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Slave Receive FIFO Trigger"] # [inline (always)] pub fn int_event0_imask_srxfifotrg (& self) -> INT_EVENT0_IMASK_SRXFIFOTRG_R { INT_EVENT0_IMASK_SRXFIFOTRG_R :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Slave Transmit FIFO Trigger"] # [inline (always)] pub fn int_event0_imask_stxfifotrg (& self) -> INT_EVENT0_IMASK_STXFIFOTRG_R { INT_EVENT0_IMASK_STXFIFOTRG_R :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 20 - RXFIFO full event. This interrupt is set if an Slave RX FIFO is full."] # [inline (always)] pub fn int_event0_imask_srxfifofull (& self) -> INT_EVENT0_IMASK_SRXFIFOFULL_R { INT_EVENT0_IMASK_SRXFIFOFULL_R :: new (((self . bits >> 20) & 1) != 0) } # [doc = "Bit 21 - Slave Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode."] # [inline (always)] pub fn int_event0_imask_stxempty (& self) -> INT_EVENT0_IMASK_STXEMPTY_R { INT_EVENT0_IMASK_STXEMPTY_R :: new (((self . bits >> 21) & 1) != 0) } # [doc = "Bit 22 - Start Condition Interrupt"] # [inline (always)] pub fn int_event0_imask_sstart (& self) -> INT_EVENT0_IMASK_SSTART_R { INT_EVENT0_IMASK_SSTART_R :: new (((self . bits >> 22) & 1) != 0) } # [doc = "Bit 23 - Stop Condition Interrupt"] # [inline (always)] pub fn int_event0_imask_sstop (& self) -> INT_EVENT0_IMASK_SSTOP_R { INT_EVENT0_IMASK_SSTOP_R :: new (((self . bits >> 23) & 1) != 0) } # [doc = "Bit 24 - General Call Interrupt"] # [inline (always)] pub fn int_event0_imask_sgencall (& self) -> INT_EVENT0_IMASK_SGENCALL_R { INT_EVENT0_IMASK_SGENCALL_R :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 25 - Slave DMA Done 1 on Event Channel 2"] # [inline (always)] pub fn int_event0_imask_sdma_done1_2 (& self) -> INT_EVENT0_IMASK_SDMA_DONE1_2_R { INT_EVENT0_IMASK_SDMA_DONE1_2_R :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - Slave DMA Done 1 on Event Channel 3"] # [inline (always)] pub fn int_event0_imask_sdma_done1_3 (& self) -> INT_EVENT0_IMASK_SDMA_DONE1_3_R { INT_EVENT0_IMASK_SDMA_DONE1_3_R :: new (((self . bits >> 26) & 1) != 0) } # [doc = "Bit 27 - Slave RX Pec Error Interrupt"] # [inline (always)] pub fn int_event0_imask_spec_rx_err (& self) -> INT_EVENT0_IMASK_SPEC_RX_ERR_R { INT_EVENT0_IMASK_SPEC_RX_ERR_R :: new (((self . bits >> 27) & 1) != 0) } # [doc = "Bit 28 - Slave TX FIFO underflow"] # [inline (always)] pub fn int_event0_imask_stx_unfl (& self) -> INT_EVENT0_IMASK_STX_UNFL_R { INT_EVENT0_IMASK_STX_UNFL_R :: new (((self . bits >> 28) & 1) != 0) } # [doc = "Bit 29 - Slave RX FIFO overflow"] # [inline (always)] pub fn int_event0_imask_srx_ovfl (& self) -> INT_EVENT0_IMASK_SRX_OVFL_R { INT_EVENT0_IMASK_SRX_OVFL_R :: new (((self . bits >> 29) & 1) != 0) } # [doc = "Bit 30 - Slave Arbitration Lost"] # [inline (always)] pub fn int_event0_imask_sarblost (& self) -> INT_EVENT0_IMASK_SARBLOST_R { INT_EVENT0_IMASK_SARBLOST_R :: new (((self . bits >> 30) & 1) != 0) } # [doc = "Bit 31 - Interrupt Overflow Interrupt Mask"] # [inline (always)] pub fn int_event0_imask_intr_ovfl (& self) -> INT_EVENT0_IMASK_INTR_OVFL_R { INT_EVENT0_IMASK_INTR_OVFL_R :: new (((self . bits >> 31) & 1) != 0) } } impl W { # [doc = "Bit 0 - Master Receive Transaction completed Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_imask_mrxdone (& mut self) -> INT_EVENT0_IMASK_MRXDONE_W < INT_EVENT0_IMASK_SPEC , 0 > { INT_EVENT0_IMASK_MRXDONE_W :: new (self) } # [doc = "Bit 1 - Master Transmit Transaction completed Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_imask_mtxdone (& mut self) -> INT_EVENT0_IMASK_MTXDONE_W < INT_EVENT0_IMASK_SPEC , 1 > { INT_EVENT0_IMASK_MTXDONE_W :: new (self) } # [doc = "Bit 2 - Master Receive FIFO Trigger Trigger when RX FIFO contains &amp;gt;= defined bytes"] # [inline (always)] # [must_use] pub fn int_event0_imask_mrxfifotrg (& mut self) -> INT_EVENT0_IMASK_MRXFIFOTRG_W < INT_EVENT0_IMASK_SPEC , 2 > { INT_EVENT0_IMASK_MRXFIFOTRG_W :: new (self) } # [doc = "Bit 3 - Master Transmit FIFO Trigger Trigger when Transmit FIFO contains &amp;lt;= defined bytes"] # [inline (always)] # [must_use] pub fn int_event0_imask_mtxfifotrg (& mut self) -> INT_EVENT0_IMASK_MTXFIFOTRG_W < INT_EVENT0_IMASK_SPEC , 3 > { INT_EVENT0_IMASK_MTXFIFOTRG_W :: new (self) } # [doc = "Bit 4 - RXFIFO full event. This interrupt is set if an RX FIFO is full."] # [inline (always)] # [must_use] pub fn int_event0_imask_mrxfifofull (& mut self) -> INT_EVENT0_IMASK_MRXFIFOFULL_W < INT_EVENT0_IMASK_SPEC , 4 > { INT_EVENT0_IMASK_MRXFIFOFULL_W :: new (self) } # [doc = "Bit 5 - Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode."] # [inline (always)] # [must_use] pub fn int_event0_imask_mtxempty (& mut self) -> INT_EVENT0_IMASK_MTXEMPTY_W < INT_EVENT0_IMASK_SPEC , 5 > { INT_EVENT0_IMASK_MTXEMPTY_W :: new (self) } # [doc = "Bit 7 - Address/Data NACK Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_imask_mnack (& mut self) -> INT_EVENT0_IMASK_MNACK_W < INT_EVENT0_IMASK_SPEC , 7 > { INT_EVENT0_IMASK_MNACK_W :: new (self) } # [doc = "Bit 8 - START Detection Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_imask_mstart (& mut self) -> INT_EVENT0_IMASK_MSTART_W < INT_EVENT0_IMASK_SPEC , 8 > { INT_EVENT0_IMASK_MSTART_W :: new (self) } # [doc = "Bit 9 - STOP Detection Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_imask_mstop (& mut self) -> INT_EVENT0_IMASK_MSTOP_W < INT_EVENT0_IMASK_SPEC , 9 > { INT_EVENT0_IMASK_MSTOP_W :: new (self) } # [doc = "Bit 10 - Arbitration Lost Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_imask_marblost (& mut self) -> INT_EVENT0_IMASK_MARBLOST_W < INT_EVENT0_IMASK_SPEC , 10 > { INT_EVENT0_IMASK_MARBLOST_W :: new (self) } # [doc = "Bit 11 - DMA Done 1 on Event Channel 2"] # [inline (always)] # [must_use] pub fn int_event0_imask_mdma_done1_2 (& mut self) -> INT_EVENT0_IMASK_MDMA_DONE1_2_W < INT_EVENT0_IMASK_SPEC , 11 > { INT_EVENT0_IMASK_MDMA_DONE1_2_W :: new (self) } # [doc = "Bit 12 - DMA Done 1 on Event Channel 3"] # [inline (always)] # [must_use] pub fn int_event0_imask_mdma_done1_3 (& mut self) -> INT_EVENT0_IMASK_MDMA_DONE1_3_W < INT_EVENT0_IMASK_SPEC , 12 > { INT_EVENT0_IMASK_MDMA_DONE1_3_W :: new (self) } # [doc = "Bit 13 - Master RX Pec Error Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_imask_mpec_rx_err (& mut self) -> INT_EVENT0_IMASK_MPEC_RX_ERR_W < INT_EVENT0_IMASK_SPEC , 13 > { INT_EVENT0_IMASK_MPEC_RX_ERR_W :: new (self) } # [doc = "Bit 14 - Timeout A Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_imask_timeouta (& mut self) -> INT_EVENT0_IMASK_TIMEOUTA_W < INT_EVENT0_IMASK_SPEC , 14 > { INT_EVENT0_IMASK_TIMEOUTA_W :: new (self) } # [doc = "Bit 15 - Timeout B Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_imask_timeoutb (& mut self) -> INT_EVENT0_IMASK_TIMEOUTB_W < INT_EVENT0_IMASK_SPEC , 15 > { INT_EVENT0_IMASK_TIMEOUTB_W :: new (self) } # [doc = "Bit 16 - Slave Receive Data Interrupt Signals that a byte has been received"] # [inline (always)] # [must_use] pub fn int_event0_imask_srxdone (& mut self) -> INT_EVENT0_IMASK_SRXDONE_W < INT_EVENT0_IMASK_SPEC , 16 > { INT_EVENT0_IMASK_SRXDONE_W :: new (self) } # [doc = "Bit 17 - Slave Transmit Transaction completed Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_imask_stxdone (& mut self) -> INT_EVENT0_IMASK_STXDONE_W < INT_EVENT0_IMASK_SPEC , 17 > { INT_EVENT0_IMASK_STXDONE_W :: new (self) } # [doc = "Bit 18 - Slave Receive FIFO Trigger"] # [inline (always)] # [must_use] pub fn int_event0_imask_srxfifotrg (& mut self) -> INT_EVENT0_IMASK_SRXFIFOTRG_W < INT_EVENT0_IMASK_SPEC , 18 > { INT_EVENT0_IMASK_SRXFIFOTRG_W :: new (self) } # [doc = "Bit 19 - Slave Transmit FIFO Trigger"] # [inline (always)] # [must_use] pub fn int_event0_imask_stxfifotrg (& mut self) -> INT_EVENT0_IMASK_STXFIFOTRG_W < INT_EVENT0_IMASK_SPEC , 19 > { INT_EVENT0_IMASK_STXFIFOTRG_W :: new (self) } # [doc = "Bit 20 - RXFIFO full event. This interrupt is set if an Slave RX FIFO is full."] # [inline (always)] # [must_use] pub fn int_event0_imask_srxfifofull (& mut self) -> INT_EVENT0_IMASK_SRXFIFOFULL_W < INT_EVENT0_IMASK_SPEC , 20 > { INT_EVENT0_IMASK_SRXFIFOFULL_W :: new (self) } # [doc = "Bit 21 - Slave Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode."] # [inline (always)] # [must_use] pub fn int_event0_imask_stxempty (& mut self) -> INT_EVENT0_IMASK_STXEMPTY_W < INT_EVENT0_IMASK_SPEC , 21 > { INT_EVENT0_IMASK_STXEMPTY_W :: new (self) } # [doc = "Bit 22 - Start Condition Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_imask_sstart (& mut self) -> INT_EVENT0_IMASK_SSTART_W < INT_EVENT0_IMASK_SPEC , 22 > { INT_EVENT0_IMASK_SSTART_W :: new (self) } # [doc = "Bit 23 - Stop Condition Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_imask_sstop (& mut self) -> INT_EVENT0_IMASK_SSTOP_W < INT_EVENT0_IMASK_SPEC , 23 > { INT_EVENT0_IMASK_SSTOP_W :: new (self) } # [doc = "Bit 24 - General Call Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_imask_sgencall (& mut self) -> INT_EVENT0_IMASK_SGENCALL_W < INT_EVENT0_IMASK_SPEC , 24 > { INT_EVENT0_IMASK_SGENCALL_W :: new (self) } # [doc = "Bit 25 - Slave DMA Done 1 on Event Channel 2"] # [inline (always)] # [must_use] pub fn int_event0_imask_sdma_done1_2 (& mut self) -> INT_EVENT0_IMASK_SDMA_DONE1_2_W < INT_EVENT0_IMASK_SPEC , 25 > { INT_EVENT0_IMASK_SDMA_DONE1_2_W :: new (self) } # [doc = "Bit 26 - Slave DMA Done 1 on Event Channel 3"] # [inline (always)] # [must_use] pub fn int_event0_imask_sdma_done1_3 (& mut self) -> INT_EVENT0_IMASK_SDMA_DONE1_3_W < INT_EVENT0_IMASK_SPEC , 26 > { INT_EVENT0_IMASK_SDMA_DONE1_3_W :: new (self) } # [doc = "Bit 27 - Slave RX Pec Error Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_imask_spec_rx_err (& mut self) -> INT_EVENT0_IMASK_SPEC_RX_ERR_W < INT_EVENT0_IMASK_SPEC , 27 > { INT_EVENT0_IMASK_SPEC_RX_ERR_W :: new (self) } # [doc = "Bit 28 - Slave TX FIFO underflow"] # [inline (always)] # [must_use] pub fn int_event0_imask_stx_unfl (& mut self) -> INT_EVENT0_IMASK_STX_UNFL_W < INT_EVENT0_IMASK_SPEC , 28 > { INT_EVENT0_IMASK_STX_UNFL_W :: new (self) } # [doc = "Bit 29 - Slave RX FIFO overflow"] # [inline (always)] # [must_use] pub fn int_event0_imask_srx_ovfl (& mut self) -> INT_EVENT0_IMASK_SRX_OVFL_W < INT_EVENT0_IMASK_SPEC , 29 > { INT_EVENT0_IMASK_SRX_OVFL_W :: new (self) } # [doc = "Bit 30 - Slave Arbitration Lost"] # [inline (always)] # [must_use] pub fn int_event0_imask_sarblost (& mut self) -> INT_EVENT0_IMASK_SARBLOST_W < INT_EVENT0_IMASK_SPEC , 30 > { INT_EVENT0_IMASK_SARBLOST_W :: new (self) } # [doc = "Bit 31 - Interrupt Overflow Interrupt Mask"] # [inline (always)] # [must_use] pub fn int_event0_imask_intr_ovfl (& mut self) -> INT_EVENT0_IMASK_INTR_OVFL_W < INT_EVENT0_IMASK_SPEC , 31 > { INT_EVENT0_IMASK_INTR_OVFL_W :: new (self) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Interrupt mask\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`int_event0_imask::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_event0_imask::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT_EVENT0_IMASK_SPEC ; impl crate :: RegisterSpec for INT_EVENT0_IMASK_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`int_event0_imask::R`](R) reader structure"] impl crate :: Readable for INT_EVENT0_IMASK_SPEC { } # [doc = "`write(|w| ..)` method takes [`int_event0_imask::W`](W) writer structure"] impl crate :: Writable for INT_EVENT0_IMASK_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT_EVENT0_IMASK to value 0"] impl crate :: Resettable for INT_EVENT0_IMASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }