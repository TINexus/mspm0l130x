# [doc = "Register `INT_EVENT0_ICLR` writer"] pub type W = crate :: W < INT_EVENT0_ICLR_SPEC > ; # [doc = "Master Receive Data Interrupt Signals that a byte has been received\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_MRXDONE_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_MRXDONE_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_MRXDONE_CLR = 1 , } impl From < INT_EVENT0_ICLR_MRXDONE_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_MRXDONE_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_MRXDONE` writer - Master Receive Data Interrupt Signals that a byte has been received"] pub type INT_EVENT0_ICLR_MRXDONE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_MRXDONE_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_MRXDONE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_mrxdone_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MRXDONE_AW :: INT_EVENT0_ICLR_MRXDONE_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_mrxdone_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MRXDONE_AW :: INT_EVENT0_ICLR_MRXDONE_CLR) } } # [doc = "Master Transmit Transaction completed Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_MTXDONE_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_MTXDONE_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_MTXDONE_CLR = 1 , } impl From < INT_EVENT0_ICLR_MTXDONE_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_MTXDONE_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_MTXDONE` writer - Master Transmit Transaction completed Interrupt"] pub type INT_EVENT0_ICLR_MTXDONE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_MTXDONE_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_MTXDONE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_mtxdone_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MTXDONE_AW :: INT_EVENT0_ICLR_MTXDONE_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_mtxdone_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MTXDONE_AW :: INT_EVENT0_ICLR_MTXDONE_CLR) } } # [doc = "Master Receive FIFO Trigger Trigger when RX FIFO contains &amp;gt;= defined bytes\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_MRXFIFOTRG_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_MRXFIFOTRG_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_MRXFIFOTRG_CLR = 1 , } impl From < INT_EVENT0_ICLR_MRXFIFOTRG_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_MRXFIFOTRG_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_MRXFIFOTRG` writer - Master Receive FIFO Trigger Trigger when RX FIFO contains &amp;gt;= defined bytes"] pub type INT_EVENT0_ICLR_MRXFIFOTRG_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_MRXFIFOTRG_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_MRXFIFOTRG_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_mrxfifotrg_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MRXFIFOTRG_AW :: INT_EVENT0_ICLR_MRXFIFOTRG_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_mrxfifotrg_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MRXFIFOTRG_AW :: INT_EVENT0_ICLR_MRXFIFOTRG_CLR) } } # [doc = "Master Transmit FIFO Trigger Trigger when Transmit FIFO contains &amp;lt;= defined bytes\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_MTXFIFOTRG_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_MTXFIFOTRG_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_MTXFIFOTRG_CLR = 1 , } impl From < INT_EVENT0_ICLR_MTXFIFOTRG_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_MTXFIFOTRG_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_MTXFIFOTRG` writer - Master Transmit FIFO Trigger Trigger when Transmit FIFO contains &amp;lt;= defined bytes"] pub type INT_EVENT0_ICLR_MTXFIFOTRG_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_MTXFIFOTRG_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_MTXFIFOTRG_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_mtxfifotrg_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MTXFIFOTRG_AW :: INT_EVENT0_ICLR_MTXFIFOTRG_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_mtxfifotrg_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MTXFIFOTRG_AW :: INT_EVENT0_ICLR_MTXFIFOTRG_CLR) } } # [doc = "RXFIFO full event.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_MRXFIFOFULL_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_MRXFIFOFULL_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_MRXFIFOFULL_CLR = 1 , } impl From < INT_EVENT0_ICLR_MRXFIFOFULL_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_MRXFIFOFULL_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_MRXFIFOFULL` writer - RXFIFO full event."] pub type INT_EVENT0_ICLR_MRXFIFOFULL_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_MRXFIFOFULL_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_MRXFIFOFULL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_mrxfifofull_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MRXFIFOFULL_AW :: INT_EVENT0_ICLR_MRXFIFOFULL_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_mrxfifofull_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MRXFIFOFULL_AW :: INT_EVENT0_ICLR_MRXFIFOFULL_CLR) } } # [doc = "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_MTXEMPTY_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_MTXEMPTY_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_MTXEMPTY_CLR = 1 , } impl From < INT_EVENT0_ICLR_MTXEMPTY_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_MTXEMPTY_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_MTXEMPTY` writer - Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode."] pub type INT_EVENT0_ICLR_MTXEMPTY_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_MTXEMPTY_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_MTXEMPTY_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_mtxempty_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MTXEMPTY_AW :: INT_EVENT0_ICLR_MTXEMPTY_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_mtxempty_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MTXEMPTY_AW :: INT_EVENT0_ICLR_MTXEMPTY_CLR) } } # [doc = "Address/Data NACK Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_MNACK_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_MNACK_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_MNACK_CLR = 1 , } impl From < INT_EVENT0_ICLR_MNACK_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_MNACK_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_MNACK` writer - Address/Data NACK Interrupt"] pub type INT_EVENT0_ICLR_MNACK_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_MNACK_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_MNACK_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_mnack_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MNACK_AW :: INT_EVENT0_ICLR_MNACK_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_mnack_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MNACK_AW :: INT_EVENT0_ICLR_MNACK_CLR) } } # [doc = "START Detection Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_MSTART_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_MSTART_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_MSTART_CLR = 1 , } impl From < INT_EVENT0_ICLR_MSTART_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_MSTART_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_MSTART` writer - START Detection Interrupt"] pub type INT_EVENT0_ICLR_MSTART_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_MSTART_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_MSTART_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_mstart_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MSTART_AW :: INT_EVENT0_ICLR_MSTART_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_mstart_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MSTART_AW :: INT_EVENT0_ICLR_MSTART_CLR) } } # [doc = "STOP Detection Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_MSTOP_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_MSTOP_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_MSTOP_CLR = 1 , } impl From < INT_EVENT0_ICLR_MSTOP_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_MSTOP_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_MSTOP` writer - STOP Detection Interrupt"] pub type INT_EVENT0_ICLR_MSTOP_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_MSTOP_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_MSTOP_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_mstop_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MSTOP_AW :: INT_EVENT0_ICLR_MSTOP_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_mstop_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MSTOP_AW :: INT_EVENT0_ICLR_MSTOP_CLR) } } # [doc = "Arbitration Lost Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_MARBLOST_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_MARBLOST_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_MARBLOST_CLR = 1 , } impl From < INT_EVENT0_ICLR_MARBLOST_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_MARBLOST_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_MARBLOST` writer - Arbitration Lost Interrupt"] pub type INT_EVENT0_ICLR_MARBLOST_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_MARBLOST_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_MARBLOST_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_marblost_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MARBLOST_AW :: INT_EVENT0_ICLR_MARBLOST_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_marblost_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MARBLOST_AW :: INT_EVENT0_ICLR_MARBLOST_CLR) } } # [doc = "DMA Done 1 on Event Channel 2\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_MDMA_DONE1_2_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_MDMA_DONE1_2_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_MDMA_DONE1_2_CLR = 1 , } impl From < INT_EVENT0_ICLR_MDMA_DONE1_2_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_MDMA_DONE1_2_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_MDMA_DONE1_2` writer - DMA Done 1 on Event Channel 2"] pub type INT_EVENT0_ICLR_MDMA_DONE1_2_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_MDMA_DONE1_2_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_MDMA_DONE1_2_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_mdma_done1_2_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MDMA_DONE1_2_AW :: INT_EVENT0_ICLR_MDMA_DONE1_2_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_mdma_done1_2_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MDMA_DONE1_2_AW :: INT_EVENT0_ICLR_MDMA_DONE1_2_CLR) } } # [doc = "DMA Done 1 on Event Channel 3\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_MDMA_DONE1_3_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_MDMA_DONE1_3_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_MDMA_DONE1_3_CLR = 1 , } impl From < INT_EVENT0_ICLR_MDMA_DONE1_3_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_MDMA_DONE1_3_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_MDMA_DONE1_3` writer - DMA Done 1 on Event Channel 3"] pub type INT_EVENT0_ICLR_MDMA_DONE1_3_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_MDMA_DONE1_3_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_MDMA_DONE1_3_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_mdma_done1_3_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MDMA_DONE1_3_AW :: INT_EVENT0_ICLR_MDMA_DONE1_3_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_mdma_done1_3_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MDMA_DONE1_3_AW :: INT_EVENT0_ICLR_MDMA_DONE1_3_CLR) } } # [doc = "Master RX Pec Error Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_MPEC_RX_ERR_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_MPEC_RX_ERR_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_MPEC_RX_ERR_CLR = 1 , } impl From < INT_EVENT0_ICLR_MPEC_RX_ERR_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_MPEC_RX_ERR_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_MPEC_RX_ERR` writer - Master RX Pec Error Interrupt"] pub type INT_EVENT0_ICLR_MPEC_RX_ERR_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_MPEC_RX_ERR_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_MPEC_RX_ERR_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_mpec_rx_err_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MPEC_RX_ERR_AW :: INT_EVENT0_ICLR_MPEC_RX_ERR_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_mpec_rx_err_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_MPEC_RX_ERR_AW :: INT_EVENT0_ICLR_MPEC_RX_ERR_CLR) } } # [doc = "Timeout A interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_TIMEOUTA_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_TIMEOUTA_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_TIMEOUTA_CLR = 1 , } impl From < INT_EVENT0_ICLR_TIMEOUTA_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_TIMEOUTA_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_TIMEOUTA` writer - Timeout A interrupt"] pub type INT_EVENT0_ICLR_TIMEOUTA_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_TIMEOUTA_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_TIMEOUTA_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_timeouta_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_TIMEOUTA_AW :: INT_EVENT0_ICLR_TIMEOUTA_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_timeouta_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_TIMEOUTA_AW :: INT_EVENT0_ICLR_TIMEOUTA_CLR) } } # [doc = "Timeout B Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_TIMEOUTB_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_TIMEOUTB_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_TIMEOUTB_CLR = 1 , } impl From < INT_EVENT0_ICLR_TIMEOUTB_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_TIMEOUTB_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_TIMEOUTB` writer - Timeout B Interrupt"] pub type INT_EVENT0_ICLR_TIMEOUTB_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_TIMEOUTB_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_TIMEOUTB_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_timeoutb_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_TIMEOUTB_AW :: INT_EVENT0_ICLR_TIMEOUTB_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_timeoutb_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_TIMEOUTB_AW :: INT_EVENT0_ICLR_TIMEOUTB_CLR) } } # [doc = "Slave Receive Data Interrupt Signals that a byte has been received\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_SRXDONE_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_SRXDONE_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_SRXDONE_CLR = 1 , } impl From < INT_EVENT0_ICLR_SRXDONE_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_SRXDONE_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_SRXDONE` writer - Slave Receive Data Interrupt Signals that a byte has been received"] pub type INT_EVENT0_ICLR_SRXDONE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_SRXDONE_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_SRXDONE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_srxdone_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_SRXDONE_AW :: INT_EVENT0_ICLR_SRXDONE_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_srxdone_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_SRXDONE_AW :: INT_EVENT0_ICLR_SRXDONE_CLR) } } # [doc = "Slave Transmit Transaction completed Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_STXDONE_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_STXDONE_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_STXDONE_CLR = 1 , } impl From < INT_EVENT0_ICLR_STXDONE_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_STXDONE_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_STXDONE` writer - Slave Transmit Transaction completed Interrupt"] pub type INT_EVENT0_ICLR_STXDONE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_STXDONE_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_STXDONE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_stxdone_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_STXDONE_AW :: INT_EVENT0_ICLR_STXDONE_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_stxdone_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_STXDONE_AW :: INT_EVENT0_ICLR_STXDONE_CLR) } } # [doc = "Slave Receive FIFO Trigger\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_SRXFIFOTRG_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_SRXFIFOTRG_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_SRXFIFOTRG_CLR = 1 , } impl From < INT_EVENT0_ICLR_SRXFIFOTRG_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_SRXFIFOTRG_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_SRXFIFOTRG` writer - Slave Receive FIFO Trigger"] pub type INT_EVENT0_ICLR_SRXFIFOTRG_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_SRXFIFOTRG_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_SRXFIFOTRG_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_srxfifotrg_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_SRXFIFOTRG_AW :: INT_EVENT0_ICLR_SRXFIFOTRG_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_srxfifotrg_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_SRXFIFOTRG_AW :: INT_EVENT0_ICLR_SRXFIFOTRG_CLR) } } # [doc = "Slave Transmit FIFO Trigger\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_STXFIFOTRG_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_STXFIFOTRG_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_STXFIFOTRG_CLR = 1 , } impl From < INT_EVENT0_ICLR_STXFIFOTRG_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_STXFIFOTRG_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_STXFIFOTRG` writer - Slave Transmit FIFO Trigger"] pub type INT_EVENT0_ICLR_STXFIFOTRG_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_STXFIFOTRG_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_STXFIFOTRG_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_stxfifotrg_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_STXFIFOTRG_AW :: INT_EVENT0_ICLR_STXFIFOTRG_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_stxfifotrg_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_STXFIFOTRG_AW :: INT_EVENT0_ICLR_STXFIFOTRG_CLR) } } # [doc = "RXFIFO full event. This interrupt is set if an RX FIFO is full.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_SRXFIFOFULL_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_SRXFIFOFULL_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_SRXFIFOFULL_CLR = 1 , } impl From < INT_EVENT0_ICLR_SRXFIFOFULL_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_SRXFIFOFULL_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_SRXFIFOFULL` writer - RXFIFO full event. This interrupt is set if an RX FIFO is full."] pub type INT_EVENT0_ICLR_SRXFIFOFULL_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_SRXFIFOFULL_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_SRXFIFOFULL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_srxfifofull_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_SRXFIFOFULL_AW :: INT_EVENT0_ICLR_SRXFIFOFULL_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_srxfifofull_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_SRXFIFOFULL_AW :: INT_EVENT0_ICLR_SRXFIFOFULL_CLR) } } # [doc = "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_STXEMPTY_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_STXEMPTY_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_STXEMPTY_CLR = 1 , } impl From < INT_EVENT0_ICLR_STXEMPTY_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_STXEMPTY_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_STXEMPTY` writer - Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode."] pub type INT_EVENT0_ICLR_STXEMPTY_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_STXEMPTY_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_STXEMPTY_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_stxempty_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_STXEMPTY_AW :: INT_EVENT0_ICLR_STXEMPTY_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_stxempty_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_STXEMPTY_AW :: INT_EVENT0_ICLR_STXEMPTY_CLR) } } # [doc = "Slave START Detection Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_SSTART_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_SSTART_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_SSTART_CLR = 1 , } impl From < INT_EVENT0_ICLR_SSTART_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_SSTART_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_SSTART` writer - Slave START Detection Interrupt"] pub type INT_EVENT0_ICLR_SSTART_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_SSTART_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_SSTART_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_sstart_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_SSTART_AW :: INT_EVENT0_ICLR_SSTART_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_sstart_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_SSTART_AW :: INT_EVENT0_ICLR_SSTART_CLR) } } # [doc = "Slave STOP Detection Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_SSTOP_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_SSTOP_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_SSTOP_CLR = 1 , } impl From < INT_EVENT0_ICLR_SSTOP_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_SSTOP_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_SSTOP` writer - Slave STOP Detection Interrupt"] pub type INT_EVENT0_ICLR_SSTOP_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_SSTOP_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_SSTOP_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_sstop_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_SSTOP_AW :: INT_EVENT0_ICLR_SSTOP_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_sstop_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_SSTOP_AW :: INT_EVENT0_ICLR_SSTOP_CLR) } } # [doc = "General Call Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_SGENCALL_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_SGENCALL_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_SGENCALL_CLR = 1 , } impl From < INT_EVENT0_ICLR_SGENCALL_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_SGENCALL_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_SGENCALL` writer - General Call Interrupt"] pub type INT_EVENT0_ICLR_SGENCALL_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_SGENCALL_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_SGENCALL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_sgencall_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_SGENCALL_AW :: INT_EVENT0_ICLR_SGENCALL_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_sgencall_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_SGENCALL_AW :: INT_EVENT0_ICLR_SGENCALL_CLR) } } # [doc = "DMA Done 1 on Event Channel 2\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_SDMA_DONE1_2_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_SDMA_DONE1_2_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_SDMA_DONE1_2_CLR = 1 , } impl From < INT_EVENT0_ICLR_SDMA_DONE1_2_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_SDMA_DONE1_2_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_SDMA_DONE1_2` writer - DMA Done 1 on Event Channel 2"] pub type INT_EVENT0_ICLR_SDMA_DONE1_2_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_SDMA_DONE1_2_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_SDMA_DONE1_2_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_sdma_done1_2_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_SDMA_DONE1_2_AW :: INT_EVENT0_ICLR_SDMA_DONE1_2_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_sdma_done1_2_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_SDMA_DONE1_2_AW :: INT_EVENT0_ICLR_SDMA_DONE1_2_CLR) } } # [doc = "DMA Done 1 on Event Channel 3\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_SDMA_DONE1_3_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_SDMA_DONE1_3_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_SDMA_DONE1_3_CLR = 1 , } impl From < INT_EVENT0_ICLR_SDMA_DONE1_3_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_SDMA_DONE1_3_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_SDMA_DONE1_3` writer - DMA Done 1 on Event Channel 3"] pub type INT_EVENT0_ICLR_SDMA_DONE1_3_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_SDMA_DONE1_3_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_SDMA_DONE1_3_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_sdma_done1_3_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_SDMA_DONE1_3_AW :: INT_EVENT0_ICLR_SDMA_DONE1_3_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_sdma_done1_3_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_SDMA_DONE1_3_AW :: INT_EVENT0_ICLR_SDMA_DONE1_3_CLR) } } # [doc = "Slave RX Pec Error Interrupt\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_SPEC_RX_ERR_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_SPEC_RX_ERR_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_SPEC_RX_ERR_CLR = 1 , } impl From < INT_EVENT0_ICLR_SPEC_RX_ERR_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_SPEC_RX_ERR_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_SPEC_RX_ERR` writer - Slave RX Pec Error Interrupt"] pub type INT_EVENT0_ICLR_SPEC_RX_ERR_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_SPEC_RX_ERR_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_SPEC_RX_ERR_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_spec_rx_err_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_SPEC_RX_ERR_AW :: INT_EVENT0_ICLR_SPEC_RX_ERR_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_spec_rx_err_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_SPEC_RX_ERR_AW :: INT_EVENT0_ICLR_SPEC_RX_ERR_CLR) } } # [doc = "Slave TX FIFO underflow\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_STX_UNFL_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_STX_UNFL_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_STX_UNFL_CLR = 1 , } impl From < INT_EVENT0_ICLR_STX_UNFL_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_STX_UNFL_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_STX_UNFL` writer - Slave TX FIFO underflow"] pub type INT_EVENT0_ICLR_STX_UNFL_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_STX_UNFL_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_STX_UNFL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_stx_unfl_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_STX_UNFL_AW :: INT_EVENT0_ICLR_STX_UNFL_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_stx_unfl_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_STX_UNFL_AW :: INT_EVENT0_ICLR_STX_UNFL_CLR) } } # [doc = "Slave RX FIFO overflow\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_SRX_OVFL_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_SRX_OVFL_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_SRX_OVFL_CLR = 1 , } impl From < INT_EVENT0_ICLR_SRX_OVFL_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_SRX_OVFL_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_SRX_OVFL` writer - Slave RX FIFO overflow"] pub type INT_EVENT0_ICLR_SRX_OVFL_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_SRX_OVFL_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_SRX_OVFL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_srx_ovfl_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_SRX_OVFL_AW :: INT_EVENT0_ICLR_SRX_OVFL_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_srx_ovfl_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_SRX_OVFL_AW :: INT_EVENT0_ICLR_SRX_OVFL_CLR) } } # [doc = "Slave Arbitration Lost\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_SARBLOST_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_SARBLOST_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_SARBLOST_CLR = 1 , } impl From < INT_EVENT0_ICLR_SARBLOST_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_SARBLOST_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_SARBLOST` writer - Slave Arbitration Lost"] pub type INT_EVENT0_ICLR_SARBLOST_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_SARBLOST_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_SARBLOST_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_sarblost_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_SARBLOST_AW :: INT_EVENT0_ICLR_SARBLOST_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_sarblost_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_SARBLOST_AW :: INT_EVENT0_ICLR_SARBLOST_CLR) } } # [doc = "Interrupt overflow\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum INT_EVENT0_ICLR_INTR_OVFL_AW { # [doc = "0: NO_EFFECT"] INT_EVENT0_ICLR_INTR_OVFL_NO_EFFECT = 0 , # [doc = "1: CLR"] INT_EVENT0_ICLR_INTR_OVFL_CLR = 1 , } impl From < INT_EVENT0_ICLR_INTR_OVFL_AW > for bool { # [inline (always)] fn from (variant : INT_EVENT0_ICLR_INTR_OVFL_AW) -> Self { variant as u8 != 0 } } # [doc = "Field `INT_EVENT0_ICLR_INTR_OVFL` writer - Interrupt overflow"] pub type INT_EVENT0_ICLR_INTR_OVFL_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , INT_EVENT0_ICLR_INTR_OVFL_AW > ; impl < 'a , REG , const O : u8 > INT_EVENT0_ICLR_INTR_OVFL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NO_EFFECT"] # [inline (always)] pub fn int_event0_iclr_intr_ovfl_no_effect (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_INTR_OVFL_AW :: INT_EVENT0_ICLR_INTR_OVFL_NO_EFFECT) } # [doc = "CLR"] # [inline (always)] pub fn int_event0_iclr_intr_ovfl_clr (self) -> & 'a mut crate :: W < REG > { self . variant (INT_EVENT0_ICLR_INTR_OVFL_AW :: INT_EVENT0_ICLR_INTR_OVFL_CLR) } } impl W { # [doc = "Bit 0 - Master Receive Data Interrupt Signals that a byte has been received"] # [inline (always)] # [must_use] pub fn int_event0_iclr_mrxdone (& mut self) -> INT_EVENT0_ICLR_MRXDONE_W < INT_EVENT0_ICLR_SPEC , 0 > { INT_EVENT0_ICLR_MRXDONE_W :: new (self) } # [doc = "Bit 1 - Master Transmit Transaction completed Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iclr_mtxdone (& mut self) -> INT_EVENT0_ICLR_MTXDONE_W < INT_EVENT0_ICLR_SPEC , 1 > { INT_EVENT0_ICLR_MTXDONE_W :: new (self) } # [doc = "Bit 2 - Master Receive FIFO Trigger Trigger when RX FIFO contains &amp;gt;= defined bytes"] # [inline (always)] # [must_use] pub fn int_event0_iclr_mrxfifotrg (& mut self) -> INT_EVENT0_ICLR_MRXFIFOTRG_W < INT_EVENT0_ICLR_SPEC , 2 > { INT_EVENT0_ICLR_MRXFIFOTRG_W :: new (self) } # [doc = "Bit 3 - Master Transmit FIFO Trigger Trigger when Transmit FIFO contains &amp;lt;= defined bytes"] # [inline (always)] # [must_use] pub fn int_event0_iclr_mtxfifotrg (& mut self) -> INT_EVENT0_ICLR_MTXFIFOTRG_W < INT_EVENT0_ICLR_SPEC , 3 > { INT_EVENT0_ICLR_MTXFIFOTRG_W :: new (self) } # [doc = "Bit 4 - RXFIFO full event."] # [inline (always)] # [must_use] pub fn int_event0_iclr_mrxfifofull (& mut self) -> INT_EVENT0_ICLR_MRXFIFOFULL_W < INT_EVENT0_ICLR_SPEC , 4 > { INT_EVENT0_ICLR_MRXFIFOFULL_W :: new (self) } # [doc = "Bit 5 - Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode."] # [inline (always)] # [must_use] pub fn int_event0_iclr_mtxempty (& mut self) -> INT_EVENT0_ICLR_MTXEMPTY_W < INT_EVENT0_ICLR_SPEC , 5 > { INT_EVENT0_ICLR_MTXEMPTY_W :: new (self) } # [doc = "Bit 7 - Address/Data NACK Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iclr_mnack (& mut self) -> INT_EVENT0_ICLR_MNACK_W < INT_EVENT0_ICLR_SPEC , 7 > { INT_EVENT0_ICLR_MNACK_W :: new (self) } # [doc = "Bit 8 - START Detection Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iclr_mstart (& mut self) -> INT_EVENT0_ICLR_MSTART_W < INT_EVENT0_ICLR_SPEC , 8 > { INT_EVENT0_ICLR_MSTART_W :: new (self) } # [doc = "Bit 9 - STOP Detection Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iclr_mstop (& mut self) -> INT_EVENT0_ICLR_MSTOP_W < INT_EVENT0_ICLR_SPEC , 9 > { INT_EVENT0_ICLR_MSTOP_W :: new (self) } # [doc = "Bit 10 - Arbitration Lost Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iclr_marblost (& mut self) -> INT_EVENT0_ICLR_MARBLOST_W < INT_EVENT0_ICLR_SPEC , 10 > { INT_EVENT0_ICLR_MARBLOST_W :: new (self) } # [doc = "Bit 11 - DMA Done 1 on Event Channel 2"] # [inline (always)] # [must_use] pub fn int_event0_iclr_mdma_done1_2 (& mut self) -> INT_EVENT0_ICLR_MDMA_DONE1_2_W < INT_EVENT0_ICLR_SPEC , 11 > { INT_EVENT0_ICLR_MDMA_DONE1_2_W :: new (self) } # [doc = "Bit 12 - DMA Done 1 on Event Channel 3"] # [inline (always)] # [must_use] pub fn int_event0_iclr_mdma_done1_3 (& mut self) -> INT_EVENT0_ICLR_MDMA_DONE1_3_W < INT_EVENT0_ICLR_SPEC , 12 > { INT_EVENT0_ICLR_MDMA_DONE1_3_W :: new (self) } # [doc = "Bit 13 - Master RX Pec Error Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iclr_mpec_rx_err (& mut self) -> INT_EVENT0_ICLR_MPEC_RX_ERR_W < INT_EVENT0_ICLR_SPEC , 13 > { INT_EVENT0_ICLR_MPEC_RX_ERR_W :: new (self) } # [doc = "Bit 14 - Timeout A interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iclr_timeouta (& mut self) -> INT_EVENT0_ICLR_TIMEOUTA_W < INT_EVENT0_ICLR_SPEC , 14 > { INT_EVENT0_ICLR_TIMEOUTA_W :: new (self) } # [doc = "Bit 15 - Timeout B Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iclr_timeoutb (& mut self) -> INT_EVENT0_ICLR_TIMEOUTB_W < INT_EVENT0_ICLR_SPEC , 15 > { INT_EVENT0_ICLR_TIMEOUTB_W :: new (self) } # [doc = "Bit 16 - Slave Receive Data Interrupt Signals that a byte has been received"] # [inline (always)] # [must_use] pub fn int_event0_iclr_srxdone (& mut self) -> INT_EVENT0_ICLR_SRXDONE_W < INT_EVENT0_ICLR_SPEC , 16 > { INT_EVENT0_ICLR_SRXDONE_W :: new (self) } # [doc = "Bit 17 - Slave Transmit Transaction completed Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iclr_stxdone (& mut self) -> INT_EVENT0_ICLR_STXDONE_W < INT_EVENT0_ICLR_SPEC , 17 > { INT_EVENT0_ICLR_STXDONE_W :: new (self) } # [doc = "Bit 18 - Slave Receive FIFO Trigger"] # [inline (always)] # [must_use] pub fn int_event0_iclr_srxfifotrg (& mut self) -> INT_EVENT0_ICLR_SRXFIFOTRG_W < INT_EVENT0_ICLR_SPEC , 18 > { INT_EVENT0_ICLR_SRXFIFOTRG_W :: new (self) } # [doc = "Bit 19 - Slave Transmit FIFO Trigger"] # [inline (always)] # [must_use] pub fn int_event0_iclr_stxfifotrg (& mut self) -> INT_EVENT0_ICLR_STXFIFOTRG_W < INT_EVENT0_ICLR_SPEC , 19 > { INT_EVENT0_ICLR_STXFIFOTRG_W :: new (self) } # [doc = "Bit 20 - RXFIFO full event. This interrupt is set if an RX FIFO is full."] # [inline (always)] # [must_use] pub fn int_event0_iclr_srxfifofull (& mut self) -> INT_EVENT0_ICLR_SRXFIFOFULL_W < INT_EVENT0_ICLR_SPEC , 20 > { INT_EVENT0_ICLR_SRXFIFOFULL_W :: new (self) } # [doc = "Bit 21 - Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode."] # [inline (always)] # [must_use] pub fn int_event0_iclr_stxempty (& mut self) -> INT_EVENT0_ICLR_STXEMPTY_W < INT_EVENT0_ICLR_SPEC , 21 > { INT_EVENT0_ICLR_STXEMPTY_W :: new (self) } # [doc = "Bit 22 - Slave START Detection Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iclr_sstart (& mut self) -> INT_EVENT0_ICLR_SSTART_W < INT_EVENT0_ICLR_SPEC , 22 > { INT_EVENT0_ICLR_SSTART_W :: new (self) } # [doc = "Bit 23 - Slave STOP Detection Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iclr_sstop (& mut self) -> INT_EVENT0_ICLR_SSTOP_W < INT_EVENT0_ICLR_SPEC , 23 > { INT_EVENT0_ICLR_SSTOP_W :: new (self) } # [doc = "Bit 24 - General Call Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iclr_sgencall (& mut self) -> INT_EVENT0_ICLR_SGENCALL_W < INT_EVENT0_ICLR_SPEC , 24 > { INT_EVENT0_ICLR_SGENCALL_W :: new (self) } # [doc = "Bit 25 - DMA Done 1 on Event Channel 2"] # [inline (always)] # [must_use] pub fn int_event0_iclr_sdma_done1_2 (& mut self) -> INT_EVENT0_ICLR_SDMA_DONE1_2_W < INT_EVENT0_ICLR_SPEC , 25 > { INT_EVENT0_ICLR_SDMA_DONE1_2_W :: new (self) } # [doc = "Bit 26 - DMA Done 1 on Event Channel 3"] # [inline (always)] # [must_use] pub fn int_event0_iclr_sdma_done1_3 (& mut self) -> INT_EVENT0_ICLR_SDMA_DONE1_3_W < INT_EVENT0_ICLR_SPEC , 26 > { INT_EVENT0_ICLR_SDMA_DONE1_3_W :: new (self) } # [doc = "Bit 27 - Slave RX Pec Error Interrupt"] # [inline (always)] # [must_use] pub fn int_event0_iclr_spec_rx_err (& mut self) -> INT_EVENT0_ICLR_SPEC_RX_ERR_W < INT_EVENT0_ICLR_SPEC , 27 > { INT_EVENT0_ICLR_SPEC_RX_ERR_W :: new (self) } # [doc = "Bit 28 - Slave TX FIFO underflow"] # [inline (always)] # [must_use] pub fn int_event0_iclr_stx_unfl (& mut self) -> INT_EVENT0_ICLR_STX_UNFL_W < INT_EVENT0_ICLR_SPEC , 28 > { INT_EVENT0_ICLR_STX_UNFL_W :: new (self) } # [doc = "Bit 29 - Slave RX FIFO overflow"] # [inline (always)] # [must_use] pub fn int_event0_iclr_srx_ovfl (& mut self) -> INT_EVENT0_ICLR_SRX_OVFL_W < INT_EVENT0_ICLR_SPEC , 29 > { INT_EVENT0_ICLR_SRX_OVFL_W :: new (self) } # [doc = "Bit 30 - Slave Arbitration Lost"] # [inline (always)] # [must_use] pub fn int_event0_iclr_sarblost (& mut self) -> INT_EVENT0_ICLR_SARBLOST_W < INT_EVENT0_ICLR_SPEC , 30 > { INT_EVENT0_ICLR_SARBLOST_W :: new (self) } # [doc = "Bit 31 - Interrupt overflow"] # [inline (always)] # [must_use] pub fn int_event0_iclr_intr_ovfl (& mut self) -> INT_EVENT0_ICLR_INTR_OVFL_W < INT_EVENT0_ICLR_SPEC , 31 > { INT_EVENT0_ICLR_INTR_OVFL_W :: new (self) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Interrupt clear\n\nYou can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_event0_iclr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT_EVENT0_ICLR_SPEC ; impl crate :: RegisterSpec for INT_EVENT0_ICLR_SPEC { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`int_event0_iclr::W`](W) writer structure"] impl crate :: Writable for INT_EVENT0_ICLR_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT_EVENT0_ICLR to value 0"] impl crate :: Resettable for INT_EVENT0_ICLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }