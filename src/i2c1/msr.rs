# [doc = "Register `MSR` reader"] pub type R = crate :: R < MSR_SPEC > ; # [doc = "Field `MSR_BUSY` reader - I2C Master FSM Busy The BUSY bit is set during an ongoing transaction, so is set during the transmit/receive of the amount of data set in MBLEN including START, RESTART, Address and STOP signal generation when required for the current transaction."] pub type MSR_BUSY_R = crate :: BitReader < MSR_BUSY_A > ; # [doc = "I2C Master FSM Busy The BUSY bit is set during an ongoing transaction, so is set during the transmit/receive of the amount of data set in MBLEN including START, RESTART, Address and STOP signal generation when required for the current transaction.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum MSR_BUSY_A { # [doc = "0: CLEARED"] MSR_BUSY_CLEARED = 0 , # [doc = "1: SET"] MSR_BUSY_SET = 1 , } impl From < MSR_BUSY_A > for bool { # [inline (always)] fn from (variant : MSR_BUSY_A) -> Self { variant as u8 != 0 } } impl MSR_BUSY_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> MSR_BUSY_A { match self . bits { false => MSR_BUSY_A :: MSR_BUSY_CLEARED , true => MSR_BUSY_A :: MSR_BUSY_SET , } } # [doc = "CLEARED"] # [inline (always)] pub fn is_msr_busy_cleared (& self) -> bool { * self == MSR_BUSY_A :: MSR_BUSY_CLEARED } # [doc = "SET"] # [inline (always)] pub fn is_msr_busy_set (& self) -> bool { * self == MSR_BUSY_A :: MSR_BUSY_SET } } # [doc = "Field `MSR_ERR` reader - Error The error can be from the slave address not being acknowledged or the transmit data not being acknowledged."] pub type MSR_ERR_R = crate :: BitReader < MSR_ERR_A > ; # [doc = "Error The error can be from the slave address not being acknowledged or the transmit data not being acknowledged.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum MSR_ERR_A { # [doc = "0: CLEARED"] MSR_ERR_CLEARED = 0 , # [doc = "1: SET"] MSR_ERR_SET = 1 , } impl From < MSR_ERR_A > for bool { # [inline (always)] fn from (variant : MSR_ERR_A) -> Self { variant as u8 != 0 } } impl MSR_ERR_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> MSR_ERR_A { match self . bits { false => MSR_ERR_A :: MSR_ERR_CLEARED , true => MSR_ERR_A :: MSR_ERR_SET , } } # [doc = "CLEARED"] # [inline (always)] pub fn is_msr_err_cleared (& self) -> bool { * self == MSR_ERR_A :: MSR_ERR_CLEARED } # [doc = "SET"] # [inline (always)] pub fn is_msr_err_set (& self) -> bool { * self == MSR_ERR_A :: MSR_ERR_SET } } # [doc = "Field `MSR_ADRACK` reader - Acknowledge Address"] pub type MSR_ADRACK_R = crate :: BitReader < MSR_ADRACK_A > ; # [doc = "Acknowledge Address\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum MSR_ADRACK_A { # [doc = "0: CLEARED"] MSR_ADRACK_CLEARED = 0 , # [doc = "1: SET"] MSR_ADRACK_SET = 1 , } impl From < MSR_ADRACK_A > for bool { # [inline (always)] fn from (variant : MSR_ADRACK_A) -> Self { variant as u8 != 0 } } impl MSR_ADRACK_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> MSR_ADRACK_A { match self . bits { false => MSR_ADRACK_A :: MSR_ADRACK_CLEARED , true => MSR_ADRACK_A :: MSR_ADRACK_SET , } } # [doc = "CLEARED"] # [inline (always)] pub fn is_msr_adrack_cleared (& self) -> bool { * self == MSR_ADRACK_A :: MSR_ADRACK_CLEARED } # [doc = "SET"] # [inline (always)] pub fn is_msr_adrack_set (& self) -> bool { * self == MSR_ADRACK_A :: MSR_ADRACK_SET } } # [doc = "Field `MSR_DATACK` reader - Acknowledge Data"] pub type MSR_DATACK_R = crate :: BitReader < MSR_DATACK_A > ; # [doc = "Acknowledge Data\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum MSR_DATACK_A { # [doc = "0: CLEARED"] MSR_DATACK_CLEARED = 0 , # [doc = "1: SET"] MSR_DATACK_SET = 1 , } impl From < MSR_DATACK_A > for bool { # [inline (always)] fn from (variant : MSR_DATACK_A) -> Self { variant as u8 != 0 } } impl MSR_DATACK_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> MSR_DATACK_A { match self . bits { false => MSR_DATACK_A :: MSR_DATACK_CLEARED , true => MSR_DATACK_A :: MSR_DATACK_SET , } } # [doc = "CLEARED"] # [inline (always)] pub fn is_msr_datack_cleared (& self) -> bool { * self == MSR_DATACK_A :: MSR_DATACK_CLEARED } # [doc = "SET"] # [inline (always)] pub fn is_msr_datack_set (& self) -> bool { * self == MSR_DATACK_A :: MSR_DATACK_SET } } # [doc = "Field `MSR_ARBLST` reader - Arbitration Lost"] pub type MSR_ARBLST_R = crate :: BitReader < MSR_ARBLST_A > ; # [doc = "Arbitration Lost\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum MSR_ARBLST_A { # [doc = "0: CLEARED"] MSR_ARBLST_CLEARED = 0 , # [doc = "1: SET"] MSR_ARBLST_SET = 1 , } impl From < MSR_ARBLST_A > for bool { # [inline (always)] fn from (variant : MSR_ARBLST_A) -> Self { variant as u8 != 0 } } impl MSR_ARBLST_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> MSR_ARBLST_A { match self . bits { false => MSR_ARBLST_A :: MSR_ARBLST_CLEARED , true => MSR_ARBLST_A :: MSR_ARBLST_SET , } } # [doc = "CLEARED"] # [inline (always)] pub fn is_msr_arblst_cleared (& self) -> bool { * self == MSR_ARBLST_A :: MSR_ARBLST_CLEARED } # [doc = "SET"] # [inline (always)] pub fn is_msr_arblst_set (& self) -> bool { * self == MSR_ARBLST_A :: MSR_ARBLST_SET } } # [doc = "Field `MSR_IDLE` reader - I2C Idle"] pub type MSR_IDLE_R = crate :: BitReader < MSR_IDLE_A > ; # [doc = "I2C Idle\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum MSR_IDLE_A { # [doc = "0: CLEARED"] MSR_IDLE_CLEARED = 0 , # [doc = "1: SET"] MSR_IDLE_SET = 1 , } impl From < MSR_IDLE_A > for bool { # [inline (always)] fn from (variant : MSR_IDLE_A) -> Self { variant as u8 != 0 } } impl MSR_IDLE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> MSR_IDLE_A { match self . bits { false => MSR_IDLE_A :: MSR_IDLE_CLEARED , true => MSR_IDLE_A :: MSR_IDLE_SET , } } # [doc = "CLEARED"] # [inline (always)] pub fn is_msr_idle_cleared (& self) -> bool { * self == MSR_IDLE_A :: MSR_IDLE_CLEARED } # [doc = "SET"] # [inline (always)] pub fn is_msr_idle_set (& self) -> bool { * self == MSR_IDLE_A :: MSR_IDLE_SET } } # [doc = "Field `MSR_BUSBSY` reader - I2C Bus is Busy Master State Machine will wait until this bit is cleared before starting a transaction. When first enabling the Master in multi master environments, FW should wait for one I2C clock period after setting ACTIVE high before writing to the MTCR register to start the transaction so that if SCL goes low it will trigger the BUSBSY."] pub type MSR_BUSBSY_R = crate :: BitReader < MSR_BUSBSY_A > ; # [doc = "I2C Bus is Busy Master State Machine will wait until this bit is cleared before starting a transaction. When first enabling the Master in multi master environments, FW should wait for one I2C clock period after setting ACTIVE high before writing to the MTCR register to start the transaction so that if SCL goes low it will trigger the BUSBSY.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum MSR_BUSBSY_A { # [doc = "0: CLEARED"] MSR_BUSBSY_CLEARED = 0 , # [doc = "1: SET"] MSR_BUSBSY_SET = 1 , } impl From < MSR_BUSBSY_A > for bool { # [inline (always)] fn from (variant : MSR_BUSBSY_A) -> Self { variant as u8 != 0 } } impl MSR_BUSBSY_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> MSR_BUSBSY_A { match self . bits { false => MSR_BUSBSY_A :: MSR_BUSBSY_CLEARED , true => MSR_BUSBSY_A :: MSR_BUSBSY_SET , } } # [doc = "CLEARED"] # [inline (always)] pub fn is_msr_busbsy_cleared (& self) -> bool { * self == MSR_BUSBSY_A :: MSR_BUSBSY_CLEARED } # [doc = "SET"] # [inline (always)] pub fn is_msr_busbsy_set (& self) -> bool { * self == MSR_BUSBSY_A :: MSR_BUSBSY_SET } } # [doc = "Field `MSR_MBCNT` reader - I2C Master Transaction Count This field contains the current count-down value of the transaction."] pub type MSR_MBCNT_R = crate :: FieldReader < u16 > ; impl R { # [doc = "Bit 0 - I2C Master FSM Busy The BUSY bit is set during an ongoing transaction, so is set during the transmit/receive of the amount of data set in MBLEN including START, RESTART, Address and STOP signal generation when required for the current transaction."] # [inline (always)] pub fn msr_busy (& self) -> MSR_BUSY_R { MSR_BUSY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Error The error can be from the slave address not being acknowledged or the transmit data not being acknowledged."] # [inline (always)] pub fn msr_err (& self) -> MSR_ERR_R { MSR_ERR_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Acknowledge Address"] # [inline (always)] pub fn msr_adrack (& self) -> MSR_ADRACK_R { MSR_ADRACK_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Acknowledge Data"] # [inline (always)] pub fn msr_datack (& self) -> MSR_DATACK_R { MSR_DATACK_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Arbitration Lost"] # [inline (always)] pub fn msr_arblst (& self) -> MSR_ARBLST_R { MSR_ARBLST_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - I2C Idle"] # [inline (always)] pub fn msr_idle (& self) -> MSR_IDLE_R { MSR_IDLE_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - I2C Bus is Busy Master State Machine will wait until this bit is cleared before starting a transaction. When first enabling the Master in multi master environments, FW should wait for one I2C clock period after setting ACTIVE high before writing to the MTCR register to start the transaction so that if SCL goes low it will trigger the BUSBSY."] # [inline (always)] pub fn msr_busbsy (& self) -> MSR_BUSBSY_R { MSR_BUSBSY_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bits 16:27 - I2C Master Transaction Count This field contains the current count-down value of the transaction."] # [inline (always)] pub fn msr_mbcnt (& self) -> MSR_MBCNT_R { MSR_MBCNT_R :: new (((self . bits >> 16) & 0x0fff) as u16) } } # [doc = "I2C Master Status Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`msr::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MSR_SPEC ; impl crate :: RegisterSpec for MSR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`msr::R`](R) reader structure"] impl crate :: Readable for MSR_SPEC { } # [doc = "`reset()` method sets MSR to value 0"] impl crate :: Resettable for MSR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }