# [doc = "Register `PMUOPAMP` reader"] pub type R = crate :: R < PMUOPAMP_SPEC > ; # [doc = "Register `PMUOPAMP` writer"] pub type W = crate :: W < PMUOPAMP_SPEC > ; # [doc = "Field `PMUOPAMP_ENABLE` reader - Set ENABLE to turn on the GPAMP."] pub type PMUOPAMP_ENABLE_R = crate :: BitReader < PMUOPAMP_ENABLE_A > ; # [doc = "Set ENABLE to turn on the GPAMP.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum PMUOPAMP_ENABLE_A { # [doc = "0: FALSE"] PMUOPAMP_ENABLE_FALSE = 0 , # [doc = "1: TRUE"] PMUOPAMP_ENABLE_TRUE = 1 , } impl From < PMUOPAMP_ENABLE_A > for bool { # [inline (always)] fn from (variant : PMUOPAMP_ENABLE_A) -> Self { variant as u8 != 0 } } impl PMUOPAMP_ENABLE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> PMUOPAMP_ENABLE_A { match self . bits { false => PMUOPAMP_ENABLE_A :: PMUOPAMP_ENABLE_FALSE , true => PMUOPAMP_ENABLE_A :: PMUOPAMP_ENABLE_TRUE , } } # [doc = "FALSE"] # [inline (always)] pub fn is_pmuopamp_enable_false (& self) -> bool { * self == PMUOPAMP_ENABLE_A :: PMUOPAMP_ENABLE_FALSE } # [doc = "TRUE"] # [inline (always)] pub fn is_pmuopamp_enable_true (& self) -> bool { * self == PMUOPAMP_ENABLE_A :: PMUOPAMP_ENABLE_TRUE } } # [doc = "Field `PMUOPAMP_ENABLE` writer - Set ENABLE to turn on the GPAMP."] pub type PMUOPAMP_ENABLE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , PMUOPAMP_ENABLE_A > ; impl < 'a , REG , const O : u8 > PMUOPAMP_ENABLE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "FALSE"] # [inline (always)] pub fn pmuopamp_enable_false (self) -> & 'a mut crate :: W < REG > { self . variant (PMUOPAMP_ENABLE_A :: PMUOPAMP_ENABLE_FALSE) } # [doc = "TRUE"] # [inline (always)] pub fn pmuopamp_enable_true (self) -> & 'a mut crate :: W < REG > { self . variant (PMUOPAMP_ENABLE_A :: PMUOPAMP_ENABLE_TRUE) } } # [doc = "Field `PMUOPAMP_PCHENABLE` reader - Set PCHENABLE to enable the positive channel input."] pub type PMUOPAMP_PCHENABLE_R = crate :: BitReader < PMUOPAMP_PCHENABLE_A > ; # [doc = "Set PCHENABLE to enable the positive channel input.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum PMUOPAMP_PCHENABLE_A { # [doc = "0: FALSE"] PMUOPAMP_PCHENABLE_FALSE = 0 , # [doc = "1: TRUE"] PMUOPAMP_PCHENABLE_TRUE = 1 , } impl From < PMUOPAMP_PCHENABLE_A > for bool { # [inline (always)] fn from (variant : PMUOPAMP_PCHENABLE_A) -> Self { variant as u8 != 0 } } impl PMUOPAMP_PCHENABLE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> PMUOPAMP_PCHENABLE_A { match self . bits { false => PMUOPAMP_PCHENABLE_A :: PMUOPAMP_PCHENABLE_FALSE , true => PMUOPAMP_PCHENABLE_A :: PMUOPAMP_PCHENABLE_TRUE , } } # [doc = "FALSE"] # [inline (always)] pub fn is_pmuopamp_pchenable_false (& self) -> bool { * self == PMUOPAMP_PCHENABLE_A :: PMUOPAMP_PCHENABLE_FALSE } # [doc = "TRUE"] # [inline (always)] pub fn is_pmuopamp_pchenable_true (& self) -> bool { * self == PMUOPAMP_PCHENABLE_A :: PMUOPAMP_PCHENABLE_TRUE } } # [doc = "Field `PMUOPAMP_PCHENABLE` writer - Set PCHENABLE to enable the positive channel input."] pub type PMUOPAMP_PCHENABLE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , PMUOPAMP_PCHENABLE_A > ; impl < 'a , REG , const O : u8 > PMUOPAMP_PCHENABLE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "FALSE"] # [inline (always)] pub fn pmuopamp_pchenable_false (self) -> & 'a mut crate :: W < REG > { self . variant (PMUOPAMP_PCHENABLE_A :: PMUOPAMP_PCHENABLE_FALSE) } # [doc = "TRUE"] # [inline (always)] pub fn pmuopamp_pchenable_true (self) -> & 'a mut crate :: W < REG > { self . variant (PMUOPAMP_PCHENABLE_A :: PMUOPAMP_PCHENABLE_TRUE) } } # [doc = "Field `PMUOPAMP_NSEL` reader - NSEL selects the GPAMP negative channel input."] pub type PMUOPAMP_NSEL_R = crate :: FieldReader < PMUOPAMP_NSEL_A > ; # [doc = "NSEL selects the GPAMP negative channel input.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum PMUOPAMP_NSEL_A { # [doc = "0: SEL0"] PMUOPAMP_NSEL_SEL0 = 0 , # [doc = "1: SEL1"] PMUOPAMP_NSEL_SEL1 = 1 , # [doc = "2: SEL2"] PMUOPAMP_NSEL_SEL2 = 2 , # [doc = "3: SEL3"] PMUOPAMP_NSEL_SEL3 = 3 , } impl From < PMUOPAMP_NSEL_A > for u8 { # [inline (always)] fn from (variant : PMUOPAMP_NSEL_A) -> Self { variant as _ } } impl crate :: FieldSpec for PMUOPAMP_NSEL_A { type Ux = u8 ; } impl PMUOPAMP_NSEL_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> PMUOPAMP_NSEL_A { match self . bits { 0 => PMUOPAMP_NSEL_A :: PMUOPAMP_NSEL_SEL0 , 1 => PMUOPAMP_NSEL_A :: PMUOPAMP_NSEL_SEL1 , 2 => PMUOPAMP_NSEL_A :: PMUOPAMP_NSEL_SEL2 , 3 => PMUOPAMP_NSEL_A :: PMUOPAMP_NSEL_SEL3 , _ => unreachable ! () , } } # [doc = "SEL0"] # [inline (always)] pub fn is_pmuopamp_nsel_sel0 (& self) -> bool { * self == PMUOPAMP_NSEL_A :: PMUOPAMP_NSEL_SEL0 } # [doc = "SEL1"] # [inline (always)] pub fn is_pmuopamp_nsel_sel1 (& self) -> bool { * self == PMUOPAMP_NSEL_A :: PMUOPAMP_NSEL_SEL1 } # [doc = "SEL2"] # [inline (always)] pub fn is_pmuopamp_nsel_sel2 (& self) -> bool { * self == PMUOPAMP_NSEL_A :: PMUOPAMP_NSEL_SEL2 } # [doc = "SEL3"] # [inline (always)] pub fn is_pmuopamp_nsel_sel3 (& self) -> bool { * self == PMUOPAMP_NSEL_A :: PMUOPAMP_NSEL_SEL3 } } # [doc = "Field `PMUOPAMP_NSEL` writer - NSEL selects the GPAMP negative channel input."] pub type PMUOPAMP_NSEL_W < 'a , REG , const O : u8 > = crate :: FieldWriterSafe < 'a , REG , 2 , O , PMUOPAMP_NSEL_A > ; impl < 'a , REG , const O : u8 > PMUOPAMP_NSEL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "SEL0"] # [inline (always)] pub fn pmuopamp_nsel_sel0 (self) -> & 'a mut crate :: W < REG > { self . variant (PMUOPAMP_NSEL_A :: PMUOPAMP_NSEL_SEL0) } # [doc = "SEL1"] # [inline (always)] pub fn pmuopamp_nsel_sel1 (self) -> & 'a mut crate :: W < REG > { self . variant (PMUOPAMP_NSEL_A :: PMUOPAMP_NSEL_SEL1) } # [doc = "SEL2"] # [inline (always)] pub fn pmuopamp_nsel_sel2 (self) -> & 'a mut crate :: W < REG > { self . variant (PMUOPAMP_NSEL_A :: PMUOPAMP_NSEL_SEL2) } # [doc = "SEL3"] # [inline (always)] pub fn pmuopamp_nsel_sel3 (self) -> & 'a mut crate :: W < REG > { self . variant (PMUOPAMP_NSEL_A :: PMUOPAMP_NSEL_SEL3) } } # [doc = "Field `PMUOPAMP_RRI` reader - RRI selects the rail-to-rail input mode."] pub type PMUOPAMP_RRI_R = crate :: FieldReader < PMUOPAMP_RRI_A > ; # [doc = "RRI selects the rail-to-rail input mode.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum PMUOPAMP_RRI_A { # [doc = "0: MODE0"] PMUOPAMP_RRI_MODE0 = 0 , # [doc = "1: MODE1"] PMUOPAMP_RRI_MODE1 = 1 , # [doc = "2: MODE2"] PMUOPAMP_RRI_MODE2 = 2 , # [doc = "3: MODE3"] PMUOPAMP_RRI_MODE3 = 3 , } impl From < PMUOPAMP_RRI_A > for u8 { # [inline (always)] fn from (variant : PMUOPAMP_RRI_A) -> Self { variant as _ } } impl crate :: FieldSpec for PMUOPAMP_RRI_A { type Ux = u8 ; } impl PMUOPAMP_RRI_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> PMUOPAMP_RRI_A { match self . bits { 0 => PMUOPAMP_RRI_A :: PMUOPAMP_RRI_MODE0 , 1 => PMUOPAMP_RRI_A :: PMUOPAMP_RRI_MODE1 , 2 => PMUOPAMP_RRI_A :: PMUOPAMP_RRI_MODE2 , 3 => PMUOPAMP_RRI_A :: PMUOPAMP_RRI_MODE3 , _ => unreachable ! () , } } # [doc = "MODE0"] # [inline (always)] pub fn is_pmuopamp_rri_mode0 (& self) -> bool { * self == PMUOPAMP_RRI_A :: PMUOPAMP_RRI_MODE0 } # [doc = "MODE1"] # [inline (always)] pub fn is_pmuopamp_rri_mode1 (& self) -> bool { * self == PMUOPAMP_RRI_A :: PMUOPAMP_RRI_MODE1 } # [doc = "MODE2"] # [inline (always)] pub fn is_pmuopamp_rri_mode2 (& self) -> bool { * self == PMUOPAMP_RRI_A :: PMUOPAMP_RRI_MODE2 } # [doc = "MODE3"] # [inline (always)] pub fn is_pmuopamp_rri_mode3 (& self) -> bool { * self == PMUOPAMP_RRI_A :: PMUOPAMP_RRI_MODE3 } } # [doc = "Field `PMUOPAMP_RRI` writer - RRI selects the rail-to-rail input mode."] pub type PMUOPAMP_RRI_W < 'a , REG , const O : u8 > = crate :: FieldWriterSafe < 'a , REG , 2 , O , PMUOPAMP_RRI_A > ; impl < 'a , REG , const O : u8 > PMUOPAMP_RRI_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "MODE0"] # [inline (always)] pub fn pmuopamp_rri_mode0 (self) -> & 'a mut crate :: W < REG > { self . variant (PMUOPAMP_RRI_A :: PMUOPAMP_RRI_MODE0) } # [doc = "MODE1"] # [inline (always)] pub fn pmuopamp_rri_mode1 (self) -> & 'a mut crate :: W < REG > { self . variant (PMUOPAMP_RRI_A :: PMUOPAMP_RRI_MODE1) } # [doc = "MODE2"] # [inline (always)] pub fn pmuopamp_rri_mode2 (self) -> & 'a mut crate :: W < REG > { self . variant (PMUOPAMP_RRI_A :: PMUOPAMP_RRI_MODE2) } # [doc = "MODE3"] # [inline (always)] pub fn pmuopamp_rri_mode3 (self) -> & 'a mut crate :: W < REG > { self . variant (PMUOPAMP_RRI_A :: PMUOPAMP_RRI_MODE3) } } # [doc = "Field `PMUOPAMP_OUTENABLE` reader - Set OUTENABLE to connect the GPAMP output signal to the GPAMP_OUT pin"] pub type PMUOPAMP_OUTENABLE_R = crate :: BitReader < PMUOPAMP_OUTENABLE_A > ; # [doc = "Set OUTENABLE to connect the GPAMP output signal to the GPAMP_OUT pin\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum PMUOPAMP_OUTENABLE_A { # [doc = "0: FALSE"] PMUOPAMP_OUTENABLE_FALSE = 0 , # [doc = "1: TRUE"] PMUOPAMP_OUTENABLE_TRUE = 1 , } impl From < PMUOPAMP_OUTENABLE_A > for bool { # [inline (always)] fn from (variant : PMUOPAMP_OUTENABLE_A) -> Self { variant as u8 != 0 } } impl PMUOPAMP_OUTENABLE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> PMUOPAMP_OUTENABLE_A { match self . bits { false => PMUOPAMP_OUTENABLE_A :: PMUOPAMP_OUTENABLE_FALSE , true => PMUOPAMP_OUTENABLE_A :: PMUOPAMP_OUTENABLE_TRUE , } } # [doc = "FALSE"] # [inline (always)] pub fn is_pmuopamp_outenable_false (& self) -> bool { * self == PMUOPAMP_OUTENABLE_A :: PMUOPAMP_OUTENABLE_FALSE } # [doc = "TRUE"] # [inline (always)] pub fn is_pmuopamp_outenable_true (& self) -> bool { * self == PMUOPAMP_OUTENABLE_A :: PMUOPAMP_OUTENABLE_TRUE } } # [doc = "Field `PMUOPAMP_OUTENABLE` writer - Set OUTENABLE to connect the GPAMP output signal to the GPAMP_OUT pin"] pub type PMUOPAMP_OUTENABLE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , PMUOPAMP_OUTENABLE_A > ; impl < 'a , REG , const O : u8 > PMUOPAMP_OUTENABLE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "FALSE"] # [inline (always)] pub fn pmuopamp_outenable_false (self) -> & 'a mut crate :: W < REG > { self . variant (PMUOPAMP_OUTENABLE_A :: PMUOPAMP_OUTENABLE_FALSE) } # [doc = "TRUE"] # [inline (always)] pub fn pmuopamp_outenable_true (self) -> & 'a mut crate :: W < REG > { self . variant (PMUOPAMP_OUTENABLE_A :: PMUOPAMP_OUTENABLE_TRUE) } } # [doc = "Field `PMUOPAMP_CHOPCLKFREQ` reader - CHOPCLKFREQ selects the GPAMP chopping clock frequency"] pub type PMUOPAMP_CHOPCLKFREQ_R = crate :: FieldReader < PMUOPAMP_CHOPCLKFREQ_A > ; # [doc = "CHOPCLKFREQ selects the GPAMP chopping clock frequency\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum PMUOPAMP_CHOPCLKFREQ_A { # [doc = "0: CLK16KHZ"] PMUOPAMP_CHOPCLKFREQ_CLK16KHZ = 0 , # [doc = "1: CLK8KHZ"] PMUOPAMP_CHOPCLKFREQ_CLK8KHZ = 1 , # [doc = "2: CLK4KHZ"] PMUOPAMP_CHOPCLKFREQ_CLK4KHZ = 2 , # [doc = "3: CLK2KHZ"] PMUOPAMP_CHOPCLKFREQ_CLK2KHZ = 3 , } impl From < PMUOPAMP_CHOPCLKFREQ_A > for u8 { # [inline (always)] fn from (variant : PMUOPAMP_CHOPCLKFREQ_A) -> Self { variant as _ } } impl crate :: FieldSpec for PMUOPAMP_CHOPCLKFREQ_A { type Ux = u8 ; } impl PMUOPAMP_CHOPCLKFREQ_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> PMUOPAMP_CHOPCLKFREQ_A { match self . bits { 0 => PMUOPAMP_CHOPCLKFREQ_A :: PMUOPAMP_CHOPCLKFREQ_CLK16KHZ , 1 => PMUOPAMP_CHOPCLKFREQ_A :: PMUOPAMP_CHOPCLKFREQ_CLK8KHZ , 2 => PMUOPAMP_CHOPCLKFREQ_A :: PMUOPAMP_CHOPCLKFREQ_CLK4KHZ , 3 => PMUOPAMP_CHOPCLKFREQ_A :: PMUOPAMP_CHOPCLKFREQ_CLK2KHZ , _ => unreachable ! () , } } # [doc = "CLK16KHZ"] # [inline (always)] pub fn is_pmuopamp_chopclkfreq_clk16khz (& self) -> bool { * self == PMUOPAMP_CHOPCLKFREQ_A :: PMUOPAMP_CHOPCLKFREQ_CLK16KHZ } # [doc = "CLK8KHZ"] # [inline (always)] pub fn is_pmuopamp_chopclkfreq_clk8khz (& self) -> bool { * self == PMUOPAMP_CHOPCLKFREQ_A :: PMUOPAMP_CHOPCLKFREQ_CLK8KHZ } # [doc = "CLK4KHZ"] # [inline (always)] pub fn is_pmuopamp_chopclkfreq_clk4khz (& self) -> bool { * self == PMUOPAMP_CHOPCLKFREQ_A :: PMUOPAMP_CHOPCLKFREQ_CLK4KHZ } # [doc = "CLK2KHZ"] # [inline (always)] pub fn is_pmuopamp_chopclkfreq_clk2khz (& self) -> bool { * self == PMUOPAMP_CHOPCLKFREQ_A :: PMUOPAMP_CHOPCLKFREQ_CLK2KHZ } } # [doc = "Field `PMUOPAMP_CHOPCLKFREQ` writer - CHOPCLKFREQ selects the GPAMP chopping clock frequency"] pub type PMUOPAMP_CHOPCLKFREQ_W < 'a , REG , const O : u8 > = crate :: FieldWriterSafe < 'a , REG , 2 , O , PMUOPAMP_CHOPCLKFREQ_A > ; impl < 'a , REG , const O : u8 > PMUOPAMP_CHOPCLKFREQ_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "CLK16KHZ"] # [inline (always)] pub fn pmuopamp_chopclkfreq_clk16khz (self) -> & 'a mut crate :: W < REG > { self . variant (PMUOPAMP_CHOPCLKFREQ_A :: PMUOPAMP_CHOPCLKFREQ_CLK16KHZ) } # [doc = "CLK8KHZ"] # [inline (always)] pub fn pmuopamp_chopclkfreq_clk8khz (self) -> & 'a mut crate :: W < REG > { self . variant (PMUOPAMP_CHOPCLKFREQ_A :: PMUOPAMP_CHOPCLKFREQ_CLK8KHZ) } # [doc = "CLK4KHZ"] # [inline (always)] pub fn pmuopamp_chopclkfreq_clk4khz (self) -> & 'a mut crate :: W < REG > { self . variant (PMUOPAMP_CHOPCLKFREQ_A :: PMUOPAMP_CHOPCLKFREQ_CLK4KHZ) } # [doc = "CLK2KHZ"] # [inline (always)] pub fn pmuopamp_chopclkfreq_clk2khz (self) -> & 'a mut crate :: W < REG > { self . variant (PMUOPAMP_CHOPCLKFREQ_A :: PMUOPAMP_CHOPCLKFREQ_CLK2KHZ) } } # [doc = "Field `PMUOPAMP_CHOPCLKMODE` reader - CHOPCLKMODE selects the GPAMP chopping mode."] pub type PMUOPAMP_CHOPCLKMODE_R = crate :: FieldReader < PMUOPAMP_CHOPCLKMODE_A > ; # [doc = "CHOPCLKMODE selects the GPAMP chopping mode.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum PMUOPAMP_CHOPCLKMODE_A { # [doc = "0: CHOPDISABLED"] PMUOPAMP_CHOPCLKMODE_CHOPDISABLED = 0 , # [doc = "1: REGCHOP"] PMUOPAMP_CHOPCLKMODE_REGCHOP = 1 , # [doc = "2: ADCASSIST"] PMUOPAMP_CHOPCLKMODE_ADCASSIST = 2 , } impl From < PMUOPAMP_CHOPCLKMODE_A > for u8 { # [inline (always)] fn from (variant : PMUOPAMP_CHOPCLKMODE_A) -> Self { variant as _ } } impl crate :: FieldSpec for PMUOPAMP_CHOPCLKMODE_A { type Ux = u8 ; } impl PMUOPAMP_CHOPCLKMODE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < PMUOPAMP_CHOPCLKMODE_A > { match self . bits { 0 => Some (PMUOPAMP_CHOPCLKMODE_A :: PMUOPAMP_CHOPCLKMODE_CHOPDISABLED) , 1 => Some (PMUOPAMP_CHOPCLKMODE_A :: PMUOPAMP_CHOPCLKMODE_REGCHOP) , 2 => Some (PMUOPAMP_CHOPCLKMODE_A :: PMUOPAMP_CHOPCLKMODE_ADCASSIST) , _ => None , } } # [doc = "CHOPDISABLED"] # [inline (always)] pub fn is_pmuopamp_chopclkmode_chopdisabled (& self) -> bool { * self == PMUOPAMP_CHOPCLKMODE_A :: PMUOPAMP_CHOPCLKMODE_CHOPDISABLED } # [doc = "REGCHOP"] # [inline (always)] pub fn is_pmuopamp_chopclkmode_regchop (& self) -> bool { * self == PMUOPAMP_CHOPCLKMODE_A :: PMUOPAMP_CHOPCLKMODE_REGCHOP } # [doc = "ADCASSIST"] # [inline (always)] pub fn is_pmuopamp_chopclkmode_adcassist (& self) -> bool { * self == PMUOPAMP_CHOPCLKMODE_A :: PMUOPAMP_CHOPCLKMODE_ADCASSIST } } # [doc = "Field `PMUOPAMP_CHOPCLKMODE` writer - CHOPCLKMODE selects the GPAMP chopping mode."] pub type PMUOPAMP_CHOPCLKMODE_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 2 , O , PMUOPAMP_CHOPCLKMODE_A > ; impl < 'a , REG , const O : u8 > PMUOPAMP_CHOPCLKMODE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "CHOPDISABLED"] # [inline (always)] pub fn pmuopamp_chopclkmode_chopdisabled (self) -> & 'a mut crate :: W < REG > { self . variant (PMUOPAMP_CHOPCLKMODE_A :: PMUOPAMP_CHOPCLKMODE_CHOPDISABLED) } # [doc = "REGCHOP"] # [inline (always)] pub fn pmuopamp_chopclkmode_regchop (self) -> & 'a mut crate :: W < REG > { self . variant (PMUOPAMP_CHOPCLKMODE_A :: PMUOPAMP_CHOPCLKMODE_REGCHOP) } # [doc = "ADCASSIST"] # [inline (always)] pub fn pmuopamp_chopclkmode_adcassist (self) -> & 'a mut crate :: W < REG > { self . variant (PMUOPAMP_CHOPCLKMODE_A :: PMUOPAMP_CHOPCLKMODE_ADCASSIST) } } impl R { # [doc = "Bit 0 - Set ENABLE to turn on the GPAMP."] # [inline (always)] pub fn pmuopamp_enable (& self) -> PMUOPAMP_ENABLE_R { PMUOPAMP_ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Set PCHENABLE to enable the positive channel input."] # [inline (always)] pub fn pmuopamp_pchenable (& self) -> PMUOPAMP_PCHENABLE_R { PMUOPAMP_PCHENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - NSEL selects the GPAMP negative channel input."] # [inline (always)] pub fn pmuopamp_nsel (& self) -> PMUOPAMP_NSEL_R { PMUOPAMP_NSEL_R :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bits 4:5 - RRI selects the rail-to-rail input mode."] # [inline (always)] pub fn pmuopamp_rri (& self) -> PMUOPAMP_RRI_R { PMUOPAMP_RRI_R :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bit 6 - Set OUTENABLE to connect the GPAMP output signal to the GPAMP_OUT pin"] # [inline (always)] pub fn pmuopamp_outenable (& self) -> PMUOPAMP_OUTENABLE_R { PMUOPAMP_OUTENABLE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bits 8:9 - CHOPCLKFREQ selects the GPAMP chopping clock frequency"] # [inline (always)] pub fn pmuopamp_chopclkfreq (& self) -> PMUOPAMP_CHOPCLKFREQ_R { PMUOPAMP_CHOPCLKFREQ_R :: new (((self . bits >> 8) & 3) as u8) } # [doc = "Bits 10:11 - CHOPCLKMODE selects the GPAMP chopping mode."] # [inline (always)] pub fn pmuopamp_chopclkmode (& self) -> PMUOPAMP_CHOPCLKMODE_R { PMUOPAMP_CHOPCLKMODE_R :: new (((self . bits >> 10) & 3) as u8) } } impl W { # [doc = "Bit 0 - Set ENABLE to turn on the GPAMP."] # [inline (always)] # [must_use] pub fn pmuopamp_enable (& mut self) -> PMUOPAMP_ENABLE_W < PMUOPAMP_SPEC , 0 > { PMUOPAMP_ENABLE_W :: new (self) } # [doc = "Bit 1 - Set PCHENABLE to enable the positive channel input."] # [inline (always)] # [must_use] pub fn pmuopamp_pchenable (& mut self) -> PMUOPAMP_PCHENABLE_W < PMUOPAMP_SPEC , 1 > { PMUOPAMP_PCHENABLE_W :: new (self) } # [doc = "Bits 2:3 - NSEL selects the GPAMP negative channel input."] # [inline (always)] # [must_use] pub fn pmuopamp_nsel (& mut self) -> PMUOPAMP_NSEL_W < PMUOPAMP_SPEC , 2 > { PMUOPAMP_NSEL_W :: new (self) } # [doc = "Bits 4:5 - RRI selects the rail-to-rail input mode."] # [inline (always)] # [must_use] pub fn pmuopamp_rri (& mut self) -> PMUOPAMP_RRI_W < PMUOPAMP_SPEC , 4 > { PMUOPAMP_RRI_W :: new (self) } # [doc = "Bit 6 - Set OUTENABLE to connect the GPAMP output signal to the GPAMP_OUT pin"] # [inline (always)] # [must_use] pub fn pmuopamp_outenable (& mut self) -> PMUOPAMP_OUTENABLE_W < PMUOPAMP_SPEC , 6 > { PMUOPAMP_OUTENABLE_W :: new (self) } # [doc = "Bits 8:9 - CHOPCLKFREQ selects the GPAMP chopping clock frequency"] # [inline (always)] # [must_use] pub fn pmuopamp_chopclkfreq (& mut self) -> PMUOPAMP_CHOPCLKFREQ_W < PMUOPAMP_SPEC , 8 > { PMUOPAMP_CHOPCLKFREQ_W :: new (self) } # [doc = "Bits 10:11 - CHOPCLKMODE selects the GPAMP chopping mode."] # [inline (always)] # [must_use] pub fn pmuopamp_chopclkmode (& mut self) -> PMUOPAMP_CHOPCLKMODE_W < PMUOPAMP_SPEC , 10 > { PMUOPAMP_CHOPCLKMODE_W :: new (self) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "GPAMP control\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`pmuopamp::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pmuopamp::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PMUOPAMP_SPEC ; impl crate :: RegisterSpec for PMUOPAMP_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`pmuopamp::R`](R) reader structure"] impl crate :: Readable for PMUOPAMP_SPEC { } # [doc = "`write(|w| ..)` method takes [`pmuopamp::W`](W) writer structure"] impl crate :: Writable for PMUOPAMP_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PMUOPAMP to value 0"] impl crate :: Resettable for PMUOPAMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }