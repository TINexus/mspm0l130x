# [doc = "Register `IFCTL_01[%s]` reader"] pub type R = crate :: R < IFCTL_01_SPEC > ; # [doc = "Register `IFCTL_01[%s]` writer"] pub type W = crate :: W < IFCTL_01_SPEC > ; # [doc = "Field `IFCTL_01_ISEL` reader - Input Select (CCP0) This field selects the input source to the filter input. 4h-7h = Reserved"] pub type IFCTL_01_ISEL_R = crate :: FieldReader < IFCTL_01_ISEL_A > ; # [doc = "Input Select (CCP0) This field selects the input source to the filter input. 4h-7h = Reserved\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum IFCTL_01_ISEL_A { # [doc = "0: CCPX_INPUT"] IFCTL_01_ISEL_CCPX_INPUT = 0 , # [doc = "1: CCPX_INPUT_PAIR"] IFCTL_01_ISEL_CCPX_INPUT_PAIR = 1 , # [doc = "2: CCP0_INPUT"] IFCTL_01_ISEL_CCP0_INPUT = 2 , # [doc = "3: TRIG_INPUT"] IFCTL_01_ISEL_TRIG_INPUT = 3 , # [doc = "4: CCP_XOR"] IFCTL_01_ISEL_CCP_XOR = 4 , # [doc = "5: FSUB0"] IFCTL_01_ISEL_FSUB0 = 5 , # [doc = "6: FSUB1"] IFCTL_01_ISEL_FSUB1 = 6 , # [doc = "7: COMP0"] IFCTL_01_ISEL_COMP0 = 7 , # [doc = "8: COMP1"] IFCTL_01_ISEL_COMP1 = 8 , # [doc = "9: COMP2"] IFCTL_01_ISEL_COMP2 = 9 , } impl From < IFCTL_01_ISEL_A > for u8 { # [inline (always)] fn from (variant : IFCTL_01_ISEL_A) -> Self { variant as _ } } impl crate :: FieldSpec for IFCTL_01_ISEL_A { type Ux = u8 ; } impl IFCTL_01_ISEL_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < IFCTL_01_ISEL_A > { match self . bits { 0 => Some (IFCTL_01_ISEL_A :: IFCTL_01_ISEL_CCPX_INPUT) , 1 => Some (IFCTL_01_ISEL_A :: IFCTL_01_ISEL_CCPX_INPUT_PAIR) , 2 => Some (IFCTL_01_ISEL_A :: IFCTL_01_ISEL_CCP0_INPUT) , 3 => Some (IFCTL_01_ISEL_A :: IFCTL_01_ISEL_TRIG_INPUT) , 4 => Some (IFCTL_01_ISEL_A :: IFCTL_01_ISEL_CCP_XOR) , 5 => Some (IFCTL_01_ISEL_A :: IFCTL_01_ISEL_FSUB0) , 6 => Some (IFCTL_01_ISEL_A :: IFCTL_01_ISEL_FSUB1) , 7 => Some (IFCTL_01_ISEL_A :: IFCTL_01_ISEL_COMP0) , 8 => Some (IFCTL_01_ISEL_A :: IFCTL_01_ISEL_COMP1) , 9 => Some (IFCTL_01_ISEL_A :: IFCTL_01_ISEL_COMP2) , _ => None , } } # [doc = "CCPX_INPUT"] # [inline (always)] pub fn is_ifctl_01_isel_ccpx_input (& self) -> bool { * self == IFCTL_01_ISEL_A :: IFCTL_01_ISEL_CCPX_INPUT } # [doc = "CCPX_INPUT_PAIR"] # [inline (always)] pub fn is_ifctl_01_isel_ccpx_input_pair (& self) -> bool { * self == IFCTL_01_ISEL_A :: IFCTL_01_ISEL_CCPX_INPUT_PAIR } # [doc = "CCP0_INPUT"] # [inline (always)] pub fn is_ifctl_01_isel_ccp0_input (& self) -> bool { * self == IFCTL_01_ISEL_A :: IFCTL_01_ISEL_CCP0_INPUT } # [doc = "TRIG_INPUT"] # [inline (always)] pub fn is_ifctl_01_isel_trig_input (& self) -> bool { * self == IFCTL_01_ISEL_A :: IFCTL_01_ISEL_TRIG_INPUT } # [doc = "CCP_XOR"] # [inline (always)] pub fn is_ifctl_01_isel_ccp_xor (& self) -> bool { * self == IFCTL_01_ISEL_A :: IFCTL_01_ISEL_CCP_XOR } # [doc = "FSUB0"] # [inline (always)] pub fn is_ifctl_01_isel_fsub0 (& self) -> bool { * self == IFCTL_01_ISEL_A :: IFCTL_01_ISEL_FSUB0 } # [doc = "FSUB1"] # [inline (always)] pub fn is_ifctl_01_isel_fsub1 (& self) -> bool { * self == IFCTL_01_ISEL_A :: IFCTL_01_ISEL_FSUB1 } # [doc = "COMP0"] # [inline (always)] pub fn is_ifctl_01_isel_comp0 (& self) -> bool { * self == IFCTL_01_ISEL_A :: IFCTL_01_ISEL_COMP0 } # [doc = "COMP1"] # [inline (always)] pub fn is_ifctl_01_isel_comp1 (& self) -> bool { * self == IFCTL_01_ISEL_A :: IFCTL_01_ISEL_COMP1 } # [doc = "COMP2"] # [inline (always)] pub fn is_ifctl_01_isel_comp2 (& self) -> bool { * self == IFCTL_01_ISEL_A :: IFCTL_01_ISEL_COMP2 } } # [doc = "Field `IFCTL_01_ISEL` writer - Input Select (CCP0) This field selects the input source to the filter input. 4h-7h = Reserved"] pub type IFCTL_01_ISEL_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 4 , O , IFCTL_01_ISEL_A > ; impl < 'a , REG , const O : u8 > IFCTL_01_ISEL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "CCPX_INPUT"] # [inline (always)] pub fn ifctl_01_isel_ccpx_input (self) -> & 'a mut crate :: W < REG > { self . variant (IFCTL_01_ISEL_A :: IFCTL_01_ISEL_CCPX_INPUT) } # [doc = "CCPX_INPUT_PAIR"] # [inline (always)] pub fn ifctl_01_isel_ccpx_input_pair (self) -> & 'a mut crate :: W < REG > { self . variant (IFCTL_01_ISEL_A :: IFCTL_01_ISEL_CCPX_INPUT_PAIR) } # [doc = "CCP0_INPUT"] # [inline (always)] pub fn ifctl_01_isel_ccp0_input (self) -> & 'a mut crate :: W < REG > { self . variant (IFCTL_01_ISEL_A :: IFCTL_01_ISEL_CCP0_INPUT) } # [doc = "TRIG_INPUT"] # [inline (always)] pub fn ifctl_01_isel_trig_input (self) -> & 'a mut crate :: W < REG > { self . variant (IFCTL_01_ISEL_A :: IFCTL_01_ISEL_TRIG_INPUT) } # [doc = "CCP_XOR"] # [inline (always)] pub fn ifctl_01_isel_ccp_xor (self) -> & 'a mut crate :: W < REG > { self . variant (IFCTL_01_ISEL_A :: IFCTL_01_ISEL_CCP_XOR) } # [doc = "FSUB0"] # [inline (always)] pub fn ifctl_01_isel_fsub0 (self) -> & 'a mut crate :: W < REG > { self . variant (IFCTL_01_ISEL_A :: IFCTL_01_ISEL_FSUB0) } # [doc = "FSUB1"] # [inline (always)] pub fn ifctl_01_isel_fsub1 (self) -> & 'a mut crate :: W < REG > { self . variant (IFCTL_01_ISEL_A :: IFCTL_01_ISEL_FSUB1) } # [doc = "COMP0"] # [inline (always)] pub fn ifctl_01_isel_comp0 (self) -> & 'a mut crate :: W < REG > { self . variant (IFCTL_01_ISEL_A :: IFCTL_01_ISEL_COMP0) } # [doc = "COMP1"] # [inline (always)] pub fn ifctl_01_isel_comp1 (self) -> & 'a mut crate :: W < REG > { self . variant (IFCTL_01_ISEL_A :: IFCTL_01_ISEL_COMP1) } # [doc = "COMP2"] # [inline (always)] pub fn ifctl_01_isel_comp2 (self) -> & 'a mut crate :: W < REG > { self . variant (IFCTL_01_ISEL_A :: IFCTL_01_ISEL_COMP2) } } # [doc = "Field `IFCTL_01_INV` reader - Input Inversion This bit controls whether the selected input is inverted."] pub type IFCTL_01_INV_R = crate :: BitReader < IFCTL_01_INV_A > ; # [doc = "Input Inversion This bit controls whether the selected input is inverted.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum IFCTL_01_INV_A { # [doc = "0: NOINVERT"] IFCTL_01_INV_NOINVERT = 0 , # [doc = "1: INVERT"] IFCTL_01_INV_INVERT = 1 , } impl From < IFCTL_01_INV_A > for bool { # [inline (always)] fn from (variant : IFCTL_01_INV_A) -> Self { variant as u8 != 0 } } impl IFCTL_01_INV_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> IFCTL_01_INV_A { match self . bits { false => IFCTL_01_INV_A :: IFCTL_01_INV_NOINVERT , true => IFCTL_01_INV_A :: IFCTL_01_INV_INVERT , } } # [doc = "NOINVERT"] # [inline (always)] pub fn is_ifctl_01_inv_noinvert (& self) -> bool { * self == IFCTL_01_INV_A :: IFCTL_01_INV_NOINVERT } # [doc = "INVERT"] # [inline (always)] pub fn is_ifctl_01_inv_invert (& self) -> bool { * self == IFCTL_01_INV_A :: IFCTL_01_INV_INVERT } } # [doc = "Field `IFCTL_01_INV` writer - Input Inversion This bit controls whether the selected input is inverted."] pub type IFCTL_01_INV_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , IFCTL_01_INV_A > ; impl < 'a , REG , const O : u8 > IFCTL_01_INV_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NOINVERT"] # [inline (always)] pub fn ifctl_01_inv_noinvert (self) -> & 'a mut crate :: W < REG > { self . variant (IFCTL_01_INV_A :: IFCTL_01_INV_NOINVERT) } # [doc = "INVERT"] # [inline (always)] pub fn ifctl_01_inv_invert (self) -> & 'a mut crate :: W < REG > { self . variant (IFCTL_01_INV_A :: IFCTL_01_INV_INVERT) } } # [doc = "Field `IFCTL_01_FP` reader - Filter Period. This field specifies the sample period for the input filter. I.e. The input is sampled for FP timer clocks during filtering."] pub type IFCTL_01_FP_R = crate :: FieldReader < IFCTL_01_FP_A > ; # [doc = "Filter Period. This field specifies the sample period for the input filter. I.e. The input is sampled for FP timer clocks during filtering.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum IFCTL_01_FP_A { # [doc = "0: _3"] IFCTL_01_FP__3 = 0 , # [doc = "1: _5"] IFCTL_01_FP__5 = 1 , # [doc = "2: _8"] IFCTL_01_FP__8 = 2 , } impl From < IFCTL_01_FP_A > for u8 { # [inline (always)] fn from (variant : IFCTL_01_FP_A) -> Self { variant as _ } } impl crate :: FieldSpec for IFCTL_01_FP_A { type Ux = u8 ; } impl IFCTL_01_FP_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < IFCTL_01_FP_A > { match self . bits { 0 => Some (IFCTL_01_FP_A :: IFCTL_01_FP__3) , 1 => Some (IFCTL_01_FP_A :: IFCTL_01_FP__5) , 2 => Some (IFCTL_01_FP_A :: IFCTL_01_FP__8) , _ => None , } } # [doc = "_3"] # [inline (always)] pub fn is_ifctl_01_fp__3 (& self) -> bool { * self == IFCTL_01_FP_A :: IFCTL_01_FP__3 } # [doc = "_5"] # [inline (always)] pub fn is_ifctl_01_fp__5 (& self) -> bool { * self == IFCTL_01_FP_A :: IFCTL_01_FP__5 } # [doc = "_8"] # [inline (always)] pub fn is_ifctl_01_fp__8 (& self) -> bool { * self == IFCTL_01_FP_A :: IFCTL_01_FP__8 } } # [doc = "Field `IFCTL_01_FP` writer - Filter Period. This field specifies the sample period for the input filter. I.e. The input is sampled for FP timer clocks during filtering."] pub type IFCTL_01_FP_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 2 , O , IFCTL_01_FP_A > ; impl < 'a , REG , const O : u8 > IFCTL_01_FP_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "_3"] # [inline (always)] pub fn ifctl_01_fp__3 (self) -> & 'a mut crate :: W < REG > { self . variant (IFCTL_01_FP_A :: IFCTL_01_FP__3) } # [doc = "_5"] # [inline (always)] pub fn ifctl_01_fp__5 (self) -> & 'a mut crate :: W < REG > { self . variant (IFCTL_01_FP_A :: IFCTL_01_FP__5) } # [doc = "_8"] # [inline (always)] pub fn ifctl_01_fp__8 (self) -> & 'a mut crate :: W < REG > { self . variant (IFCTL_01_FP_A :: IFCTL_01_FP__8) } } # [doc = "Field `IFCTL_01_CPV` reader - Consecutive Period/Voting Select This bit controls whether the input filter uses a stricter consecutive period count or majority voting."] pub type IFCTL_01_CPV_R = crate :: BitReader < IFCTL_01_CPV_A > ; # [doc = "Consecutive Period/Voting Select This bit controls whether the input filter uses a stricter consecutive period count or majority voting.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum IFCTL_01_CPV_A { # [doc = "0: CONSECUTIVE"] IFCTL_01_CPV_CONSECUTIVE = 0 , # [doc = "1: VOTING"] IFCTL_01_CPV_VOTING = 1 , } impl From < IFCTL_01_CPV_A > for bool { # [inline (always)] fn from (variant : IFCTL_01_CPV_A) -> Self { variant as u8 != 0 } } impl IFCTL_01_CPV_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> IFCTL_01_CPV_A { match self . bits { false => IFCTL_01_CPV_A :: IFCTL_01_CPV_CONSECUTIVE , true => IFCTL_01_CPV_A :: IFCTL_01_CPV_VOTING , } } # [doc = "CONSECUTIVE"] # [inline (always)] pub fn is_ifctl_01_cpv_consecutive (& self) -> bool { * self == IFCTL_01_CPV_A :: IFCTL_01_CPV_CONSECUTIVE } # [doc = "VOTING"] # [inline (always)] pub fn is_ifctl_01_cpv_voting (& self) -> bool { * self == IFCTL_01_CPV_A :: IFCTL_01_CPV_VOTING } } # [doc = "Field `IFCTL_01_CPV` writer - Consecutive Period/Voting Select This bit controls whether the input filter uses a stricter consecutive period count or majority voting."] pub type IFCTL_01_CPV_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , IFCTL_01_CPV_A > ; impl < 'a , REG , const O : u8 > IFCTL_01_CPV_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CONSECUTIVE"] # [inline (always)] pub fn ifctl_01_cpv_consecutive (self) -> & 'a mut crate :: W < REG > { self . variant (IFCTL_01_CPV_A :: IFCTL_01_CPV_CONSECUTIVE) } # [doc = "VOTING"] # [inline (always)] pub fn ifctl_01_cpv_voting (self) -> & 'a mut crate :: W < REG > { self . variant (IFCTL_01_CPV_A :: IFCTL_01_CPV_VOTING) } } # [doc = "Field `IFCTL_01_FE` reader - Filter Enable This bit controls whether the input is filtered by the input filter or bypasses to the edge detect."] pub type IFCTL_01_FE_R = crate :: BitReader < IFCTL_01_FE_A > ; # [doc = "Filter Enable This bit controls whether the input is filtered by the input filter or bypasses to the edge detect.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum IFCTL_01_FE_A { # [doc = "0: DISABLED"] IFCTL_01_FE_DISABLED = 0 , # [doc = "1: ENABLED"] IFCTL_01_FE_ENABLED = 1 , } impl From < IFCTL_01_FE_A > for bool { # [inline (always)] fn from (variant : IFCTL_01_FE_A) -> Self { variant as u8 != 0 } } impl IFCTL_01_FE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> IFCTL_01_FE_A { match self . bits { false => IFCTL_01_FE_A :: IFCTL_01_FE_DISABLED , true => IFCTL_01_FE_A :: IFCTL_01_FE_ENABLED , } } # [doc = "DISABLED"] # [inline (always)] pub fn is_ifctl_01_fe_disabled (& self) -> bool { * self == IFCTL_01_FE_A :: IFCTL_01_FE_DISABLED } # [doc = "ENABLED"] # [inline (always)] pub fn is_ifctl_01_fe_enabled (& self) -> bool { * self == IFCTL_01_FE_A :: IFCTL_01_FE_ENABLED } } # [doc = "Field `IFCTL_01_FE` writer - Filter Enable This bit controls whether the input is filtered by the input filter or bypasses to the edge detect."] pub type IFCTL_01_FE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , IFCTL_01_FE_A > ; impl < 'a , REG , const O : u8 > IFCTL_01_FE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLED"] # [inline (always)] pub fn ifctl_01_fe_disabled (self) -> & 'a mut crate :: W < REG > { self . variant (IFCTL_01_FE_A :: IFCTL_01_FE_DISABLED) } # [doc = "ENABLED"] # [inline (always)] pub fn ifctl_01_fe_enabled (self) -> & 'a mut crate :: W < REG > { self . variant (IFCTL_01_FE_A :: IFCTL_01_FE_ENABLED) } } impl R { # [doc = "Bits 0:3 - Input Select (CCP0) This field selects the input source to the filter input. 4h-7h = Reserved"] # [inline (always)] pub fn ifctl_01_isel (& self) -> IFCTL_01_ISEL_R { IFCTL_01_ISEL_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bit 7 - Input Inversion This bit controls whether the selected input is inverted."] # [inline (always)] pub fn ifctl_01_inv (& self) -> IFCTL_01_INV_R { IFCTL_01_INV_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bits 8:9 - Filter Period. This field specifies the sample period for the input filter. I.e. The input is sampled for FP timer clocks during filtering."] # [inline (always)] pub fn ifctl_01_fp (& self) -> IFCTL_01_FP_R { IFCTL_01_FP_R :: new (((self . bits >> 8) & 3) as u8) } # [doc = "Bit 11 - Consecutive Period/Voting Select This bit controls whether the input filter uses a stricter consecutive period count or majority voting."] # [inline (always)] pub fn ifctl_01_cpv (& self) -> IFCTL_01_CPV_R { IFCTL_01_CPV_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Filter Enable This bit controls whether the input is filtered by the input filter or bypasses to the edge detect."] # [inline (always)] pub fn ifctl_01_fe (& self) -> IFCTL_01_FE_R { IFCTL_01_FE_R :: new (((self . bits >> 12) & 1) != 0) } } impl W { # [doc = "Bits 0:3 - Input Select (CCP0) This field selects the input source to the filter input. 4h-7h = Reserved"] # [inline (always)] # [must_use] pub fn ifctl_01_isel (& mut self) -> IFCTL_01_ISEL_W < IFCTL_01_SPEC , 0 > { IFCTL_01_ISEL_W :: new (self) } # [doc = "Bit 7 - Input Inversion This bit controls whether the selected input is inverted."] # [inline (always)] # [must_use] pub fn ifctl_01_inv (& mut self) -> IFCTL_01_INV_W < IFCTL_01_SPEC , 7 > { IFCTL_01_INV_W :: new (self) } # [doc = "Bits 8:9 - Filter Period. This field specifies the sample period for the input filter. I.e. The input is sampled for FP timer clocks during filtering."] # [inline (always)] # [must_use] pub fn ifctl_01_fp (& mut self) -> IFCTL_01_FP_W < IFCTL_01_SPEC , 8 > { IFCTL_01_FP_W :: new (self) } # [doc = "Bit 11 - Consecutive Period/Voting Select This bit controls whether the input filter uses a stricter consecutive period count or majority voting."] # [inline (always)] # [must_use] pub fn ifctl_01_cpv (& mut self) -> IFCTL_01_CPV_W < IFCTL_01_SPEC , 11 > { IFCTL_01_CPV_W :: new (self) } # [doc = "Bit 12 - Filter Enable This bit controls whether the input is filtered by the input filter or bypasses to the edge detect."] # [inline (always)] # [must_use] pub fn ifctl_01_fe (& mut self) -> IFCTL_01_FE_W < IFCTL_01_SPEC , 12 > { IFCTL_01_FE_W :: new (self) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Input Filter Control Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ifctl_01::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ifctl_01::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IFCTL_01_SPEC ; impl crate :: RegisterSpec for IFCTL_01_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`ifctl_01::R`](R) reader structure"] impl crate :: Readable for IFCTL_01_SPEC { } # [doc = "`write(|w| ..)` method takes [`ifctl_01::W`](W) writer structure"] impl crate :: Writable for IFCTL_01_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IFCTL_01[%s]
to value 0"] impl crate :: Resettable for IFCTL_01_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }