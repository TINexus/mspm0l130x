# [doc = "Register `MEMCTL[%s]` reader"] pub type R = crate :: R < MEMCTL_SPEC > ; # [doc = "Register `MEMCTL[%s]` writer"] pub type W = crate :: W < MEMCTL_SPEC > ; # [doc = "Field `MEMCTL_CHANSEL` reader - Input channel select."] pub type MEMCTL_CHANSEL_R = crate :: FieldReader < MEMCTL_CHANSEL_A > ; # [doc = "Input channel select.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum MEMCTL_CHANSEL_A { # [doc = "0: CHAN_0"] MEMCTL_CHANSEL_CHAN_0 = 0 , # [doc = "1: CHAN_1"] MEMCTL_CHANSEL_CHAN_1 = 1 , # [doc = "2: CHAN_2"] MEMCTL_CHANSEL_CHAN_2 = 2 , # [doc = "3: CHAN_3"] MEMCTL_CHANSEL_CHAN_3 = 3 , # [doc = "4: CHAN_4"] MEMCTL_CHANSEL_CHAN_4 = 4 , # [doc = "5: CHAN_5"] MEMCTL_CHANSEL_CHAN_5 = 5 , # [doc = "6: CHAN_6"] MEMCTL_CHANSEL_CHAN_6 = 6 , # [doc = "7: CHAN_7"] MEMCTL_CHANSEL_CHAN_7 = 7 , # [doc = "8: CHAN_8"] MEMCTL_CHANSEL_CHAN_8 = 8 , # [doc = "9: CHAN_9"] MEMCTL_CHANSEL_CHAN_9 = 9 , # [doc = "10: CHAN_10"] MEMCTL_CHANSEL_CHAN_10 = 10 , # [doc = "11: CHAN_11"] MEMCTL_CHANSEL_CHAN_11 = 11 , # [doc = "12: CHAN_12"] MEMCTL_CHANSEL_CHAN_12 = 12 , # [doc = "13: CHAN_13"] MEMCTL_CHANSEL_CHAN_13 = 13 , # [doc = "14: CHAN_14"] MEMCTL_CHANSEL_CHAN_14 = 14 , # [doc = "15: CHAN_15"] MEMCTL_CHANSEL_CHAN_15 = 15 , # [doc = "16: CHAN_16"] MEMCTL_CHANSEL_CHAN_16 = 16 , # [doc = "17: CHAN_17"] MEMCTL_CHANSEL_CHAN_17 = 17 , # [doc = "18: CHAN_18"] MEMCTL_CHANSEL_CHAN_18 = 18 , # [doc = "19: CHAN_19"] MEMCTL_CHANSEL_CHAN_19 = 19 , # [doc = "20: CHAN_20"] MEMCTL_CHANSEL_CHAN_20 = 20 , # [doc = "21: CHAN_21"] MEMCTL_CHANSEL_CHAN_21 = 21 , # [doc = "22: CHAN_22"] MEMCTL_CHANSEL_CHAN_22 = 22 , # [doc = "23: CHAN_23"] MEMCTL_CHANSEL_CHAN_23 = 23 , # [doc = "24: CHAN_24"] MEMCTL_CHANSEL_CHAN_24 = 24 , # [doc = "25: CHAN_25"] MEMCTL_CHANSEL_CHAN_25 = 25 , # [doc = "26: CHAN_26"] MEMCTL_CHANSEL_CHAN_26 = 26 , # [doc = "27: CHAN_27"] MEMCTL_CHANSEL_CHAN_27 = 27 , # [doc = "28: CHAN_28"] MEMCTL_CHANSEL_CHAN_28 = 28 , # [doc = "29: CHAN_29"] MEMCTL_CHANSEL_CHAN_29 = 29 , # [doc = "30: CHAN_30"] MEMCTL_CHANSEL_CHAN_30 = 30 , # [doc = "31: CHAN_31"] MEMCTL_CHANSEL_CHAN_31 = 31 , } impl From < MEMCTL_CHANSEL_A > for u8 { # [inline (always)] fn from (variant : MEMCTL_CHANSEL_A) -> Self { variant as _ } } impl crate :: FieldSpec for MEMCTL_CHANSEL_A { type Ux = u8 ; } impl MEMCTL_CHANSEL_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> MEMCTL_CHANSEL_A { match self . bits { 0 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_0 , 1 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_1 , 2 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_2 , 3 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_3 , 4 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_4 , 5 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_5 , 6 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_6 , 7 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_7 , 8 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_8 , 9 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_9 , 10 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_10 , 11 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_11 , 12 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_12 , 13 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_13 , 14 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_14 , 15 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_15 , 16 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_16 , 17 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_17 , 18 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_18 , 19 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_19 , 20 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_20 , 21 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_21 , 22 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_22 , 23 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_23 , 24 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_24 , 25 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_25 , 26 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_26 , 27 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_27 , 28 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_28 , 29 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_29 , 30 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_30 , 31 => MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_31 , _ => unreachable ! () , } } # [doc = "CHAN_0"] # [inline (always)] pub fn is_memctl_chansel_chan_0 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_0 } # [doc = "CHAN_1"] # [inline (always)] pub fn is_memctl_chansel_chan_1 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_1 } # [doc = "CHAN_2"] # [inline (always)] pub fn is_memctl_chansel_chan_2 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_2 } # [doc = "CHAN_3"] # [inline (always)] pub fn is_memctl_chansel_chan_3 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_3 } # [doc = "CHAN_4"] # [inline (always)] pub fn is_memctl_chansel_chan_4 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_4 } # [doc = "CHAN_5"] # [inline (always)] pub fn is_memctl_chansel_chan_5 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_5 } # [doc = "CHAN_6"] # [inline (always)] pub fn is_memctl_chansel_chan_6 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_6 } # [doc = "CHAN_7"] # [inline (always)] pub fn is_memctl_chansel_chan_7 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_7 } # [doc = "CHAN_8"] # [inline (always)] pub fn is_memctl_chansel_chan_8 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_8 } # [doc = "CHAN_9"] # [inline (always)] pub fn is_memctl_chansel_chan_9 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_9 } # [doc = "CHAN_10"] # [inline (always)] pub fn is_memctl_chansel_chan_10 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_10 } # [doc = "CHAN_11"] # [inline (always)] pub fn is_memctl_chansel_chan_11 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_11 } # [doc = "CHAN_12"] # [inline (always)] pub fn is_memctl_chansel_chan_12 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_12 } # [doc = "CHAN_13"] # [inline (always)] pub fn is_memctl_chansel_chan_13 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_13 } # [doc = "CHAN_14"] # [inline (always)] pub fn is_memctl_chansel_chan_14 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_14 } # [doc = "CHAN_15"] # [inline (always)] pub fn is_memctl_chansel_chan_15 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_15 } # [doc = "CHAN_16"] # [inline (always)] pub fn is_memctl_chansel_chan_16 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_16 } # [doc = "CHAN_17"] # [inline (always)] pub fn is_memctl_chansel_chan_17 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_17 } # [doc = "CHAN_18"] # [inline (always)] pub fn is_memctl_chansel_chan_18 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_18 } # [doc = "CHAN_19"] # [inline (always)] pub fn is_memctl_chansel_chan_19 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_19 } # [doc = "CHAN_20"] # [inline (always)] pub fn is_memctl_chansel_chan_20 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_20 } # [doc = "CHAN_21"] # [inline (always)] pub fn is_memctl_chansel_chan_21 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_21 } # [doc = "CHAN_22"] # [inline (always)] pub fn is_memctl_chansel_chan_22 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_22 } # [doc = "CHAN_23"] # [inline (always)] pub fn is_memctl_chansel_chan_23 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_23 } # [doc = "CHAN_24"] # [inline (always)] pub fn is_memctl_chansel_chan_24 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_24 } # [doc = "CHAN_25"] # [inline (always)] pub fn is_memctl_chansel_chan_25 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_25 } # [doc = "CHAN_26"] # [inline (always)] pub fn is_memctl_chansel_chan_26 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_26 } # [doc = "CHAN_27"] # [inline (always)] pub fn is_memctl_chansel_chan_27 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_27 } # [doc = "CHAN_28"] # [inline (always)] pub fn is_memctl_chansel_chan_28 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_28 } # [doc = "CHAN_29"] # [inline (always)] pub fn is_memctl_chansel_chan_29 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_29 } # [doc = "CHAN_30"] # [inline (always)] pub fn is_memctl_chansel_chan_30 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_30 } # [doc = "CHAN_31"] # [inline (always)] pub fn is_memctl_chansel_chan_31 (& self) -> bool { * self == MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_31 } } # [doc = "Field `MEMCTL_CHANSEL` writer - Input channel select."] pub type MEMCTL_CHANSEL_W < 'a , REG , const O : u8 > = crate :: FieldWriterSafe < 'a , REG , 5 , O , MEMCTL_CHANSEL_A > ; impl < 'a , REG , const O : u8 > MEMCTL_CHANSEL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "CHAN_0"] # [inline (always)] pub fn memctl_chansel_chan_0 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_0) } # [doc = "CHAN_1"] # [inline (always)] pub fn memctl_chansel_chan_1 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_1) } # [doc = "CHAN_2"] # [inline (always)] pub fn memctl_chansel_chan_2 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_2) } # [doc = "CHAN_3"] # [inline (always)] pub fn memctl_chansel_chan_3 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_3) } # [doc = "CHAN_4"] # [inline (always)] pub fn memctl_chansel_chan_4 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_4) } # [doc = "CHAN_5"] # [inline (always)] pub fn memctl_chansel_chan_5 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_5) } # [doc = "CHAN_6"] # [inline (always)] pub fn memctl_chansel_chan_6 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_6) } # [doc = "CHAN_7"] # [inline (always)] pub fn memctl_chansel_chan_7 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_7) } # [doc = "CHAN_8"] # [inline (always)] pub fn memctl_chansel_chan_8 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_8) } # [doc = "CHAN_9"] # [inline (always)] pub fn memctl_chansel_chan_9 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_9) } # [doc = "CHAN_10"] # [inline (always)] pub fn memctl_chansel_chan_10 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_10) } # [doc = "CHAN_11"] # [inline (always)] pub fn memctl_chansel_chan_11 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_11) } # [doc = "CHAN_12"] # [inline (always)] pub fn memctl_chansel_chan_12 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_12) } # [doc = "CHAN_13"] # [inline (always)] pub fn memctl_chansel_chan_13 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_13) } # [doc = "CHAN_14"] # [inline (always)] pub fn memctl_chansel_chan_14 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_14) } # [doc = "CHAN_15"] # [inline (always)] pub fn memctl_chansel_chan_15 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_15) } # [doc = "CHAN_16"] # [inline (always)] pub fn memctl_chansel_chan_16 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_16) } # [doc = "CHAN_17"] # [inline (always)] pub fn memctl_chansel_chan_17 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_17) } # [doc = "CHAN_18"] # [inline (always)] pub fn memctl_chansel_chan_18 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_18) } # [doc = "CHAN_19"] # [inline (always)] pub fn memctl_chansel_chan_19 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_19) } # [doc = "CHAN_20"] # [inline (always)] pub fn memctl_chansel_chan_20 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_20) } # [doc = "CHAN_21"] # [inline (always)] pub fn memctl_chansel_chan_21 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_21) } # [doc = "CHAN_22"] # [inline (always)] pub fn memctl_chansel_chan_22 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_22) } # [doc = "CHAN_23"] # [inline (always)] pub fn memctl_chansel_chan_23 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_23) } # [doc = "CHAN_24"] # [inline (always)] pub fn memctl_chansel_chan_24 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_24) } # [doc = "CHAN_25"] # [inline (always)] pub fn memctl_chansel_chan_25 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_25) } # [doc = "CHAN_26"] # [inline (always)] pub fn memctl_chansel_chan_26 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_26) } # [doc = "CHAN_27"] # [inline (always)] pub fn memctl_chansel_chan_27 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_27) } # [doc = "CHAN_28"] # [inline (always)] pub fn memctl_chansel_chan_28 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_28) } # [doc = "CHAN_29"] # [inline (always)] pub fn memctl_chansel_chan_29 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_29) } # [doc = "CHAN_30"] # [inline (always)] pub fn memctl_chansel_chan_30 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_30) } # [doc = "CHAN_31"] # [inline (always)] pub fn memctl_chansel_chan_31 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_CHANSEL_A :: MEMCTL_CHANSEL_CHAN_31) } } # [doc = "Field `MEMCTL_VRSEL` reader - Voltage reference selection. VEREFM must be connected to on-board ground when external reference option is selected. Note: Writing value 0x3 defaults to INTREF."] pub type MEMCTL_VRSEL_R = crate :: FieldReader < MEMCTL_VRSEL_A > ; # [doc = "Voltage reference selection. VEREFM must be connected to on-board ground when external reference option is selected. Note: Writing value 0x3 defaults to INTREF.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum MEMCTL_VRSEL_A { # [doc = "0: VDDA"] MEMCTL_VRSEL_VDDA = 0 , # [doc = "1: EXTREF"] MEMCTL_VRSEL_EXTREF = 1 , # [doc = "2: INTREF"] MEMCTL_VRSEL_INTREF = 2 , } impl From < MEMCTL_VRSEL_A > for u8 { # [inline (always)] fn from (variant : MEMCTL_VRSEL_A) -> Self { variant as _ } } impl crate :: FieldSpec for MEMCTL_VRSEL_A { type Ux = u8 ; } impl MEMCTL_VRSEL_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < MEMCTL_VRSEL_A > { match self . bits { 0 => Some (MEMCTL_VRSEL_A :: MEMCTL_VRSEL_VDDA) , 1 => Some (MEMCTL_VRSEL_A :: MEMCTL_VRSEL_EXTREF) , 2 => Some (MEMCTL_VRSEL_A :: MEMCTL_VRSEL_INTREF) , _ => None , } } # [doc = "VDDA"] # [inline (always)] pub fn is_memctl_vrsel_vdda (& self) -> bool { * self == MEMCTL_VRSEL_A :: MEMCTL_VRSEL_VDDA } # [doc = "EXTREF"] # [inline (always)] pub fn is_memctl_vrsel_extref (& self) -> bool { * self == MEMCTL_VRSEL_A :: MEMCTL_VRSEL_EXTREF } # [doc = "INTREF"] # [inline (always)] pub fn is_memctl_vrsel_intref (& self) -> bool { * self == MEMCTL_VRSEL_A :: MEMCTL_VRSEL_INTREF } } # [doc = "Field `MEMCTL_VRSEL` writer - Voltage reference selection. VEREFM must be connected to on-board ground when external reference option is selected. Note: Writing value 0x3 defaults to INTREF."] pub type MEMCTL_VRSEL_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 2 , O , MEMCTL_VRSEL_A > ; impl < 'a , REG , const O : u8 > MEMCTL_VRSEL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "VDDA"] # [inline (always)] pub fn memctl_vrsel_vdda (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_VRSEL_A :: MEMCTL_VRSEL_VDDA) } # [doc = "EXTREF"] # [inline (always)] pub fn memctl_vrsel_extref (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_VRSEL_A :: MEMCTL_VRSEL_EXTREF) } # [doc = "INTREF"] # [inline (always)] pub fn memctl_vrsel_intref (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_VRSEL_A :: MEMCTL_VRSEL_INTREF) } } # [doc = "Field `MEMCTL_STIME` reader - Selects the source of sample timer period between SCOMP0 and SCOMP1."] pub type MEMCTL_STIME_R = crate :: BitReader < MEMCTL_STIME_A > ; # [doc = "Selects the source of sample timer period between SCOMP0 and SCOMP1.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum MEMCTL_STIME_A { # [doc = "0: SEL_SCOMP0"] MEMCTL_STIME_SEL_SCOMP0 = 0 , # [doc = "1: SEL_SCOMP1"] MEMCTL_STIME_SEL_SCOMP1 = 1 , } impl From < MEMCTL_STIME_A > for bool { # [inline (always)] fn from (variant : MEMCTL_STIME_A) -> Self { variant as u8 != 0 } } impl MEMCTL_STIME_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> MEMCTL_STIME_A { match self . bits { false => MEMCTL_STIME_A :: MEMCTL_STIME_SEL_SCOMP0 , true => MEMCTL_STIME_A :: MEMCTL_STIME_SEL_SCOMP1 , } } # [doc = "SEL_SCOMP0"] # [inline (always)] pub fn is_memctl_stime_sel_scomp0 (& self) -> bool { * self == MEMCTL_STIME_A :: MEMCTL_STIME_SEL_SCOMP0 } # [doc = "SEL_SCOMP1"] # [inline (always)] pub fn is_memctl_stime_sel_scomp1 (& self) -> bool { * self == MEMCTL_STIME_A :: MEMCTL_STIME_SEL_SCOMP1 } } # [doc = "Field `MEMCTL_STIME` writer - Selects the source of sample timer period between SCOMP0 and SCOMP1."] pub type MEMCTL_STIME_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , MEMCTL_STIME_A > ; impl < 'a , REG , const O : u8 > MEMCTL_STIME_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "SEL_SCOMP0"] # [inline (always)] pub fn memctl_stime_sel_scomp0 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_STIME_A :: MEMCTL_STIME_SEL_SCOMP0) } # [doc = "SEL_SCOMP1"] # [inline (always)] pub fn memctl_stime_sel_scomp1 (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_STIME_A :: MEMCTL_STIME_SEL_SCOMP1) } } # [doc = "Field `MEMCTL_AVGEN` reader - Enable hardware averaging."] pub type MEMCTL_AVGEN_R = crate :: BitReader < MEMCTL_AVGEN_A > ; # [doc = "Enable hardware averaging.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum MEMCTL_AVGEN_A { # [doc = "0: DISABLE"] MEMCTL_AVGEN_DISABLE = 0 , # [doc = "1: ENABLE"] MEMCTL_AVGEN_ENABLE = 1 , } impl From < MEMCTL_AVGEN_A > for bool { # [inline (always)] fn from (variant : MEMCTL_AVGEN_A) -> Self { variant as u8 != 0 } } impl MEMCTL_AVGEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> MEMCTL_AVGEN_A { match self . bits { false => MEMCTL_AVGEN_A :: MEMCTL_AVGEN_DISABLE , true => MEMCTL_AVGEN_A :: MEMCTL_AVGEN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_memctl_avgen_disable (& self) -> bool { * self == MEMCTL_AVGEN_A :: MEMCTL_AVGEN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_memctl_avgen_enable (& self) -> bool { * self == MEMCTL_AVGEN_A :: MEMCTL_AVGEN_ENABLE } } # [doc = "Field `MEMCTL_AVGEN` writer - Enable hardware averaging."] pub type MEMCTL_AVGEN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , MEMCTL_AVGEN_A > ; impl < 'a , REG , const O : u8 > MEMCTL_AVGEN_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn memctl_avgen_disable (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_AVGEN_A :: MEMCTL_AVGEN_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn memctl_avgen_enable (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_AVGEN_A :: MEMCTL_AVGEN_ENABLE) } } # [doc = "Field `MEMCTL_BCSEN` reader - Enable burn out current source."] pub type MEMCTL_BCSEN_R = crate :: BitReader < MEMCTL_BCSEN_A > ; # [doc = "Enable burn out current source.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum MEMCTL_BCSEN_A { # [doc = "0: DISABLE"] MEMCTL_BCSEN_DISABLE = 0 , # [doc = "1: ENABLE"] MEMCTL_BCSEN_ENABLE = 1 , } impl From < MEMCTL_BCSEN_A > for bool { # [inline (always)] fn from (variant : MEMCTL_BCSEN_A) -> Self { variant as u8 != 0 } } impl MEMCTL_BCSEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> MEMCTL_BCSEN_A { match self . bits { false => MEMCTL_BCSEN_A :: MEMCTL_BCSEN_DISABLE , true => MEMCTL_BCSEN_A :: MEMCTL_BCSEN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_memctl_bcsen_disable (& self) -> bool { * self == MEMCTL_BCSEN_A :: MEMCTL_BCSEN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_memctl_bcsen_enable (& self) -> bool { * self == MEMCTL_BCSEN_A :: MEMCTL_BCSEN_ENABLE } } # [doc = "Field `MEMCTL_BCSEN` writer - Enable burn out current source."] pub type MEMCTL_BCSEN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , MEMCTL_BCSEN_A > ; impl < 'a , REG , const O : u8 > MEMCTL_BCSEN_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn memctl_bcsen_disable (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_BCSEN_A :: MEMCTL_BCSEN_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn memctl_bcsen_enable (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_BCSEN_A :: MEMCTL_BCSEN_ENABLE) } } # [doc = "Field `MEMCTL_TRIG` reader - Trigger policy. Indicates if a trigger will be needed to step to the next MEMCTL in the sequence or to perform next conversion in the case of repeat single channel conversions."] pub type MEMCTL_TRIG_R = crate :: BitReader < MEMCTL_TRIG_A > ; # [doc = "Trigger policy. Indicates if a trigger will be needed to step to the next MEMCTL in the sequence or to perform next conversion in the case of repeat single channel conversions.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum MEMCTL_TRIG_A { # [doc = "0: AUTO_NEXT"] MEMCTL_TRIG_AUTO_NEXT = 0 , # [doc = "1: TRIGGER_NEXT"] MEMCTL_TRIG_TRIGGER_NEXT = 1 , } impl From < MEMCTL_TRIG_A > for bool { # [inline (always)] fn from (variant : MEMCTL_TRIG_A) -> Self { variant as u8 != 0 } } impl MEMCTL_TRIG_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> MEMCTL_TRIG_A { match self . bits { false => MEMCTL_TRIG_A :: MEMCTL_TRIG_AUTO_NEXT , true => MEMCTL_TRIG_A :: MEMCTL_TRIG_TRIGGER_NEXT , } } # [doc = "AUTO_NEXT"] # [inline (always)] pub fn is_memctl_trig_auto_next (& self) -> bool { * self == MEMCTL_TRIG_A :: MEMCTL_TRIG_AUTO_NEXT } # [doc = "TRIGGER_NEXT"] # [inline (always)] pub fn is_memctl_trig_trigger_next (& self) -> bool { * self == MEMCTL_TRIG_A :: MEMCTL_TRIG_TRIGGER_NEXT } } # [doc = "Field `MEMCTL_TRIG` writer - Trigger policy. Indicates if a trigger will be needed to step to the next MEMCTL in the sequence or to perform next conversion in the case of repeat single channel conversions."] pub type MEMCTL_TRIG_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , MEMCTL_TRIG_A > ; impl < 'a , REG , const O : u8 > MEMCTL_TRIG_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "AUTO_NEXT"] # [inline (always)] pub fn memctl_trig_auto_next (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_TRIG_A :: MEMCTL_TRIG_AUTO_NEXT) } # [doc = "TRIGGER_NEXT"] # [inline (always)] pub fn memctl_trig_trigger_next (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_TRIG_A :: MEMCTL_TRIG_TRIGGER_NEXT) } } # [doc = "Field `MEMCTL_WINCOMP` reader - Enable window comparator."] pub type MEMCTL_WINCOMP_R = crate :: BitReader < MEMCTL_WINCOMP_A > ; # [doc = "Enable window comparator.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum MEMCTL_WINCOMP_A { # [doc = "0: DISABLE"] MEMCTL_WINCOMP_DISABLE = 0 , # [doc = "1: ENABLE"] MEMCTL_WINCOMP_ENABLE = 1 , } impl From < MEMCTL_WINCOMP_A > for bool { # [inline (always)] fn from (variant : MEMCTL_WINCOMP_A) -> Self { variant as u8 != 0 } } impl MEMCTL_WINCOMP_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> MEMCTL_WINCOMP_A { match self . bits { false => MEMCTL_WINCOMP_A :: MEMCTL_WINCOMP_DISABLE , true => MEMCTL_WINCOMP_A :: MEMCTL_WINCOMP_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_memctl_wincomp_disable (& self) -> bool { * self == MEMCTL_WINCOMP_A :: MEMCTL_WINCOMP_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_memctl_wincomp_enable (& self) -> bool { * self == MEMCTL_WINCOMP_A :: MEMCTL_WINCOMP_ENABLE } } # [doc = "Field `MEMCTL_WINCOMP` writer - Enable window comparator."] pub type MEMCTL_WINCOMP_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , MEMCTL_WINCOMP_A > ; impl < 'a , REG , const O : u8 > MEMCTL_WINCOMP_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn memctl_wincomp_disable (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_WINCOMP_A :: MEMCTL_WINCOMP_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn memctl_wincomp_enable (self) -> & 'a mut crate :: W < REG > { self . variant (MEMCTL_WINCOMP_A :: MEMCTL_WINCOMP_ENABLE) } } impl R { # [doc = "Bits 0:4 - Input channel select."] # [inline (always)] pub fn memctl_chansel (& self) -> MEMCTL_CHANSEL_R { MEMCTL_CHANSEL_R :: new ((self . bits & 0x1f) as u8) } # [doc = "Bits 8:9 - Voltage reference selection. VEREFM must be connected to on-board ground when external reference option is selected. Note: Writing value 0x3 defaults to INTREF."] # [inline (always)] pub fn memctl_vrsel (& self) -> MEMCTL_VRSEL_R { MEMCTL_VRSEL_R :: new (((self . bits >> 8) & 3) as u8) } # [doc = "Bit 12 - Selects the source of sample timer period between SCOMP0 and SCOMP1."] # [inline (always)] pub fn memctl_stime (& self) -> MEMCTL_STIME_R { MEMCTL_STIME_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 16 - Enable hardware averaging."] # [inline (always)] pub fn memctl_avgen (& self) -> MEMCTL_AVGEN_R { MEMCTL_AVGEN_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 20 - Enable burn out current source."] # [inline (always)] pub fn memctl_bcsen (& self) -> MEMCTL_BCSEN_R { MEMCTL_BCSEN_R :: new (((self . bits >> 20) & 1) != 0) } # [doc = "Bit 24 - Trigger policy. Indicates if a trigger will be needed to step to the next MEMCTL in the sequence or to perform next conversion in the case of repeat single channel conversions."] # [inline (always)] pub fn memctl_trig (& self) -> MEMCTL_TRIG_R { MEMCTL_TRIG_R :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 28 - Enable window comparator."] # [inline (always)] pub fn memctl_wincomp (& self) -> MEMCTL_WINCOMP_R { MEMCTL_WINCOMP_R :: new (((self . bits >> 28) & 1) != 0) } } impl W { # [doc = "Bits 0:4 - Input channel select."] # [inline (always)] # [must_use] pub fn memctl_chansel (& mut self) -> MEMCTL_CHANSEL_W < MEMCTL_SPEC , 0 > { MEMCTL_CHANSEL_W :: new (self) } # [doc = "Bits 8:9 - Voltage reference selection. VEREFM must be connected to on-board ground when external reference option is selected. Note: Writing value 0x3 defaults to INTREF."] # [inline (always)] # [must_use] pub fn memctl_vrsel (& mut self) -> MEMCTL_VRSEL_W < MEMCTL_SPEC , 8 > { MEMCTL_VRSEL_W :: new (self) } # [doc = "Bit 12 - Selects the source of sample timer period between SCOMP0 and SCOMP1."] # [inline (always)] # [must_use] pub fn memctl_stime (& mut self) -> MEMCTL_STIME_W < MEMCTL_SPEC , 12 > { MEMCTL_STIME_W :: new (self) } # [doc = "Bit 16 - Enable hardware averaging."] # [inline (always)] # [must_use] pub fn memctl_avgen (& mut self) -> MEMCTL_AVGEN_W < MEMCTL_SPEC , 16 > { MEMCTL_AVGEN_W :: new (self) } # [doc = "Bit 20 - Enable burn out current source."] # [inline (always)] # [must_use] pub fn memctl_bcsen (& mut self) -> MEMCTL_BCSEN_W < MEMCTL_SPEC , 20 > { MEMCTL_BCSEN_W :: new (self) } # [doc = "Bit 24 - Trigger policy. Indicates if a trigger will be needed to step to the next MEMCTL in the sequence or to perform next conversion in the case of repeat single channel conversions."] # [inline (always)] # [must_use] pub fn memctl_trig (& mut self) -> MEMCTL_TRIG_W < MEMCTL_SPEC , 24 > { MEMCTL_TRIG_W :: new (self) } # [doc = "Bit 28 - Enable window comparator."] # [inline (always)] # [must_use] pub fn memctl_wincomp (& mut self) -> MEMCTL_WINCOMP_W < MEMCTL_SPEC , 28 > { MEMCTL_WINCOMP_W :: new (self) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Conversion Memory Control Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`memctl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`memctl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MEMCTL_SPEC ; impl crate :: RegisterSpec for MEMCTL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`memctl::R`](R) reader structure"] impl crate :: Readable for MEMCTL_SPEC { } # [doc = "`write(|w| ..)` method takes [`memctl::W`](W) writer structure"] impl crate :: Writable for MEMCTL_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MEMCTL[%s]
to value 0"] impl crate :: Resettable for MEMCTL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }