# [doc = "Register `STATUS` reader"] pub type R = crate :: R < STATUS_SPEC > ; # [doc = "Field `STATUS_BUSY` reader - Busy. This bit indicates that an active ADC sample or conversion operation is in progress."] pub type STATUS_BUSY_R = crate :: BitReader < STATUS_BUSY_A > ; # [doc = "Busy. This bit indicates that an active ADC sample or conversion operation is in progress.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum STATUS_BUSY_A { # [doc = "0: IDLE"] STATUS_BUSY_IDLE = 0 , # [doc = "1: ACTIVE"] STATUS_BUSY_ACTIVE = 1 , } impl From < STATUS_BUSY_A > for bool { # [inline (always)] fn from (variant : STATUS_BUSY_A) -> Self { variant as u8 != 0 } } impl STATUS_BUSY_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> STATUS_BUSY_A { match self . bits { false => STATUS_BUSY_A :: STATUS_BUSY_IDLE , true => STATUS_BUSY_A :: STATUS_BUSY_ACTIVE , } } # [doc = "IDLE"] # [inline (always)] pub fn is_status_busy_idle (& self) -> bool { * self == STATUS_BUSY_A :: STATUS_BUSY_IDLE } # [doc = "ACTIVE"] # [inline (always)] pub fn is_status_busy_active (& self) -> bool { * self == STATUS_BUSY_A :: STATUS_BUSY_ACTIVE } } # [doc = "Field `STATUS_REFBUFRDY` reader - Indicates reference buffer is powered up and ready."] pub type STATUS_REFBUFRDY_R = crate :: BitReader < STATUS_REFBUFRDY_A > ; # [doc = "Indicates reference buffer is powered up and ready.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum STATUS_REFBUFRDY_A { # [doc = "0: NOTREADY"] STATUS_REFBUFRDY_NOTREADY = 0 , # [doc = "1: READY"] STATUS_REFBUFRDY_READY = 1 , } impl From < STATUS_REFBUFRDY_A > for bool { # [inline (always)] fn from (variant : STATUS_REFBUFRDY_A) -> Self { variant as u8 != 0 } } impl STATUS_REFBUFRDY_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> STATUS_REFBUFRDY_A { match self . bits { false => STATUS_REFBUFRDY_A :: STATUS_REFBUFRDY_NOTREADY , true => STATUS_REFBUFRDY_A :: STATUS_REFBUFRDY_READY , } } # [doc = "NOTREADY"] # [inline (always)] pub fn is_status_refbufrdy_notready (& self) -> bool { * self == STATUS_REFBUFRDY_A :: STATUS_REFBUFRDY_NOTREADY } # [doc = "READY"] # [inline (always)] pub fn is_status_refbufrdy_ready (& self) -> bool { * self == STATUS_REFBUFRDY_A :: STATUS_REFBUFRDY_READY } } impl R { # [doc = "Bit 0 - Busy. This bit indicates that an active ADC sample or conversion operation is in progress."] # [inline (always)] pub fn status_busy (& self) -> STATUS_BUSY_R { STATUS_BUSY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Indicates reference buffer is powered up and ready."] # [inline (always)] pub fn status_refbufrdy (& self) -> STATUS_REFBUFRDY_R { STATUS_REFBUFRDY_R :: new (((self . bits >> 1) & 1) != 0) } } # [doc = "Status Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`status::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`status::R`](R) reader structure"] impl crate :: Readable for STATUS_SPEC { } # [doc = "`reset()` method sets STATUS to value 0"] impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }