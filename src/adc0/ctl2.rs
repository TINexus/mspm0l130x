# [doc = "Register `CTL2` reader"] pub type R = crate :: R < CTL2_SPEC > ; # [doc = "Register `CTL2` writer"] pub type W = crate :: W < CTL2_SPEC > ; # [doc = "Field `CTL2_DF` reader - Data read-back format. Data is always stored in binary unsigned format."] pub type CTL2_DF_R = crate :: BitReader < CTL2_DF_A > ; # [doc = "Data read-back format. Data is always stored in binary unsigned format.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL2_DF_A { # [doc = "0: UNSIGNED"] CTL2_DF_UNSIGNED = 0 , # [doc = "1: SIGNED"] CTL2_DF_SIGNED = 1 , } impl From < CTL2_DF_A > for bool { # [inline (always)] fn from (variant : CTL2_DF_A) -> Self { variant as u8 != 0 } } impl CTL2_DF_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL2_DF_A { match self . bits { false => CTL2_DF_A :: CTL2_DF_UNSIGNED , true => CTL2_DF_A :: CTL2_DF_SIGNED , } } # [doc = "UNSIGNED"] # [inline (always)] pub fn is_ctl2_df_unsigned (& self) -> bool { * self == CTL2_DF_A :: CTL2_DF_UNSIGNED } # [doc = "SIGNED"] # [inline (always)] pub fn is_ctl2_df_signed (& self) -> bool { * self == CTL2_DF_A :: CTL2_DF_SIGNED } } # [doc = "Field `CTL2_DF` writer - Data read-back format. Data is always stored in binary unsigned format."] pub type CTL2_DF_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL2_DF_A > ; impl < 'a , REG , const O : u8 > CTL2_DF_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "UNSIGNED"] # [inline (always)] pub fn ctl2_df_unsigned (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_DF_A :: CTL2_DF_UNSIGNED) } # [doc = "SIGNED"] # [inline (always)] pub fn ctl2_df_signed (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_DF_A :: CTL2_DF_SIGNED) } } # [doc = "Field `CTL2_RES` reader - Resolution. These bits define the resolutoin of ADC conversion result. Note : A value of 3 defaults to 12-bits resolution."] pub type CTL2_RES_R = crate :: FieldReader < CTL2_RES_A > ; # [doc = "Resolution. These bits define the resolutoin of ADC conversion result. Note : A value of 3 defaults to 12-bits resolution.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CTL2_RES_A { # [doc = "0: BIT_12"] CTL2_RES_BIT_12 = 0 , # [doc = "1: BIT_10"] CTL2_RES_BIT_10 = 1 , # [doc = "2: BIT_8"] CTL2_RES_BIT_8 = 2 , } impl From < CTL2_RES_A > for u8 { # [inline (always)] fn from (variant : CTL2_RES_A) -> Self { variant as _ } } impl crate :: FieldSpec for CTL2_RES_A { type Ux = u8 ; } impl CTL2_RES_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CTL2_RES_A > { match self . bits { 0 => Some (CTL2_RES_A :: CTL2_RES_BIT_12) , 1 => Some (CTL2_RES_A :: CTL2_RES_BIT_10) , 2 => Some (CTL2_RES_A :: CTL2_RES_BIT_8) , _ => None , } } # [doc = "BIT_12"] # [inline (always)] pub fn is_ctl2_res_bit_12 (& self) -> bool { * self == CTL2_RES_A :: CTL2_RES_BIT_12 } # [doc = "BIT_10"] # [inline (always)] pub fn is_ctl2_res_bit_10 (& self) -> bool { * self == CTL2_RES_A :: CTL2_RES_BIT_10 } # [doc = "BIT_8"] # [inline (always)] pub fn is_ctl2_res_bit_8 (& self) -> bool { * self == CTL2_RES_A :: CTL2_RES_BIT_8 } } # [doc = "Field `CTL2_RES` writer - Resolution. These bits define the resolutoin of ADC conversion result. Note : A value of 3 defaults to 12-bits resolution."] pub type CTL2_RES_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 2 , O , CTL2_RES_A > ; impl < 'a , REG , const O : u8 > CTL2_RES_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "BIT_12"] # [inline (always)] pub fn ctl2_res_bit_12 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_RES_A :: CTL2_RES_BIT_12) } # [doc = "BIT_10"] # [inline (always)] pub fn ctl2_res_bit_10 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_RES_A :: CTL2_RES_BIT_10) } # [doc = "BIT_8"] # [inline (always)] pub fn ctl2_res_bit_8 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_RES_A :: CTL2_RES_BIT_8) } } # [doc = "Field `CTL2_DMAEN` reader - Enable DMA trigger for data transfer. Note: DMAEN bit is cleared by hardware based on DMA done signal at the end of data transfer. Software has to re-enable DMAEN bit for ADC to generate DMA triggers."] pub type CTL2_DMAEN_R = crate :: BitReader < CTL2_DMAEN_A > ; # [doc = "Enable DMA trigger for data transfer. Note: DMAEN bit is cleared by hardware based on DMA done signal at the end of data transfer. Software has to re-enable DMAEN bit for ADC to generate DMA triggers.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL2_DMAEN_A { # [doc = "0: DISABLE"] CTL2_DMAEN_DISABLE = 0 , # [doc = "1: ENABLE"] CTL2_DMAEN_ENABLE = 1 , } impl From < CTL2_DMAEN_A > for bool { # [inline (always)] fn from (variant : CTL2_DMAEN_A) -> Self { variant as u8 != 0 } } impl CTL2_DMAEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL2_DMAEN_A { match self . bits { false => CTL2_DMAEN_A :: CTL2_DMAEN_DISABLE , true => CTL2_DMAEN_A :: CTL2_DMAEN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_ctl2_dmaen_disable (& self) -> bool { * self == CTL2_DMAEN_A :: CTL2_DMAEN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_ctl2_dmaen_enable (& self) -> bool { * self == CTL2_DMAEN_A :: CTL2_DMAEN_ENABLE } } # [doc = "Field `CTL2_DMAEN` writer - Enable DMA trigger for data transfer. Note: DMAEN bit is cleared by hardware based on DMA done signal at the end of data transfer. Software has to re-enable DMAEN bit for ADC to generate DMA triggers."] pub type CTL2_DMAEN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL2_DMAEN_A > ; impl < 'a , REG , const O : u8 > CTL2_DMAEN_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn ctl2_dmaen_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_DMAEN_A :: CTL2_DMAEN_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn ctl2_dmaen_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_DMAEN_A :: CTL2_DMAEN_ENABLE) } } # [doc = "Field `CTL2_FIFOEN` reader - Enable FIFO based operation"] pub type CTL2_FIFOEN_R = crate :: BitReader < CTL2_FIFOEN_A > ; # [doc = "Enable FIFO based operation\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTL2_FIFOEN_A { # [doc = "0: DISABLE"] CTL2_FIFOEN_DISABLE = 0 , # [doc = "1: ENABLE"] CTL2_FIFOEN_ENABLE = 1 , } impl From < CTL2_FIFOEN_A > for bool { # [inline (always)] fn from (variant : CTL2_FIFOEN_A) -> Self { variant as u8 != 0 } } impl CTL2_FIFOEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTL2_FIFOEN_A { match self . bits { false => CTL2_FIFOEN_A :: CTL2_FIFOEN_DISABLE , true => CTL2_FIFOEN_A :: CTL2_FIFOEN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_ctl2_fifoen_disable (& self) -> bool { * self == CTL2_FIFOEN_A :: CTL2_FIFOEN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_ctl2_fifoen_enable (& self) -> bool { * self == CTL2_FIFOEN_A :: CTL2_FIFOEN_ENABLE } } # [doc = "Field `CTL2_FIFOEN` writer - Enable FIFO based operation"] pub type CTL2_FIFOEN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTL2_FIFOEN_A > ; impl < 'a , REG , const O : u8 > CTL2_FIFOEN_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLE"] # [inline (always)] pub fn ctl2_fifoen_disable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_FIFOEN_A :: CTL2_FIFOEN_DISABLE) } # [doc = "ENABLE"] # [inline (always)] pub fn ctl2_fifoen_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_FIFOEN_A :: CTL2_FIFOEN_ENABLE) } } # [doc = "Field `CTL2_SAMPCNT` reader - Number of ADC converted samples to be transferred on a DMA trigger"] pub type CTL2_SAMPCNT_R = crate :: FieldReader < CTL2_SAMPCNT_A > ; # [doc = "Number of ADC converted samples to be transferred on a DMA trigger\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CTL2_SAMPCNT_A { # [doc = "0: MIN"] CTL2_SAMPCNT_MIN = 0 , # [doc = "24: MAX"] CTL2_SAMPCNT_MAX = 24 , } impl From < CTL2_SAMPCNT_A > for u8 { # [inline (always)] fn from (variant : CTL2_SAMPCNT_A) -> Self { variant as _ } } impl crate :: FieldSpec for CTL2_SAMPCNT_A { type Ux = u8 ; } impl CTL2_SAMPCNT_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CTL2_SAMPCNT_A > { match self . bits { 0 => Some (CTL2_SAMPCNT_A :: CTL2_SAMPCNT_MIN) , 24 => Some (CTL2_SAMPCNT_A :: CTL2_SAMPCNT_MAX) , _ => None , } } # [doc = "MIN"] # [inline (always)] pub fn is_ctl2_sampcnt_min (& self) -> bool { * self == CTL2_SAMPCNT_A :: CTL2_SAMPCNT_MIN } # [doc = "MAX"] # [inline (always)] pub fn is_ctl2_sampcnt_max (& self) -> bool { * self == CTL2_SAMPCNT_A :: CTL2_SAMPCNT_MAX } } # [doc = "Field `CTL2_SAMPCNT` writer - Number of ADC converted samples to be transferred on a DMA trigger"] pub type CTL2_SAMPCNT_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 5 , O , CTL2_SAMPCNT_A > ; impl < 'a , REG , const O : u8 > CTL2_SAMPCNT_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "MIN"] # [inline (always)] pub fn ctl2_sampcnt_min (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_SAMPCNT_A :: CTL2_SAMPCNT_MIN) } # [doc = "MAX"] # [inline (always)] pub fn ctl2_sampcnt_max (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_SAMPCNT_A :: CTL2_SAMPCNT_MAX) } } # [doc = "Field `CTL2_STARTADD` reader - Sequencer start address. These bits select which MEMCTLx is used for single conversion or as first MEMCTL for sequence mode. The value of STARTADD is 0x00 to 0x17, corresponding to MEMRES0 to MEMRES23."] pub type CTL2_STARTADD_R = crate :: FieldReader < CTL2_STARTADD_A > ; # [doc = "Sequencer start address. These bits select which MEMCTLx is used for single conversion or as first MEMCTL for sequence mode. The value of STARTADD is 0x00 to 0x17, corresponding to MEMRES0 to MEMRES23.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CTL2_STARTADD_A { # [doc = "0: ADDR_00"] CTL2_STARTADD_ADDR_00 = 0 , # [doc = "1: ADDR_01"] CTL2_STARTADD_ADDR_01 = 1 , # [doc = "2: ADDR_02"] CTL2_STARTADD_ADDR_02 = 2 , # [doc = "3: ADDR_03"] CTL2_STARTADD_ADDR_03 = 3 , # [doc = "4: ADDR_04"] CTL2_STARTADD_ADDR_04 = 4 , # [doc = "5: ADDR_05"] CTL2_STARTADD_ADDR_05 = 5 , # [doc = "6: ADDR_06"] CTL2_STARTADD_ADDR_06 = 6 , # [doc = "7: ADDR_07"] CTL2_STARTADD_ADDR_07 = 7 , # [doc = "8: ADDR_08"] CTL2_STARTADD_ADDR_08 = 8 , # [doc = "9: ADDR_09"] CTL2_STARTADD_ADDR_09 = 9 , # [doc = "10: ADDR_10"] CTL2_STARTADD_ADDR_10 = 10 , # [doc = "11: ADDR_11"] CTL2_STARTADD_ADDR_11 = 11 , # [doc = "12: ADDR_12"] CTL2_STARTADD_ADDR_12 = 12 , # [doc = "13: ADDR_13"] CTL2_STARTADD_ADDR_13 = 13 , # [doc = "14: ADDR_14"] CTL2_STARTADD_ADDR_14 = 14 , # [doc = "15: ADDR_15"] CTL2_STARTADD_ADDR_15 = 15 , # [doc = "16: ADDR_16"] CTL2_STARTADD_ADDR_16 = 16 , # [doc = "17: ADDR_17"] CTL2_STARTADD_ADDR_17 = 17 , # [doc = "18: ADDR_18"] CTL2_STARTADD_ADDR_18 = 18 , # [doc = "19: ADDR_19"] CTL2_STARTADD_ADDR_19 = 19 , # [doc = "20: ADDR_20"] CTL2_STARTADD_ADDR_20 = 20 , # [doc = "21: ADDR_21"] CTL2_STARTADD_ADDR_21 = 21 , # [doc = "22: ADDR_22"] CTL2_STARTADD_ADDR_22 = 22 , # [doc = "23: ADDR_23"] CTL2_STARTADD_ADDR_23 = 23 , } impl From < CTL2_STARTADD_A > for u8 { # [inline (always)] fn from (variant : CTL2_STARTADD_A) -> Self { variant as _ } } impl crate :: FieldSpec for CTL2_STARTADD_A { type Ux = u8 ; } impl CTL2_STARTADD_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CTL2_STARTADD_A > { match self . bits { 0 => Some (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_00) , 1 => Some (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_01) , 2 => Some (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_02) , 3 => Some (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_03) , 4 => Some (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_04) , 5 => Some (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_05) , 6 => Some (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_06) , 7 => Some (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_07) , 8 => Some (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_08) , 9 => Some (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_09) , 10 => Some (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_10) , 11 => Some (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_11) , 12 => Some (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_12) , 13 => Some (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_13) , 14 => Some (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_14) , 15 => Some (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_15) , 16 => Some (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_16) , 17 => Some (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_17) , 18 => Some (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_18) , 19 => Some (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_19) , 20 => Some (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_20) , 21 => Some (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_21) , 22 => Some (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_22) , 23 => Some (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_23) , _ => None , } } # [doc = "ADDR_00"] # [inline (always)] pub fn is_ctl2_startadd_addr_00 (& self) -> bool { * self == CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_00 } # [doc = "ADDR_01"] # [inline (always)] pub fn is_ctl2_startadd_addr_01 (& self) -> bool { * self == CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_01 } # [doc = "ADDR_02"] # [inline (always)] pub fn is_ctl2_startadd_addr_02 (& self) -> bool { * self == CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_02 } # [doc = "ADDR_03"] # [inline (always)] pub fn is_ctl2_startadd_addr_03 (& self) -> bool { * self == CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_03 } # [doc = "ADDR_04"] # [inline (always)] pub fn is_ctl2_startadd_addr_04 (& self) -> bool { * self == CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_04 } # [doc = "ADDR_05"] # [inline (always)] pub fn is_ctl2_startadd_addr_05 (& self) -> bool { * self == CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_05 } # [doc = "ADDR_06"] # [inline (always)] pub fn is_ctl2_startadd_addr_06 (& self) -> bool { * self == CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_06 } # [doc = "ADDR_07"] # [inline (always)] pub fn is_ctl2_startadd_addr_07 (& self) -> bool { * self == CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_07 } # [doc = "ADDR_08"] # [inline (always)] pub fn is_ctl2_startadd_addr_08 (& self) -> bool { * self == CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_08 } # [doc = "ADDR_09"] # [inline (always)] pub fn is_ctl2_startadd_addr_09 (& self) -> bool { * self == CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_09 } # [doc = "ADDR_10"] # [inline (always)] pub fn is_ctl2_startadd_addr_10 (& self) -> bool { * self == CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_10 } # [doc = "ADDR_11"] # [inline (always)] pub fn is_ctl2_startadd_addr_11 (& self) -> bool { * self == CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_11 } # [doc = "ADDR_12"] # [inline (always)] pub fn is_ctl2_startadd_addr_12 (& self) -> bool { * self == CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_12 } # [doc = "ADDR_13"] # [inline (always)] pub fn is_ctl2_startadd_addr_13 (& self) -> bool { * self == CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_13 } # [doc = "ADDR_14"] # [inline (always)] pub fn is_ctl2_startadd_addr_14 (& self) -> bool { * self == CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_14 } # [doc = "ADDR_15"] # [inline (always)] pub fn is_ctl2_startadd_addr_15 (& self) -> bool { * self == CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_15 } # [doc = "ADDR_16"] # [inline (always)] pub fn is_ctl2_startadd_addr_16 (& self) -> bool { * self == CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_16 } # [doc = "ADDR_17"] # [inline (always)] pub fn is_ctl2_startadd_addr_17 (& self) -> bool { * self == CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_17 } # [doc = "ADDR_18"] # [inline (always)] pub fn is_ctl2_startadd_addr_18 (& self) -> bool { * self == CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_18 } # [doc = "ADDR_19"] # [inline (always)] pub fn is_ctl2_startadd_addr_19 (& self) -> bool { * self == CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_19 } # [doc = "ADDR_20"] # [inline (always)] pub fn is_ctl2_startadd_addr_20 (& self) -> bool { * self == CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_20 } # [doc = "ADDR_21"] # [inline (always)] pub fn is_ctl2_startadd_addr_21 (& self) -> bool { * self == CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_21 } # [doc = "ADDR_22"] # [inline (always)] pub fn is_ctl2_startadd_addr_22 (& self) -> bool { * self == CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_22 } # [doc = "ADDR_23"] # [inline (always)] pub fn is_ctl2_startadd_addr_23 (& self) -> bool { * self == CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_23 } } # [doc = "Field `CTL2_STARTADD` writer - Sequencer start address. These bits select which MEMCTLx is used for single conversion or as first MEMCTL for sequence mode. The value of STARTADD is 0x00 to 0x17, corresponding to MEMRES0 to MEMRES23."] pub type CTL2_STARTADD_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 5 , O , CTL2_STARTADD_A > ; impl < 'a , REG , const O : u8 > CTL2_STARTADD_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "ADDR_00"] # [inline (always)] pub fn ctl2_startadd_addr_00 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_00) } # [doc = "ADDR_01"] # [inline (always)] pub fn ctl2_startadd_addr_01 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_01) } # [doc = "ADDR_02"] # [inline (always)] pub fn ctl2_startadd_addr_02 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_02) } # [doc = "ADDR_03"] # [inline (always)] pub fn ctl2_startadd_addr_03 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_03) } # [doc = "ADDR_04"] # [inline (always)] pub fn ctl2_startadd_addr_04 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_04) } # [doc = "ADDR_05"] # [inline (always)] pub fn ctl2_startadd_addr_05 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_05) } # [doc = "ADDR_06"] # [inline (always)] pub fn ctl2_startadd_addr_06 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_06) } # [doc = "ADDR_07"] # [inline (always)] pub fn ctl2_startadd_addr_07 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_07) } # [doc = "ADDR_08"] # [inline (always)] pub fn ctl2_startadd_addr_08 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_08) } # [doc = "ADDR_09"] # [inline (always)] pub fn ctl2_startadd_addr_09 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_09) } # [doc = "ADDR_10"] # [inline (always)] pub fn ctl2_startadd_addr_10 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_10) } # [doc = "ADDR_11"] # [inline (always)] pub fn ctl2_startadd_addr_11 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_11) } # [doc = "ADDR_12"] # [inline (always)] pub fn ctl2_startadd_addr_12 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_12) } # [doc = "ADDR_13"] # [inline (always)] pub fn ctl2_startadd_addr_13 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_13) } # [doc = "ADDR_14"] # [inline (always)] pub fn ctl2_startadd_addr_14 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_14) } # [doc = "ADDR_15"] # [inline (always)] pub fn ctl2_startadd_addr_15 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_15) } # [doc = "ADDR_16"] # [inline (always)] pub fn ctl2_startadd_addr_16 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_16) } # [doc = "ADDR_17"] # [inline (always)] pub fn ctl2_startadd_addr_17 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_17) } # [doc = "ADDR_18"] # [inline (always)] pub fn ctl2_startadd_addr_18 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_18) } # [doc = "ADDR_19"] # [inline (always)] pub fn ctl2_startadd_addr_19 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_19) } # [doc = "ADDR_20"] # [inline (always)] pub fn ctl2_startadd_addr_20 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_20) } # [doc = "ADDR_21"] # [inline (always)] pub fn ctl2_startadd_addr_21 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_21) } # [doc = "ADDR_22"] # [inline (always)] pub fn ctl2_startadd_addr_22 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_22) } # [doc = "ADDR_23"] # [inline (always)] pub fn ctl2_startadd_addr_23 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_STARTADD_A :: CTL2_STARTADD_ADDR_23) } } # [doc = "Field `CTL2_ENDADD` reader - Sequence end address. These bits select which MEMCTLx is the last one for the sequence mode. The value of ENDADD is 0x00 to 0x17, corresponding to MEMRES0 to MEMRES23."] pub type CTL2_ENDADD_R = crate :: FieldReader < CTL2_ENDADD_A > ; # [doc = "Sequence end address. These bits select which MEMCTLx is the last one for the sequence mode. The value of ENDADD is 0x00 to 0x17, corresponding to MEMRES0 to MEMRES23.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CTL2_ENDADD_A { # [doc = "0: ADDR_00"] CTL2_ENDADD_ADDR_00 = 0 , # [doc = "1: ADDR_01"] CTL2_ENDADD_ADDR_01 = 1 , # [doc = "2: ADDR_02"] CTL2_ENDADD_ADDR_02 = 2 , # [doc = "3: ADDR_03"] CTL2_ENDADD_ADDR_03 = 3 , # [doc = "4: ADDR_04"] CTL2_ENDADD_ADDR_04 = 4 , # [doc = "5: ADDR_05"] CTL2_ENDADD_ADDR_05 = 5 , # [doc = "6: ADDR_06"] CTL2_ENDADD_ADDR_06 = 6 , # [doc = "7: ADDR_07"] CTL2_ENDADD_ADDR_07 = 7 , # [doc = "8: ADDR_08"] CTL2_ENDADD_ADDR_08 = 8 , # [doc = "9: ADDR_09"] CTL2_ENDADD_ADDR_09 = 9 , # [doc = "10: ADDR_10"] CTL2_ENDADD_ADDR_10 = 10 , # [doc = "11: ADDR_11"] CTL2_ENDADD_ADDR_11 = 11 , # [doc = "12: ADDR_12"] CTL2_ENDADD_ADDR_12 = 12 , # [doc = "13: ADDR_13"] CTL2_ENDADD_ADDR_13 = 13 , # [doc = "14: ADDR_14"] CTL2_ENDADD_ADDR_14 = 14 , # [doc = "15: ADDR_15"] CTL2_ENDADD_ADDR_15 = 15 , # [doc = "16: ADDR_16"] CTL2_ENDADD_ADDR_16 = 16 , # [doc = "17: ADDR_17"] CTL2_ENDADD_ADDR_17 = 17 , # [doc = "18: ADDR_18"] CTL2_ENDADD_ADDR_18 = 18 , # [doc = "19: ADDR_19"] CTL2_ENDADD_ADDR_19 = 19 , # [doc = "20: ADDR_20"] CTL2_ENDADD_ADDR_20 = 20 , # [doc = "21: ADDR_21"] CTL2_ENDADD_ADDR_21 = 21 , # [doc = "22: ADDR_22"] CTL2_ENDADD_ADDR_22 = 22 , # [doc = "23: ADDR_23"] CTL2_ENDADD_ADDR_23 = 23 , } impl From < CTL2_ENDADD_A > for u8 { # [inline (always)] fn from (variant : CTL2_ENDADD_A) -> Self { variant as _ } } impl crate :: FieldSpec for CTL2_ENDADD_A { type Ux = u8 ; } impl CTL2_ENDADD_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CTL2_ENDADD_A > { match self . bits { 0 => Some (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_00) , 1 => Some (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_01) , 2 => Some (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_02) , 3 => Some (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_03) , 4 => Some (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_04) , 5 => Some (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_05) , 6 => Some (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_06) , 7 => Some (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_07) , 8 => Some (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_08) , 9 => Some (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_09) , 10 => Some (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_10) , 11 => Some (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_11) , 12 => Some (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_12) , 13 => Some (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_13) , 14 => Some (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_14) , 15 => Some (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_15) , 16 => Some (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_16) , 17 => Some (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_17) , 18 => Some (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_18) , 19 => Some (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_19) , 20 => Some (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_20) , 21 => Some (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_21) , 22 => Some (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_22) , 23 => Some (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_23) , _ => None , } } # [doc = "ADDR_00"] # [inline (always)] pub fn is_ctl2_endadd_addr_00 (& self) -> bool { * self == CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_00 } # [doc = "ADDR_01"] # [inline (always)] pub fn is_ctl2_endadd_addr_01 (& self) -> bool { * self == CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_01 } # [doc = "ADDR_02"] # [inline (always)] pub fn is_ctl2_endadd_addr_02 (& self) -> bool { * self == CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_02 } # [doc = "ADDR_03"] # [inline (always)] pub fn is_ctl2_endadd_addr_03 (& self) -> bool { * self == CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_03 } # [doc = "ADDR_04"] # [inline (always)] pub fn is_ctl2_endadd_addr_04 (& self) -> bool { * self == CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_04 } # [doc = "ADDR_05"] # [inline (always)] pub fn is_ctl2_endadd_addr_05 (& self) -> bool { * self == CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_05 } # [doc = "ADDR_06"] # [inline (always)] pub fn is_ctl2_endadd_addr_06 (& self) -> bool { * self == CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_06 } # [doc = "ADDR_07"] # [inline (always)] pub fn is_ctl2_endadd_addr_07 (& self) -> bool { * self == CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_07 } # [doc = "ADDR_08"] # [inline (always)] pub fn is_ctl2_endadd_addr_08 (& self) -> bool { * self == CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_08 } # [doc = "ADDR_09"] # [inline (always)] pub fn is_ctl2_endadd_addr_09 (& self) -> bool { * self == CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_09 } # [doc = "ADDR_10"] # [inline (always)] pub fn is_ctl2_endadd_addr_10 (& self) -> bool { * self == CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_10 } # [doc = "ADDR_11"] # [inline (always)] pub fn is_ctl2_endadd_addr_11 (& self) -> bool { * self == CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_11 } # [doc = "ADDR_12"] # [inline (always)] pub fn is_ctl2_endadd_addr_12 (& self) -> bool { * self == CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_12 } # [doc = "ADDR_13"] # [inline (always)] pub fn is_ctl2_endadd_addr_13 (& self) -> bool { * self == CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_13 } # [doc = "ADDR_14"] # [inline (always)] pub fn is_ctl2_endadd_addr_14 (& self) -> bool { * self == CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_14 } # [doc = "ADDR_15"] # [inline (always)] pub fn is_ctl2_endadd_addr_15 (& self) -> bool { * self == CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_15 } # [doc = "ADDR_16"] # [inline (always)] pub fn is_ctl2_endadd_addr_16 (& self) -> bool { * self == CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_16 } # [doc = "ADDR_17"] # [inline (always)] pub fn is_ctl2_endadd_addr_17 (& self) -> bool { * self == CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_17 } # [doc = "ADDR_18"] # [inline (always)] pub fn is_ctl2_endadd_addr_18 (& self) -> bool { * self == CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_18 } # [doc = "ADDR_19"] # [inline (always)] pub fn is_ctl2_endadd_addr_19 (& self) -> bool { * self == CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_19 } # [doc = "ADDR_20"] # [inline (always)] pub fn is_ctl2_endadd_addr_20 (& self) -> bool { * self == CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_20 } # [doc = "ADDR_21"] # [inline (always)] pub fn is_ctl2_endadd_addr_21 (& self) -> bool { * self == CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_21 } # [doc = "ADDR_22"] # [inline (always)] pub fn is_ctl2_endadd_addr_22 (& self) -> bool { * self == CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_22 } # [doc = "ADDR_23"] # [inline (always)] pub fn is_ctl2_endadd_addr_23 (& self) -> bool { * self == CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_23 } } # [doc = "Field `CTL2_ENDADD` writer - Sequence end address. These bits select which MEMCTLx is the last one for the sequence mode. The value of ENDADD is 0x00 to 0x17, corresponding to MEMRES0 to MEMRES23."] pub type CTL2_ENDADD_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 5 , O , CTL2_ENDADD_A > ; impl < 'a , REG , const O : u8 > CTL2_ENDADD_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "ADDR_00"] # [inline (always)] pub fn ctl2_endadd_addr_00 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_00) } # [doc = "ADDR_01"] # [inline (always)] pub fn ctl2_endadd_addr_01 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_01) } # [doc = "ADDR_02"] # [inline (always)] pub fn ctl2_endadd_addr_02 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_02) } # [doc = "ADDR_03"] # [inline (always)] pub fn ctl2_endadd_addr_03 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_03) } # [doc = "ADDR_04"] # [inline (always)] pub fn ctl2_endadd_addr_04 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_04) } # [doc = "ADDR_05"] # [inline (always)] pub fn ctl2_endadd_addr_05 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_05) } # [doc = "ADDR_06"] # [inline (always)] pub fn ctl2_endadd_addr_06 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_06) } # [doc = "ADDR_07"] # [inline (always)] pub fn ctl2_endadd_addr_07 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_07) } # [doc = "ADDR_08"] # [inline (always)] pub fn ctl2_endadd_addr_08 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_08) } # [doc = "ADDR_09"] # [inline (always)] pub fn ctl2_endadd_addr_09 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_09) } # [doc = "ADDR_10"] # [inline (always)] pub fn ctl2_endadd_addr_10 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_10) } # [doc = "ADDR_11"] # [inline (always)] pub fn ctl2_endadd_addr_11 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_11) } # [doc = "ADDR_12"] # [inline (always)] pub fn ctl2_endadd_addr_12 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_12) } # [doc = "ADDR_13"] # [inline (always)] pub fn ctl2_endadd_addr_13 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_13) } # [doc = "ADDR_14"] # [inline (always)] pub fn ctl2_endadd_addr_14 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_14) } # [doc = "ADDR_15"] # [inline (always)] pub fn ctl2_endadd_addr_15 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_15) } # [doc = "ADDR_16"] # [inline (always)] pub fn ctl2_endadd_addr_16 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_16) } # [doc = "ADDR_17"] # [inline (always)] pub fn ctl2_endadd_addr_17 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_17) } # [doc = "ADDR_18"] # [inline (always)] pub fn ctl2_endadd_addr_18 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_18) } # [doc = "ADDR_19"] # [inline (always)] pub fn ctl2_endadd_addr_19 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_19) } # [doc = "ADDR_20"] # [inline (always)] pub fn ctl2_endadd_addr_20 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_20) } # [doc = "ADDR_21"] # [inline (always)] pub fn ctl2_endadd_addr_21 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_21) } # [doc = "ADDR_22"] # [inline (always)] pub fn ctl2_endadd_addr_22 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_22) } # [doc = "ADDR_23"] # [inline (always)] pub fn ctl2_endadd_addr_23 (self) -> & 'a mut crate :: W < REG > { self . variant (CTL2_ENDADD_A :: CTL2_ENDADD_ADDR_23) } } impl R { # [doc = "Bit 0 - Data read-back format. Data is always stored in binary unsigned format."] # [inline (always)] pub fn ctl2_df (& self) -> CTL2_DF_R { CTL2_DF_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Resolution. These bits define the resolutoin of ADC conversion result. Note : A value of 3 defaults to 12-bits resolution."] # [inline (always)] pub fn ctl2_res (& self) -> CTL2_RES_R { CTL2_RES_R :: new (((self . bits >> 1) & 3) as u8) } # [doc = "Bit 8 - Enable DMA trigger for data transfer. Note: DMAEN bit is cleared by hardware based on DMA done signal at the end of data transfer. Software has to re-enable DMAEN bit for ADC to generate DMA triggers."] # [inline (always)] pub fn ctl2_dmaen (& self) -> CTL2_DMAEN_R { CTL2_DMAEN_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 10 - Enable FIFO based operation"] # [inline (always)] pub fn ctl2_fifoen (& self) -> CTL2_FIFOEN_R { CTL2_FIFOEN_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bits 11:15 - Number of ADC converted samples to be transferred on a DMA trigger"] # [inline (always)] pub fn ctl2_sampcnt (& self) -> CTL2_SAMPCNT_R { CTL2_SAMPCNT_R :: new (((self . bits >> 11) & 0x1f) as u8) } # [doc = "Bits 16:20 - Sequencer start address. These bits select which MEMCTLx is used for single conversion or as first MEMCTL for sequence mode. The value of STARTADD is 0x00 to 0x17, corresponding to MEMRES0 to MEMRES23."] # [inline (always)] pub fn ctl2_startadd (& self) -> CTL2_STARTADD_R { CTL2_STARTADD_R :: new (((self . bits >> 16) & 0x1f) as u8) } # [doc = "Bits 24:28 - Sequence end address. These bits select which MEMCTLx is the last one for the sequence mode. The value of ENDADD is 0x00 to 0x17, corresponding to MEMRES0 to MEMRES23."] # [inline (always)] pub fn ctl2_endadd (& self) -> CTL2_ENDADD_R { CTL2_ENDADD_R :: new (((self . bits >> 24) & 0x1f) as u8) } } impl W { # [doc = "Bit 0 - Data read-back format. Data is always stored in binary unsigned format."] # [inline (always)] # [must_use] pub fn ctl2_df (& mut self) -> CTL2_DF_W < CTL2_SPEC , 0 > { CTL2_DF_W :: new (self) } # [doc = "Bits 1:2 - Resolution. These bits define the resolutoin of ADC conversion result. Note : A value of 3 defaults to 12-bits resolution."] # [inline (always)] # [must_use] pub fn ctl2_res (& mut self) -> CTL2_RES_W < CTL2_SPEC , 1 > { CTL2_RES_W :: new (self) } # [doc = "Bit 8 - Enable DMA trigger for data transfer. Note: DMAEN bit is cleared by hardware based on DMA done signal at the end of data transfer. Software has to re-enable DMAEN bit for ADC to generate DMA triggers."] # [inline (always)] # [must_use] pub fn ctl2_dmaen (& mut self) -> CTL2_DMAEN_W < CTL2_SPEC , 8 > { CTL2_DMAEN_W :: new (self) } # [doc = "Bit 10 - Enable FIFO based operation"] # [inline (always)] # [must_use] pub fn ctl2_fifoen (& mut self) -> CTL2_FIFOEN_W < CTL2_SPEC , 10 > { CTL2_FIFOEN_W :: new (self) } # [doc = "Bits 11:15 - Number of ADC converted samples to be transferred on a DMA trigger"] # [inline (always)] # [must_use] pub fn ctl2_sampcnt (& mut self) -> CTL2_SAMPCNT_W < CTL2_SPEC , 11 > { CTL2_SAMPCNT_W :: new (self) } # [doc = "Bits 16:20 - Sequencer start address. These bits select which MEMCTLx is used for single conversion or as first MEMCTL for sequence mode. The value of STARTADD is 0x00 to 0x17, corresponding to MEMRES0 to MEMRES23."] # [inline (always)] # [must_use] pub fn ctl2_startadd (& mut self) -> CTL2_STARTADD_W < CTL2_SPEC , 16 > { CTL2_STARTADD_W :: new (self) } # [doc = "Bits 24:28 - Sequence end address. These bits select which MEMCTLx is the last one for the sequence mode. The value of ENDADD is 0x00 to 0x17, corresponding to MEMRES0 to MEMRES23."] # [inline (always)] # [must_use] pub fn ctl2_endadd (& mut self) -> CTL2_ENDADD_W < CTL2_SPEC , 24 > { CTL2_ENDADD_W :: new (self) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Control Register 2\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ctl2::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctl2::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CTL2_SPEC ; impl crate :: RegisterSpec for CTL2_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`ctl2::R`](R) reader structure"] impl crate :: Readable for CTL2_SPEC { } # [doc = "`write(|w| ..)` method takes [`ctl2::W`](W) writer structure"] impl crate :: Writable for CTL2_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTL2 to value 0"] impl crate :: Resettable for CTL2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }