# [doc = "Register `CCCTL_01[%s]` reader"] pub type R = crate :: R < CCCTL_01_SPEC > ; # [doc = "Register `CCCTL_01[%s]` writer"] pub type W = crate :: W < CCCTL_01_SPEC > ; # [doc = "Field `CCCTL_01_CCOND` reader - Capture Condition. #br# Specifies the condition that generates a capture pulse. 4h-Fh = Reserved"] pub type CCCTL_01_CCOND_R = crate :: FieldReader < CCCTL_01_CCOND_A > ; # [doc = "Capture Condition. #br# Specifies the condition that generates a capture pulse. 4h-Fh = Reserved\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CCCTL_01_CCOND_A { # [doc = "0: NOCAPTURE"] CCCTL_01_CCOND_NOCAPTURE = 0 , # [doc = "1: CC_TRIG_RISE"] CCCTL_01_CCOND_CC_TRIG_RISE = 1 , # [doc = "2: CC_TRIG_FALL"] CCCTL_01_CCOND_CC_TRIG_FALL = 2 , # [doc = "3: CC_TRIG_EDGE"] CCCTL_01_CCOND_CC_TRIG_EDGE = 3 , } impl From < CCCTL_01_CCOND_A > for u8 { # [inline (always)] fn from (variant : CCCTL_01_CCOND_A) -> Self { variant as _ } } impl crate :: FieldSpec for CCCTL_01_CCOND_A { type Ux = u8 ; } impl CCCTL_01_CCOND_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CCCTL_01_CCOND_A > { match self . bits { 0 => Some (CCCTL_01_CCOND_A :: CCCTL_01_CCOND_NOCAPTURE) , 1 => Some (CCCTL_01_CCOND_A :: CCCTL_01_CCOND_CC_TRIG_RISE) , 2 => Some (CCCTL_01_CCOND_A :: CCCTL_01_CCOND_CC_TRIG_FALL) , 3 => Some (CCCTL_01_CCOND_A :: CCCTL_01_CCOND_CC_TRIG_EDGE) , _ => None , } } # [doc = "NOCAPTURE"] # [inline (always)] pub fn is_ccctl_01_ccond_nocapture (& self) -> bool { * self == CCCTL_01_CCOND_A :: CCCTL_01_CCOND_NOCAPTURE } # [doc = "CC_TRIG_RISE"] # [inline (always)] pub fn is_ccctl_01_ccond_cc_trig_rise (& self) -> bool { * self == CCCTL_01_CCOND_A :: CCCTL_01_CCOND_CC_TRIG_RISE } # [doc = "CC_TRIG_FALL"] # [inline (always)] pub fn is_ccctl_01_ccond_cc_trig_fall (& self) -> bool { * self == CCCTL_01_CCOND_A :: CCCTL_01_CCOND_CC_TRIG_FALL } # [doc = "CC_TRIG_EDGE"] # [inline (always)] pub fn is_ccctl_01_ccond_cc_trig_edge (& self) -> bool { * self == CCCTL_01_CCOND_A :: CCCTL_01_CCOND_CC_TRIG_EDGE } } # [doc = "Field `CCCTL_01_CCOND` writer - Capture Condition. #br# Specifies the condition that generates a capture pulse. 4h-Fh = Reserved"] pub type CCCTL_01_CCOND_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 3 , O , CCCTL_01_CCOND_A > ; impl < 'a , REG , const O : u8 > CCCTL_01_CCOND_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "NOCAPTURE"] # [inline (always)] pub fn ccctl_01_ccond_nocapture (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CCOND_A :: CCCTL_01_CCOND_NOCAPTURE) } # [doc = "CC_TRIG_RISE"] # [inline (always)] pub fn ccctl_01_ccond_cc_trig_rise (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CCOND_A :: CCCTL_01_CCOND_CC_TRIG_RISE) } # [doc = "CC_TRIG_FALL"] # [inline (always)] pub fn ccctl_01_ccond_cc_trig_fall (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CCOND_A :: CCCTL_01_CCOND_CC_TRIG_FALL) } # [doc = "CC_TRIG_EDGE"] # [inline (always)] pub fn ccctl_01_ccond_cc_trig_edge (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CCOND_A :: CCCTL_01_CCOND_CC_TRIG_EDGE) } } # [doc = "Field `CCCTL_01_ACOND` reader - Advance Condition. #br# Specifies the condition that generates an advance pulse. 6h-Fh = Reserved"] pub type CCCTL_01_ACOND_R = crate :: FieldReader < CCCTL_01_ACOND_A > ; # [doc = "Advance Condition. #br# Specifies the condition that generates an advance pulse. 6h-Fh = Reserved\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CCCTL_01_ACOND_A { # [doc = "0: TIMCLK"] CCCTL_01_ACOND_TIMCLK = 0 , # [doc = "1: CC_TRIG_RISE"] CCCTL_01_ACOND_CC_TRIG_RISE = 1 , # [doc = "2: CC_TRIG_FALL"] CCCTL_01_ACOND_CC_TRIG_FALL = 2 , # [doc = "3: CC_TRIG_EDGE"] CCCTL_01_ACOND_CC_TRIG_EDGE = 3 , # [doc = "5: CC_TRIG_HIGH"] CCCTL_01_ACOND_CC_TRIG_HIGH = 5 , } impl From < CCCTL_01_ACOND_A > for u8 { # [inline (always)] fn from (variant : CCCTL_01_ACOND_A) -> Self { variant as _ } } impl crate :: FieldSpec for CCCTL_01_ACOND_A { type Ux = u8 ; } impl CCCTL_01_ACOND_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CCCTL_01_ACOND_A > { match self . bits { 0 => Some (CCCTL_01_ACOND_A :: CCCTL_01_ACOND_TIMCLK) , 1 => Some (CCCTL_01_ACOND_A :: CCCTL_01_ACOND_CC_TRIG_RISE) , 2 => Some (CCCTL_01_ACOND_A :: CCCTL_01_ACOND_CC_TRIG_FALL) , 3 => Some (CCCTL_01_ACOND_A :: CCCTL_01_ACOND_CC_TRIG_EDGE) , 5 => Some (CCCTL_01_ACOND_A :: CCCTL_01_ACOND_CC_TRIG_HIGH) , _ => None , } } # [doc = "TIMCLK"] # [inline (always)] pub fn is_ccctl_01_acond_timclk (& self) -> bool { * self == CCCTL_01_ACOND_A :: CCCTL_01_ACOND_TIMCLK } # [doc = "CC_TRIG_RISE"] # [inline (always)] pub fn is_ccctl_01_acond_cc_trig_rise (& self) -> bool { * self == CCCTL_01_ACOND_A :: CCCTL_01_ACOND_CC_TRIG_RISE } # [doc = "CC_TRIG_FALL"] # [inline (always)] pub fn is_ccctl_01_acond_cc_trig_fall (& self) -> bool { * self == CCCTL_01_ACOND_A :: CCCTL_01_ACOND_CC_TRIG_FALL } # [doc = "CC_TRIG_EDGE"] # [inline (always)] pub fn is_ccctl_01_acond_cc_trig_edge (& self) -> bool { * self == CCCTL_01_ACOND_A :: CCCTL_01_ACOND_CC_TRIG_EDGE } # [doc = "CC_TRIG_HIGH"] # [inline (always)] pub fn is_ccctl_01_acond_cc_trig_high (& self) -> bool { * self == CCCTL_01_ACOND_A :: CCCTL_01_ACOND_CC_TRIG_HIGH } } # [doc = "Field `CCCTL_01_ACOND` writer - Advance Condition. #br# Specifies the condition that generates an advance pulse. 6h-Fh = Reserved"] pub type CCCTL_01_ACOND_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 3 , O , CCCTL_01_ACOND_A > ; impl < 'a , REG , const O : u8 > CCCTL_01_ACOND_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "TIMCLK"] # [inline (always)] pub fn ccctl_01_acond_timclk (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_ACOND_A :: CCCTL_01_ACOND_TIMCLK) } # [doc = "CC_TRIG_RISE"] # [inline (always)] pub fn ccctl_01_acond_cc_trig_rise (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_ACOND_A :: CCCTL_01_ACOND_CC_TRIG_RISE) } # [doc = "CC_TRIG_FALL"] # [inline (always)] pub fn ccctl_01_acond_cc_trig_fall (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_ACOND_A :: CCCTL_01_ACOND_CC_TRIG_FALL) } # [doc = "CC_TRIG_EDGE"] # [inline (always)] pub fn ccctl_01_acond_cc_trig_edge (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_ACOND_A :: CCCTL_01_ACOND_CC_TRIG_EDGE) } # [doc = "CC_TRIG_HIGH"] # [inline (always)] pub fn ccctl_01_acond_cc_trig_high (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_ACOND_A :: CCCTL_01_ACOND_CC_TRIG_HIGH) } } # [doc = "Field `CCCTL_01_LCOND` reader - Load Condition. #br# Specifies the condition that generates a load pulse. 4h-Fh = Reserved"] pub type CCCTL_01_LCOND_R = crate :: FieldReader < CCCTL_01_LCOND_A > ; # [doc = "Load Condition. #br# Specifies the condition that generates a load pulse. 4h-Fh = Reserved\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CCCTL_01_LCOND_A { # [doc = "1: CC_TRIG_RISE"] CCCTL_01_LCOND_CC_TRIG_RISE = 1 , # [doc = "2: CC_TRIG_FALL"] CCCTL_01_LCOND_CC_TRIG_FALL = 2 , # [doc = "3: CC_TRIG_EDGE"] CCCTL_01_LCOND_CC_TRIG_EDGE = 3 , } impl From < CCCTL_01_LCOND_A > for u8 { # [inline (always)] fn from (variant : CCCTL_01_LCOND_A) -> Self { variant as _ } } impl crate :: FieldSpec for CCCTL_01_LCOND_A { type Ux = u8 ; } impl CCCTL_01_LCOND_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CCCTL_01_LCOND_A > { match self . bits { 1 => Some (CCCTL_01_LCOND_A :: CCCTL_01_LCOND_CC_TRIG_RISE) , 2 => Some (CCCTL_01_LCOND_A :: CCCTL_01_LCOND_CC_TRIG_FALL) , 3 => Some (CCCTL_01_LCOND_A :: CCCTL_01_LCOND_CC_TRIG_EDGE) , _ => None , } } # [doc = "CC_TRIG_RISE"] # [inline (always)] pub fn is_ccctl_01_lcond_cc_trig_rise (& self) -> bool { * self == CCCTL_01_LCOND_A :: CCCTL_01_LCOND_CC_TRIG_RISE } # [doc = "CC_TRIG_FALL"] # [inline (always)] pub fn is_ccctl_01_lcond_cc_trig_fall (& self) -> bool { * self == CCCTL_01_LCOND_A :: CCCTL_01_LCOND_CC_TRIG_FALL } # [doc = "CC_TRIG_EDGE"] # [inline (always)] pub fn is_ccctl_01_lcond_cc_trig_edge (& self) -> bool { * self == CCCTL_01_LCOND_A :: CCCTL_01_LCOND_CC_TRIG_EDGE } } # [doc = "Field `CCCTL_01_LCOND` writer - Load Condition. #br# Specifies the condition that generates a load pulse. 4h-Fh = Reserved"] pub type CCCTL_01_LCOND_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 3 , O , CCCTL_01_LCOND_A > ; impl < 'a , REG , const O : u8 > CCCTL_01_LCOND_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "CC_TRIG_RISE"] # [inline (always)] pub fn ccctl_01_lcond_cc_trig_rise (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_LCOND_A :: CCCTL_01_LCOND_CC_TRIG_RISE) } # [doc = "CC_TRIG_FALL"] # [inline (always)] pub fn ccctl_01_lcond_cc_trig_fall (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_LCOND_A :: CCCTL_01_LCOND_CC_TRIG_FALL) } # [doc = "CC_TRIG_EDGE"] # [inline (always)] pub fn ccctl_01_lcond_cc_trig_edge (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_LCOND_A :: CCCTL_01_LCOND_CC_TRIG_EDGE) } } # [doc = "Field `CCCTL_01_ZCOND` reader - Zero Condition. #br# This field specifies the condition that generates a zero pulse. 4h-Fh = Reserved"] pub type CCCTL_01_ZCOND_R = crate :: FieldReader < CCCTL_01_ZCOND_A > ; # [doc = "Zero Condition. #br# This field specifies the condition that generates a zero pulse. 4h-Fh = Reserved\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CCCTL_01_ZCOND_A { # [doc = "1: CC_TRIG_RISE"] CCCTL_01_ZCOND_CC_TRIG_RISE = 1 , # [doc = "2: CC_TRIG_FALL"] CCCTL_01_ZCOND_CC_TRIG_FALL = 2 , # [doc = "3: CC_TRIG_EDGE"] CCCTL_01_ZCOND_CC_TRIG_EDGE = 3 , } impl From < CCCTL_01_ZCOND_A > for u8 { # [inline (always)] fn from (variant : CCCTL_01_ZCOND_A) -> Self { variant as _ } } impl crate :: FieldSpec for CCCTL_01_ZCOND_A { type Ux = u8 ; } impl CCCTL_01_ZCOND_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CCCTL_01_ZCOND_A > { match self . bits { 1 => Some (CCCTL_01_ZCOND_A :: CCCTL_01_ZCOND_CC_TRIG_RISE) , 2 => Some (CCCTL_01_ZCOND_A :: CCCTL_01_ZCOND_CC_TRIG_FALL) , 3 => Some (CCCTL_01_ZCOND_A :: CCCTL_01_ZCOND_CC_TRIG_EDGE) , _ => None , } } # [doc = "CC_TRIG_RISE"] # [inline (always)] pub fn is_ccctl_01_zcond_cc_trig_rise (& self) -> bool { * self == CCCTL_01_ZCOND_A :: CCCTL_01_ZCOND_CC_TRIG_RISE } # [doc = "CC_TRIG_FALL"] # [inline (always)] pub fn is_ccctl_01_zcond_cc_trig_fall (& self) -> bool { * self == CCCTL_01_ZCOND_A :: CCCTL_01_ZCOND_CC_TRIG_FALL } # [doc = "CC_TRIG_EDGE"] # [inline (always)] pub fn is_ccctl_01_zcond_cc_trig_edge (& self) -> bool { * self == CCCTL_01_ZCOND_A :: CCCTL_01_ZCOND_CC_TRIG_EDGE } } # [doc = "Field `CCCTL_01_ZCOND` writer - Zero Condition. #br# This field specifies the condition that generates a zero pulse. 4h-Fh = Reserved"] pub type CCCTL_01_ZCOND_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 3 , O , CCCTL_01_ZCOND_A > ; impl < 'a , REG , const O : u8 > CCCTL_01_ZCOND_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "CC_TRIG_RISE"] # [inline (always)] pub fn ccctl_01_zcond_cc_trig_rise (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_ZCOND_A :: CCCTL_01_ZCOND_CC_TRIG_RISE) } # [doc = "CC_TRIG_FALL"] # [inline (always)] pub fn ccctl_01_zcond_cc_trig_fall (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_ZCOND_A :: CCCTL_01_ZCOND_CC_TRIG_FALL) } # [doc = "CC_TRIG_EDGE"] # [inline (always)] pub fn ccctl_01_zcond_cc_trig_edge (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_ZCOND_A :: CCCTL_01_ZCOND_CC_TRIG_EDGE) } } # [doc = "Field `CCCTL_01_COC` reader - Capture or Compare. #br# Specifies whether the corresponding CC register is used as a capture register or a compare register (never both)."] pub type CCCTL_01_COC_R = crate :: BitReader < CCCTL_01_COC_A > ; # [doc = "Capture or Compare. #br# Specifies whether the corresponding CC register is used as a capture register or a compare register (never both).\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CCCTL_01_COC_A { # [doc = "0: COMPARE"] CCCTL_01_COC_COMPARE = 0 , # [doc = "1: CAPTURE"] CCCTL_01_COC_CAPTURE = 1 , } impl From < CCCTL_01_COC_A > for bool { # [inline (always)] fn from (variant : CCCTL_01_COC_A) -> Self { variant as u8 != 0 } } impl CCCTL_01_COC_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CCCTL_01_COC_A { match self . bits { false => CCCTL_01_COC_A :: CCCTL_01_COC_COMPARE , true => CCCTL_01_COC_A :: CCCTL_01_COC_CAPTURE , } } # [doc = "COMPARE"] # [inline (always)] pub fn is_ccctl_01_coc_compare (& self) -> bool { * self == CCCTL_01_COC_A :: CCCTL_01_COC_COMPARE } # [doc = "CAPTURE"] # [inline (always)] pub fn is_ccctl_01_coc_capture (& self) -> bool { * self == CCCTL_01_COC_A :: CCCTL_01_COC_CAPTURE } } # [doc = "Field `CCCTL_01_COC` writer - Capture or Compare. #br# Specifies whether the corresponding CC register is used as a capture register or a compare register (never both)."] pub type CCCTL_01_COC_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CCCTL_01_COC_A > ; impl < 'a , REG , const O : u8 > CCCTL_01_COC_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "COMPARE"] # [inline (always)] pub fn ccctl_01_coc_compare (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_COC_A :: CCCTL_01_COC_COMPARE) } # [doc = "CAPTURE"] # [inline (always)] pub fn ccctl_01_coc_capture (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_COC_A :: CCCTL_01_COC_CAPTURE) } } # [doc = "Field `CCCTL_01_CCUPD` reader - Capture and Compare Update Method This field controls how updates to the pipelined capture and compare register are performed (when operating in compare mode, COC=0)."] pub type CCCTL_01_CCUPD_R = crate :: FieldReader < CCCTL_01_CCUPD_A > ; # [doc = "Capture and Compare Update Method This field controls how updates to the pipelined capture and compare register are performed (when operating in compare mode, COC=0).\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CCCTL_01_CCUPD_A { # [doc = "0: IMMEDIATELY"] CCCTL_01_CCUPD_IMMEDIATELY = 0 , # [doc = "1: ZERO_EVT"] CCCTL_01_CCUPD_ZERO_EVT = 1 , # [doc = "2: COMPARE_DOWN_EVT"] CCCTL_01_CCUPD_COMPARE_DOWN_EVT = 2 , # [doc = "3: COMPARE_UP_EVT"] CCCTL_01_CCUPD_COMPARE_UP_EVT = 3 , # [doc = "4: ZERO_LOAD_EVT"] CCCTL_01_CCUPD_ZERO_LOAD_EVT = 4 , # [doc = "5: ZERO_RC_ZERO_EVT"] CCCTL_01_CCUPD_ZERO_RC_ZERO_EVT = 5 , # [doc = "6: TRIG"] CCCTL_01_CCUPD_TRIG = 6 , } impl From < CCCTL_01_CCUPD_A > for u8 { # [inline (always)] fn from (variant : CCCTL_01_CCUPD_A) -> Self { variant as _ } } impl crate :: FieldSpec for CCCTL_01_CCUPD_A { type Ux = u8 ; } impl CCCTL_01_CCUPD_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CCCTL_01_CCUPD_A > { match self . bits { 0 => Some (CCCTL_01_CCUPD_A :: CCCTL_01_CCUPD_IMMEDIATELY) , 1 => Some (CCCTL_01_CCUPD_A :: CCCTL_01_CCUPD_ZERO_EVT) , 2 => Some (CCCTL_01_CCUPD_A :: CCCTL_01_CCUPD_COMPARE_DOWN_EVT) , 3 => Some (CCCTL_01_CCUPD_A :: CCCTL_01_CCUPD_COMPARE_UP_EVT) , 4 => Some (CCCTL_01_CCUPD_A :: CCCTL_01_CCUPD_ZERO_LOAD_EVT) , 5 => Some (CCCTL_01_CCUPD_A :: CCCTL_01_CCUPD_ZERO_RC_ZERO_EVT) , 6 => Some (CCCTL_01_CCUPD_A :: CCCTL_01_CCUPD_TRIG) , _ => None , } } # [doc = "IMMEDIATELY"] # [inline (always)] pub fn is_ccctl_01_ccupd_immediately (& self) -> bool { * self == CCCTL_01_CCUPD_A :: CCCTL_01_CCUPD_IMMEDIATELY } # [doc = "ZERO_EVT"] # [inline (always)] pub fn is_ccctl_01_ccupd_zero_evt (& self) -> bool { * self == CCCTL_01_CCUPD_A :: CCCTL_01_CCUPD_ZERO_EVT } # [doc = "COMPARE_DOWN_EVT"] # [inline (always)] pub fn is_ccctl_01_ccupd_compare_down_evt (& self) -> bool { * self == CCCTL_01_CCUPD_A :: CCCTL_01_CCUPD_COMPARE_DOWN_EVT } # [doc = "COMPARE_UP_EVT"] # [inline (always)] pub fn is_ccctl_01_ccupd_compare_up_evt (& self) -> bool { * self == CCCTL_01_CCUPD_A :: CCCTL_01_CCUPD_COMPARE_UP_EVT } # [doc = "ZERO_LOAD_EVT"] # [inline (always)] pub fn is_ccctl_01_ccupd_zero_load_evt (& self) -> bool { * self == CCCTL_01_CCUPD_A :: CCCTL_01_CCUPD_ZERO_LOAD_EVT } # [doc = "ZERO_RC_ZERO_EVT"] # [inline (always)] pub fn is_ccctl_01_ccupd_zero_rc_zero_evt (& self) -> bool { * self == CCCTL_01_CCUPD_A :: CCCTL_01_CCUPD_ZERO_RC_ZERO_EVT } # [doc = "TRIG"] # [inline (always)] pub fn is_ccctl_01_ccupd_trig (& self) -> bool { * self == CCCTL_01_CCUPD_A :: CCCTL_01_CCUPD_TRIG } } # [doc = "Field `CCCTL_01_CCUPD` writer - Capture and Compare Update Method This field controls how updates to the pipelined capture and compare register are performed (when operating in compare mode, COC=0)."] pub type CCCTL_01_CCUPD_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 3 , O , CCCTL_01_CCUPD_A > ; impl < 'a , REG , const O : u8 > CCCTL_01_CCUPD_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "IMMEDIATELY"] # [inline (always)] pub fn ccctl_01_ccupd_immediately (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CCUPD_A :: CCCTL_01_CCUPD_IMMEDIATELY) } # [doc = "ZERO_EVT"] # [inline (always)] pub fn ccctl_01_ccupd_zero_evt (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CCUPD_A :: CCCTL_01_CCUPD_ZERO_EVT) } # [doc = "COMPARE_DOWN_EVT"] # [inline (always)] pub fn ccctl_01_ccupd_compare_down_evt (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CCUPD_A :: CCCTL_01_CCUPD_COMPARE_DOWN_EVT) } # [doc = "COMPARE_UP_EVT"] # [inline (always)] pub fn ccctl_01_ccupd_compare_up_evt (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CCUPD_A :: CCCTL_01_CCUPD_COMPARE_UP_EVT) } # [doc = "ZERO_LOAD_EVT"] # [inline (always)] pub fn ccctl_01_ccupd_zero_load_evt (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CCUPD_A :: CCCTL_01_CCUPD_ZERO_LOAD_EVT) } # [doc = "ZERO_RC_ZERO_EVT"] # [inline (always)] pub fn ccctl_01_ccupd_zero_rc_zero_evt (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CCUPD_A :: CCCTL_01_CCUPD_ZERO_RC_ZERO_EVT) } # [doc = "TRIG"] # [inline (always)] pub fn ccctl_01_ccupd_trig (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CCUPD_A :: CCCTL_01_CCUPD_TRIG) } } # [doc = "Field `CCCTL_01_CC2SELU` reader - Selects the source second CCU event."] pub type CCCTL_01_CC2SELU_R = crate :: FieldReader < CCCTL_01_CC2SELU_A > ; # [doc = "Selects the source second CCU event.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CCCTL_01_CC2SELU_A { # [doc = "0: SEL_CCU0"] CCCTL_01_CC2SELU_SEL_CCU0 = 0 , # [doc = "1: SEL_CCU1"] CCCTL_01_CC2SELU_SEL_CCU1 = 1 , # [doc = "2: SEL_CCU2"] CCCTL_01_CC2SELU_SEL_CCU2 = 2 , # [doc = "3: SEL_CCU3"] CCCTL_01_CC2SELU_SEL_CCU3 = 3 , # [doc = "4: SEL_CCU4"] CCCTL_01_CC2SELU_SEL_CCU4 = 4 , # [doc = "5: SEL_CCU5"] CCCTL_01_CC2SELU_SEL_CCU5 = 5 , } impl From < CCCTL_01_CC2SELU_A > for u8 { # [inline (always)] fn from (variant : CCCTL_01_CC2SELU_A) -> Self { variant as _ } } impl crate :: FieldSpec for CCCTL_01_CC2SELU_A { type Ux = u8 ; } impl CCCTL_01_CC2SELU_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CCCTL_01_CC2SELU_A > { match self . bits { 0 => Some (CCCTL_01_CC2SELU_A :: CCCTL_01_CC2SELU_SEL_CCU0) , 1 => Some (CCCTL_01_CC2SELU_A :: CCCTL_01_CC2SELU_SEL_CCU1) , 2 => Some (CCCTL_01_CC2SELU_A :: CCCTL_01_CC2SELU_SEL_CCU2) , 3 => Some (CCCTL_01_CC2SELU_A :: CCCTL_01_CC2SELU_SEL_CCU3) , 4 => Some (CCCTL_01_CC2SELU_A :: CCCTL_01_CC2SELU_SEL_CCU4) , 5 => Some (CCCTL_01_CC2SELU_A :: CCCTL_01_CC2SELU_SEL_CCU5) , _ => None , } } # [doc = "SEL_CCU0"] # [inline (always)] pub fn is_ccctl_01_cc2selu_sel_ccu0 (& self) -> bool { * self == CCCTL_01_CC2SELU_A :: CCCTL_01_CC2SELU_SEL_CCU0 } # [doc = "SEL_CCU1"] # [inline (always)] pub fn is_ccctl_01_cc2selu_sel_ccu1 (& self) -> bool { * self == CCCTL_01_CC2SELU_A :: CCCTL_01_CC2SELU_SEL_CCU1 } # [doc = "SEL_CCU2"] # [inline (always)] pub fn is_ccctl_01_cc2selu_sel_ccu2 (& self) -> bool { * self == CCCTL_01_CC2SELU_A :: CCCTL_01_CC2SELU_SEL_CCU2 } # [doc = "SEL_CCU3"] # [inline (always)] pub fn is_ccctl_01_cc2selu_sel_ccu3 (& self) -> bool { * self == CCCTL_01_CC2SELU_A :: CCCTL_01_CC2SELU_SEL_CCU3 } # [doc = "SEL_CCU4"] # [inline (always)] pub fn is_ccctl_01_cc2selu_sel_ccu4 (& self) -> bool { * self == CCCTL_01_CC2SELU_A :: CCCTL_01_CC2SELU_SEL_CCU4 } # [doc = "SEL_CCU5"] # [inline (always)] pub fn is_ccctl_01_cc2selu_sel_ccu5 (& self) -> bool { * self == CCCTL_01_CC2SELU_A :: CCCTL_01_CC2SELU_SEL_CCU5 } } # [doc = "Field `CCCTL_01_CC2SELU` writer - Selects the source second CCU event."] pub type CCCTL_01_CC2SELU_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 3 , O , CCCTL_01_CC2SELU_A > ; impl < 'a , REG , const O : u8 > CCCTL_01_CC2SELU_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "SEL_CCU0"] # [inline (always)] pub fn ccctl_01_cc2selu_sel_ccu0 (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CC2SELU_A :: CCCTL_01_CC2SELU_SEL_CCU0) } # [doc = "SEL_CCU1"] # [inline (always)] pub fn ccctl_01_cc2selu_sel_ccu1 (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CC2SELU_A :: CCCTL_01_CC2SELU_SEL_CCU1) } # [doc = "SEL_CCU2"] # [inline (always)] pub fn ccctl_01_cc2selu_sel_ccu2 (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CC2SELU_A :: CCCTL_01_CC2SELU_SEL_CCU2) } # [doc = "SEL_CCU3"] # [inline (always)] pub fn ccctl_01_cc2selu_sel_ccu3 (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CC2SELU_A :: CCCTL_01_CC2SELU_SEL_CCU3) } # [doc = "SEL_CCU4"] # [inline (always)] pub fn ccctl_01_cc2selu_sel_ccu4 (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CC2SELU_A :: CCCTL_01_CC2SELU_SEL_CCU4) } # [doc = "SEL_CCU5"] # [inline (always)] pub fn ccctl_01_cc2selu_sel_ccu5 (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CC2SELU_A :: CCCTL_01_CC2SELU_SEL_CCU5) } } # [doc = "Field `CCCTL_01_CCACTUPD` reader - CCACT shadow register Update Method This field controls how updates to the CCCACT shadow register are performed"] pub type CCCTL_01_CCACTUPD_R = crate :: FieldReader < CCCTL_01_CCACTUPD_A > ; # [doc = "CCACT shadow register Update Method This field controls how updates to the CCCACT shadow register are performed\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CCCTL_01_CCACTUPD_A { # [doc = "0: IMMEDIATELY"] CCCTL_01_CCACTUPD_IMMEDIATELY = 0 , # [doc = "1: ZERO_EVT"] CCCTL_01_CCACTUPD_ZERO_EVT = 1 , # [doc = "2: COMPARE_DOWN_EVT"] CCCTL_01_CCACTUPD_COMPARE_DOWN_EVT = 2 , # [doc = "3: COMPARE_UP_EVT"] CCCTL_01_CCACTUPD_COMPARE_UP_EVT = 3 , # [doc = "4: ZERO_LOAD_EVT"] CCCTL_01_CCACTUPD_ZERO_LOAD_EVT = 4 , # [doc = "5: ZERO_RC_ZERO_EVT"] CCCTL_01_CCACTUPD_ZERO_RC_ZERO_EVT = 5 , # [doc = "6: TRIG"] CCCTL_01_CCACTUPD_TRIG = 6 , } impl From < CCCTL_01_CCACTUPD_A > for u8 { # [inline (always)] fn from (variant : CCCTL_01_CCACTUPD_A) -> Self { variant as _ } } impl crate :: FieldSpec for CCCTL_01_CCACTUPD_A { type Ux = u8 ; } impl CCCTL_01_CCACTUPD_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CCCTL_01_CCACTUPD_A > { match self . bits { 0 => Some (CCCTL_01_CCACTUPD_A :: CCCTL_01_CCACTUPD_IMMEDIATELY) , 1 => Some (CCCTL_01_CCACTUPD_A :: CCCTL_01_CCACTUPD_ZERO_EVT) , 2 => Some (CCCTL_01_CCACTUPD_A :: CCCTL_01_CCACTUPD_COMPARE_DOWN_EVT) , 3 => Some (CCCTL_01_CCACTUPD_A :: CCCTL_01_CCACTUPD_COMPARE_UP_EVT) , 4 => Some (CCCTL_01_CCACTUPD_A :: CCCTL_01_CCACTUPD_ZERO_LOAD_EVT) , 5 => Some (CCCTL_01_CCACTUPD_A :: CCCTL_01_CCACTUPD_ZERO_RC_ZERO_EVT) , 6 => Some (CCCTL_01_CCACTUPD_A :: CCCTL_01_CCACTUPD_TRIG) , _ => None , } } # [doc = "IMMEDIATELY"] # [inline (always)] pub fn is_ccctl_01_ccactupd_immediately (& self) -> bool { * self == CCCTL_01_CCACTUPD_A :: CCCTL_01_CCACTUPD_IMMEDIATELY } # [doc = "ZERO_EVT"] # [inline (always)] pub fn is_ccctl_01_ccactupd_zero_evt (& self) -> bool { * self == CCCTL_01_CCACTUPD_A :: CCCTL_01_CCACTUPD_ZERO_EVT } # [doc = "COMPARE_DOWN_EVT"] # [inline (always)] pub fn is_ccctl_01_ccactupd_compare_down_evt (& self) -> bool { * self == CCCTL_01_CCACTUPD_A :: CCCTL_01_CCACTUPD_COMPARE_DOWN_EVT } # [doc = "COMPARE_UP_EVT"] # [inline (always)] pub fn is_ccctl_01_ccactupd_compare_up_evt (& self) -> bool { * self == CCCTL_01_CCACTUPD_A :: CCCTL_01_CCACTUPD_COMPARE_UP_EVT } # [doc = "ZERO_LOAD_EVT"] # [inline (always)] pub fn is_ccctl_01_ccactupd_zero_load_evt (& self) -> bool { * self == CCCTL_01_CCACTUPD_A :: CCCTL_01_CCACTUPD_ZERO_LOAD_EVT } # [doc = "ZERO_RC_ZERO_EVT"] # [inline (always)] pub fn is_ccctl_01_ccactupd_zero_rc_zero_evt (& self) -> bool { * self == CCCTL_01_CCACTUPD_A :: CCCTL_01_CCACTUPD_ZERO_RC_ZERO_EVT } # [doc = "TRIG"] # [inline (always)] pub fn is_ccctl_01_ccactupd_trig (& self) -> bool { * self == CCCTL_01_CCACTUPD_A :: CCCTL_01_CCACTUPD_TRIG } } # [doc = "Field `CCCTL_01_CCACTUPD` writer - CCACT shadow register Update Method This field controls how updates to the CCCACT shadow register are performed"] pub type CCCTL_01_CCACTUPD_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 3 , O , CCCTL_01_CCACTUPD_A > ; impl < 'a , REG , const O : u8 > CCCTL_01_CCACTUPD_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "IMMEDIATELY"] # [inline (always)] pub fn ccctl_01_ccactupd_immediately (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CCACTUPD_A :: CCCTL_01_CCACTUPD_IMMEDIATELY) } # [doc = "ZERO_EVT"] # [inline (always)] pub fn ccctl_01_ccactupd_zero_evt (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CCACTUPD_A :: CCCTL_01_CCACTUPD_ZERO_EVT) } # [doc = "COMPARE_DOWN_EVT"] # [inline (always)] pub fn ccctl_01_ccactupd_compare_down_evt (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CCACTUPD_A :: CCCTL_01_CCACTUPD_COMPARE_DOWN_EVT) } # [doc = "COMPARE_UP_EVT"] # [inline (always)] pub fn ccctl_01_ccactupd_compare_up_evt (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CCACTUPD_A :: CCCTL_01_CCACTUPD_COMPARE_UP_EVT) } # [doc = "ZERO_LOAD_EVT"] # [inline (always)] pub fn ccctl_01_ccactupd_zero_load_evt (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CCACTUPD_A :: CCCTL_01_CCACTUPD_ZERO_LOAD_EVT) } # [doc = "ZERO_RC_ZERO_EVT"] # [inline (always)] pub fn ccctl_01_ccactupd_zero_rc_zero_evt (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CCACTUPD_A :: CCCTL_01_CCACTUPD_ZERO_RC_ZERO_EVT) } # [doc = "TRIG"] # [inline (always)] pub fn ccctl_01_ccactupd_trig (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CCACTUPD_A :: CCCTL_01_CCACTUPD_TRIG) } } # [doc = "Field `CCCTL_01_CC2SELD` reader - Selects the source second CCD event."] pub type CCCTL_01_CC2SELD_R = crate :: FieldReader < CCCTL_01_CC2SELD_A > ; # [doc = "Selects the source second CCD event.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CCCTL_01_CC2SELD_A { # [doc = "0: SEL_CCD0"] CCCTL_01_CC2SELD_SEL_CCD0 = 0 , # [doc = "1: SEL_CCD1"] CCCTL_01_CC2SELD_SEL_CCD1 = 1 , # [doc = "2: SEL_CCD2"] CCCTL_01_CC2SELD_SEL_CCD2 = 2 , # [doc = "3: SEL_CCD3"] CCCTL_01_CC2SELD_SEL_CCD3 = 3 , # [doc = "4: SEL_CCD4"] CCCTL_01_CC2SELD_SEL_CCD4 = 4 , # [doc = "5: SEL_CCD5"] CCCTL_01_CC2SELD_SEL_CCD5 = 5 , } impl From < CCCTL_01_CC2SELD_A > for u8 { # [inline (always)] fn from (variant : CCCTL_01_CC2SELD_A) -> Self { variant as _ } } impl crate :: FieldSpec for CCCTL_01_CC2SELD_A { type Ux = u8 ; } impl CCCTL_01_CC2SELD_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CCCTL_01_CC2SELD_A > { match self . bits { 0 => Some (CCCTL_01_CC2SELD_A :: CCCTL_01_CC2SELD_SEL_CCD0) , 1 => Some (CCCTL_01_CC2SELD_A :: CCCTL_01_CC2SELD_SEL_CCD1) , 2 => Some (CCCTL_01_CC2SELD_A :: CCCTL_01_CC2SELD_SEL_CCD2) , 3 => Some (CCCTL_01_CC2SELD_A :: CCCTL_01_CC2SELD_SEL_CCD3) , 4 => Some (CCCTL_01_CC2SELD_A :: CCCTL_01_CC2SELD_SEL_CCD4) , 5 => Some (CCCTL_01_CC2SELD_A :: CCCTL_01_CC2SELD_SEL_CCD5) , _ => None , } } # [doc = "SEL_CCD0"] # [inline (always)] pub fn is_ccctl_01_cc2seld_sel_ccd0 (& self) -> bool { * self == CCCTL_01_CC2SELD_A :: CCCTL_01_CC2SELD_SEL_CCD0 } # [doc = "SEL_CCD1"] # [inline (always)] pub fn is_ccctl_01_cc2seld_sel_ccd1 (& self) -> bool { * self == CCCTL_01_CC2SELD_A :: CCCTL_01_CC2SELD_SEL_CCD1 } # [doc = "SEL_CCD2"] # [inline (always)] pub fn is_ccctl_01_cc2seld_sel_ccd2 (& self) -> bool { * self == CCCTL_01_CC2SELD_A :: CCCTL_01_CC2SELD_SEL_CCD2 } # [doc = "SEL_CCD3"] # [inline (always)] pub fn is_ccctl_01_cc2seld_sel_ccd3 (& self) -> bool { * self == CCCTL_01_CC2SELD_A :: CCCTL_01_CC2SELD_SEL_CCD3 } # [doc = "SEL_CCD4"] # [inline (always)] pub fn is_ccctl_01_cc2seld_sel_ccd4 (& self) -> bool { * self == CCCTL_01_CC2SELD_A :: CCCTL_01_CC2SELD_SEL_CCD4 } # [doc = "SEL_CCD5"] # [inline (always)] pub fn is_ccctl_01_cc2seld_sel_ccd5 (& self) -> bool { * self == CCCTL_01_CC2SELD_A :: CCCTL_01_CC2SELD_SEL_CCD5 } } # [doc = "Field `CCCTL_01_CC2SELD` writer - Selects the source second CCD event."] pub type CCCTL_01_CC2SELD_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 3 , O , CCCTL_01_CC2SELD_A > ; impl < 'a , REG , const O : u8 > CCCTL_01_CC2SELD_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "SEL_CCD0"] # [inline (always)] pub fn ccctl_01_cc2seld_sel_ccd0 (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CC2SELD_A :: CCCTL_01_CC2SELD_SEL_CCD0) } # [doc = "SEL_CCD1"] # [inline (always)] pub fn ccctl_01_cc2seld_sel_ccd1 (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CC2SELD_A :: CCCTL_01_CC2SELD_SEL_CCD1) } # [doc = "SEL_CCD2"] # [inline (always)] pub fn ccctl_01_cc2seld_sel_ccd2 (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CC2SELD_A :: CCCTL_01_CC2SELD_SEL_CCD2) } # [doc = "SEL_CCD3"] # [inline (always)] pub fn ccctl_01_cc2seld_sel_ccd3 (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CC2SELD_A :: CCCTL_01_CC2SELD_SEL_CCD3) } # [doc = "SEL_CCD4"] # [inline (always)] pub fn ccctl_01_cc2seld_sel_ccd4 (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CC2SELD_A :: CCCTL_01_CC2SELD_SEL_CCD4) } # [doc = "SEL_CCD5"] # [inline (always)] pub fn ccctl_01_cc2seld_sel_ccd5 (self) -> & 'a mut crate :: W < REG > { self . variant (CCCTL_01_CC2SELD_A :: CCCTL_01_CC2SELD_SEL_CCD5) } } impl R { # [doc = "Bits 0:2 - Capture Condition. #br# Specifies the condition that generates a capture pulse. 4h-Fh = Reserved"] # [inline (always)] pub fn ccctl_01_ccond (& self) -> CCCTL_01_CCOND_R { CCCTL_01_CCOND_R :: new ((self . bits & 7) as u8) } # [doc = "Bits 4:6 - Advance Condition. #br# Specifies the condition that generates an advance pulse. 6h-Fh = Reserved"] # [inline (always)] pub fn ccctl_01_acond (& self) -> CCCTL_01_ACOND_R { CCCTL_01_ACOND_R :: new (((self . bits >> 4) & 7) as u8) } # [doc = "Bits 8:10 - Load Condition. #br# Specifies the condition that generates a load pulse. 4h-Fh = Reserved"] # [inline (always)] pub fn ccctl_01_lcond (& self) -> CCCTL_01_LCOND_R { CCCTL_01_LCOND_R :: new (((self . bits >> 8) & 7) as u8) } # [doc = "Bits 12:14 - Zero Condition. #br# This field specifies the condition that generates a zero pulse. 4h-Fh = Reserved"] # [inline (always)] pub fn ccctl_01_zcond (& self) -> CCCTL_01_ZCOND_R { CCCTL_01_ZCOND_R :: new (((self . bits >> 12) & 7) as u8) } # [doc = "Bit 17 - Capture or Compare. #br# Specifies whether the corresponding CC register is used as a capture register or a compare register (never both)."] # [inline (always)] pub fn ccctl_01_coc (& self) -> CCCTL_01_COC_R { CCCTL_01_COC_R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bits 18:20 - Capture and Compare Update Method This field controls how updates to the pipelined capture and compare register are performed (when operating in compare mode, COC=0)."] # [inline (always)] pub fn ccctl_01_ccupd (& self) -> CCCTL_01_CCUPD_R { CCCTL_01_CCUPD_R :: new (((self . bits >> 18) & 7) as u8) } # [doc = "Bits 22:24 - Selects the source second CCU event."] # [inline (always)] pub fn ccctl_01_cc2selu (& self) -> CCCTL_01_CC2SELU_R { CCCTL_01_CC2SELU_R :: new (((self . bits >> 22) & 7) as u8) } # [doc = "Bits 26:28 - CCACT shadow register Update Method This field controls how updates to the CCCACT shadow register are performed"] # [inline (always)] pub fn ccctl_01_ccactupd (& self) -> CCCTL_01_CCACTUPD_R { CCCTL_01_CCACTUPD_R :: new (((self . bits >> 26) & 7) as u8) } # [doc = "Bits 29:31 - Selects the source second CCD event."] # [inline (always)] pub fn ccctl_01_cc2seld (& self) -> CCCTL_01_CC2SELD_R { CCCTL_01_CC2SELD_R :: new (((self . bits >> 29) & 7) as u8) } } impl W { # [doc = "Bits 0:2 - Capture Condition. #br# Specifies the condition that generates a capture pulse. 4h-Fh = Reserved"] # [inline (always)] # [must_use] pub fn ccctl_01_ccond (& mut self) -> CCCTL_01_CCOND_W < CCCTL_01_SPEC , 0 > { CCCTL_01_CCOND_W :: new (self) } # [doc = "Bits 4:6 - Advance Condition. #br# Specifies the condition that generates an advance pulse. 6h-Fh = Reserved"] # [inline (always)] # [must_use] pub fn ccctl_01_acond (& mut self) -> CCCTL_01_ACOND_W < CCCTL_01_SPEC , 4 > { CCCTL_01_ACOND_W :: new (self) } # [doc = "Bits 8:10 - Load Condition. #br# Specifies the condition that generates a load pulse. 4h-Fh = Reserved"] # [inline (always)] # [must_use] pub fn ccctl_01_lcond (& mut self) -> CCCTL_01_LCOND_W < CCCTL_01_SPEC , 8 > { CCCTL_01_LCOND_W :: new (self) } # [doc = "Bits 12:14 - Zero Condition. #br# This field specifies the condition that generates a zero pulse. 4h-Fh = Reserved"] # [inline (always)] # [must_use] pub fn ccctl_01_zcond (& mut self) -> CCCTL_01_ZCOND_W < CCCTL_01_SPEC , 12 > { CCCTL_01_ZCOND_W :: new (self) } # [doc = "Bit 17 - Capture or Compare. #br# Specifies whether the corresponding CC register is used as a capture register or a compare register (never both)."] # [inline (always)] # [must_use] pub fn ccctl_01_coc (& mut self) -> CCCTL_01_COC_W < CCCTL_01_SPEC , 17 > { CCCTL_01_COC_W :: new (self) } # [doc = "Bits 18:20 - Capture and Compare Update Method This field controls how updates to the pipelined capture and compare register are performed (when operating in compare mode, COC=0)."] # [inline (always)] # [must_use] pub fn ccctl_01_ccupd (& mut self) -> CCCTL_01_CCUPD_W < CCCTL_01_SPEC , 18 > { CCCTL_01_CCUPD_W :: new (self) } # [doc = "Bits 22:24 - Selects the source second CCU event."] # [inline (always)] # [must_use] pub fn ccctl_01_cc2selu (& mut self) -> CCCTL_01_CC2SELU_W < CCCTL_01_SPEC , 22 > { CCCTL_01_CC2SELU_W :: new (self) } # [doc = "Bits 26:28 - CCACT shadow register Update Method This field controls how updates to the CCCACT shadow register are performed"] # [inline (always)] # [must_use] pub fn ccctl_01_ccactupd (& mut self) -> CCCTL_01_CCACTUPD_W < CCCTL_01_SPEC , 26 > { CCCTL_01_CCACTUPD_W :: new (self) } # [doc = "Bits 29:31 - Selects the source second CCD event."] # [inline (always)] # [must_use] pub fn ccctl_01_cc2seld (& mut self) -> CCCTL_01_CC2SELD_W < CCCTL_01_SPEC , 29 > { CCCTL_01_CC2SELD_W :: new (self) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Capture or Compare Control Registers\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ccctl_01::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ccctl_01::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CCCTL_01_SPEC ; impl crate :: RegisterSpec for CCCTL_01_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`ccctl_01::R`](R) reader structure"] impl crate :: Readable for CCCTL_01_SPEC { } # [doc = "`write(|w| ..)` method takes [`ccctl_01::W`](W) writer structure"] impl crate :: Writable for CCCTL_01_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCCTL_01[%s]
to value 0"] impl crate :: Resettable for CCCTL_01_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }