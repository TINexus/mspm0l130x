# [doc = "Register `CTRCTL` reader"] pub type R = crate :: R < CTRCTL_SPEC > ; # [doc = "Register `CTRCTL` writer"] pub type W = crate :: W < CTRCTL_SPEC > ; # [doc = "Field `CTRCTL_EN` reader - Counter Enable. This bit allows the timer to advance This bit is automatically cleared if REPEAT=0 (do not automatically reload) and the counter value equals zero. CPU Write: A register write that sets the EN bit, the counter value is set per the CVAE value. Hardware: This bit may also be set as the result of an LCOND or ZCOND condition being met and the counter value changed to the load value or zero value, respectively."] pub type CTRCTL_EN_R = crate :: BitReader < CTRCTL_EN_A > ; # [doc = "Counter Enable. This bit allows the timer to advance This bit is automatically cleared if REPEAT=0 (do not automatically reload) and the counter value equals zero. CPU Write: A register write that sets the EN bit, the counter value is set per the CVAE value. Hardware: This bit may also be set as the result of an LCOND or ZCOND condition being met and the counter value changed to the load value or zero value, respectively.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTRCTL_EN_A { # [doc = "0: DISABLED"] CTRCTL_EN_DISABLED = 0 , # [doc = "1: ENABLED"] CTRCTL_EN_ENABLED = 1 , } impl From < CTRCTL_EN_A > for bool { # [inline (always)] fn from (variant : CTRCTL_EN_A) -> Self { variant as u8 != 0 } } impl CTRCTL_EN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTRCTL_EN_A { match self . bits { false => CTRCTL_EN_A :: CTRCTL_EN_DISABLED , true => CTRCTL_EN_A :: CTRCTL_EN_ENABLED , } } # [doc = "DISABLED"] # [inline (always)] pub fn is_ctrctl_en_disabled (& self) -> bool { * self == CTRCTL_EN_A :: CTRCTL_EN_DISABLED } # [doc = "ENABLED"] # [inline (always)] pub fn is_ctrctl_en_enabled (& self) -> bool { * self == CTRCTL_EN_A :: CTRCTL_EN_ENABLED } } # [doc = "Field `CTRCTL_EN` writer - Counter Enable. This bit allows the timer to advance This bit is automatically cleared if REPEAT=0 (do not automatically reload) and the counter value equals zero. CPU Write: A register write that sets the EN bit, the counter value is set per the CVAE value. Hardware: This bit may also be set as the result of an LCOND or ZCOND condition being met and the counter value changed to the load value or zero value, respectively."] pub type CTRCTL_EN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTRCTL_EN_A > ; impl < 'a , REG , const O : u8 > CTRCTL_EN_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLED"] # [inline (always)] pub fn ctrctl_en_disabled (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_EN_A :: CTRCTL_EN_DISABLED) } # [doc = "ENABLED"] # [inline (always)] pub fn ctrctl_en_enabled (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_EN_A :: CTRCTL_EN_ENABLED) } } # [doc = "Field `CTRCTL_REPEAT` reader - Repeat. The repeat bit controls whether the counter continues to advance following a zero event, or the exiting of a debug or fault condition. If counting down, a zero event is followed by a load at the next advance condition. If counting up-down, a zero event is followed by an advance event (+1). The intent of encoding 3 is that if the debug condition is in effect, the generation of the load pulse is deferred until the debug condition is over. This allows the counter to reach zero before counting is suspended."] pub type CTRCTL_REPEAT_R = crate :: FieldReader < CTRCTL_REPEAT_A > ; # [doc = "Repeat. The repeat bit controls whether the counter continues to advance following a zero event, or the exiting of a debug or fault condition. If counting down, a zero event is followed by a load at the next advance condition. If counting up-down, a zero event is followed by an advance event (+1). The intent of encoding 3 is that if the debug condition is in effect, the generation of the load pulse is deferred until the debug condition is over. This allows the counter to reach zero before counting is suspended.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CTRCTL_REPEAT_A { # [doc = "0: REPEAT_0"] CTRCTL_REPEAT_REPEAT_0 = 0 , # [doc = "1: REPEAT_1"] CTRCTL_REPEAT_REPEAT_1 = 1 , # [doc = "2: REPEAT_2"] CTRCTL_REPEAT_REPEAT_2 = 2 , # [doc = "3: REPEAT_3"] CTRCTL_REPEAT_REPEAT_3 = 3 , # [doc = "4: REPEAT_4"] CTRCTL_REPEAT_REPEAT_4 = 4 , } impl From < CTRCTL_REPEAT_A > for u8 { # [inline (always)] fn from (variant : CTRCTL_REPEAT_A) -> Self { variant as _ } } impl crate :: FieldSpec for CTRCTL_REPEAT_A { type Ux = u8 ; } impl CTRCTL_REPEAT_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CTRCTL_REPEAT_A > { match self . bits { 0 => Some (CTRCTL_REPEAT_A :: CTRCTL_REPEAT_REPEAT_0) , 1 => Some (CTRCTL_REPEAT_A :: CTRCTL_REPEAT_REPEAT_1) , 2 => Some (CTRCTL_REPEAT_A :: CTRCTL_REPEAT_REPEAT_2) , 3 => Some (CTRCTL_REPEAT_A :: CTRCTL_REPEAT_REPEAT_3) , 4 => Some (CTRCTL_REPEAT_A :: CTRCTL_REPEAT_REPEAT_4) , _ => None , } } # [doc = "REPEAT_0"] # [inline (always)] pub fn is_ctrctl_repeat_repeat_0 (& self) -> bool { * self == CTRCTL_REPEAT_A :: CTRCTL_REPEAT_REPEAT_0 } # [doc = "REPEAT_1"] # [inline (always)] pub fn is_ctrctl_repeat_repeat_1 (& self) -> bool { * self == CTRCTL_REPEAT_A :: CTRCTL_REPEAT_REPEAT_1 } # [doc = "REPEAT_2"] # [inline (always)] pub fn is_ctrctl_repeat_repeat_2 (& self) -> bool { * self == CTRCTL_REPEAT_A :: CTRCTL_REPEAT_REPEAT_2 } # [doc = "REPEAT_3"] # [inline (always)] pub fn is_ctrctl_repeat_repeat_3 (& self) -> bool { * self == CTRCTL_REPEAT_A :: CTRCTL_REPEAT_REPEAT_3 } # [doc = "REPEAT_4"] # [inline (always)] pub fn is_ctrctl_repeat_repeat_4 (& self) -> bool { * self == CTRCTL_REPEAT_A :: CTRCTL_REPEAT_REPEAT_4 } } # [doc = "Field `CTRCTL_REPEAT` writer - Repeat. The repeat bit controls whether the counter continues to advance following a zero event, or the exiting of a debug or fault condition. If counting down, a zero event is followed by a load at the next advance condition. If counting up-down, a zero event is followed by an advance event (+1). The intent of encoding 3 is that if the debug condition is in effect, the generation of the load pulse is deferred until the debug condition is over. This allows the counter to reach zero before counting is suspended."] pub type CTRCTL_REPEAT_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 3 , O , CTRCTL_REPEAT_A > ; impl < 'a , REG , const O : u8 > CTRCTL_REPEAT_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "REPEAT_0"] # [inline (always)] pub fn ctrctl_repeat_repeat_0 (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_REPEAT_A :: CTRCTL_REPEAT_REPEAT_0) } # [doc = "REPEAT_1"] # [inline (always)] pub fn ctrctl_repeat_repeat_1 (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_REPEAT_A :: CTRCTL_REPEAT_REPEAT_1) } # [doc = "REPEAT_2"] # [inline (always)] pub fn ctrctl_repeat_repeat_2 (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_REPEAT_A :: CTRCTL_REPEAT_REPEAT_2) } # [doc = "REPEAT_3"] # [inline (always)] pub fn ctrctl_repeat_repeat_3 (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_REPEAT_A :: CTRCTL_REPEAT_REPEAT_3) } # [doc = "REPEAT_4"] # [inline (always)] pub fn ctrctl_repeat_repeat_4 (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_REPEAT_A :: CTRCTL_REPEAT_REPEAT_4) } } # [doc = "Field `CTRCTL_CM` reader - Count Mode"] pub type CTRCTL_CM_R = crate :: FieldReader < CTRCTL_CM_A > ; # [doc = "Count Mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CTRCTL_CM_A { # [doc = "0: DOWN"] CTRCTL_CM_DOWN = 0 , # [doc = "1: UP_DOWN"] CTRCTL_CM_UP_DOWN = 1 , # [doc = "2: UP"] CTRCTL_CM_UP = 2 , } impl From < CTRCTL_CM_A > for u8 { # [inline (always)] fn from (variant : CTRCTL_CM_A) -> Self { variant as _ } } impl crate :: FieldSpec for CTRCTL_CM_A { type Ux = u8 ; } impl CTRCTL_CM_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CTRCTL_CM_A > { match self . bits { 0 => Some (CTRCTL_CM_A :: CTRCTL_CM_DOWN) , 1 => Some (CTRCTL_CM_A :: CTRCTL_CM_UP_DOWN) , 2 => Some (CTRCTL_CM_A :: CTRCTL_CM_UP) , _ => None , } } # [doc = "DOWN"] # [inline (always)] pub fn is_ctrctl_cm_down (& self) -> bool { * self == CTRCTL_CM_A :: CTRCTL_CM_DOWN } # [doc = "UP_DOWN"] # [inline (always)] pub fn is_ctrctl_cm_up_down (& self) -> bool { * self == CTRCTL_CM_A :: CTRCTL_CM_UP_DOWN } # [doc = "UP"] # [inline (always)] pub fn is_ctrctl_cm_up (& self) -> bool { * self == CTRCTL_CM_A :: CTRCTL_CM_UP } } # [doc = "Field `CTRCTL_CM` writer - Count Mode"] pub type CTRCTL_CM_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 2 , O , CTRCTL_CM_A > ; impl < 'a , REG , const O : u8 > CTRCTL_CM_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "DOWN"] # [inline (always)] pub fn ctrctl_cm_down (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_CM_A :: CTRCTL_CM_DOWN) } # [doc = "UP_DOWN"] # [inline (always)] pub fn ctrctl_cm_up_down (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_CM_A :: CTRCTL_CM_UP_DOWN) } # [doc = "UP"] # [inline (always)] pub fn ctrctl_cm_up (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_CM_A :: CTRCTL_CM_UP) } } # [doc = "Field `CTRCTL_CLC` reader - Counter Load Control. This field specifies what controls the counter operation with respect to setting the counter to the LD register value. Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved."] pub type CTRCTL_CLC_R = crate :: FieldReader < CTRCTL_CLC_A > ; # [doc = "Counter Load Control. This field specifies what controls the counter operation with respect to setting the counter to the LD register value. Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved.\n\nValue on reset: 7"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CTRCTL_CLC_A { # [doc = "0: CCCTL0_LCOND"] CTRCTL_CLC_CCCTL0_LCOND = 0 , # [doc = "1: CCCTL1_LCOND"] CTRCTL_CLC_CCCTL1_LCOND = 1 , # [doc = "2: CCCTL2_LCOND"] CTRCTL_CLC_CCCTL2_LCOND = 2 , # [doc = "3: CCCTL3_LCOND"] CTRCTL_CLC_CCCTL3_LCOND = 3 , # [doc = "4: QEI_2INP"] CTRCTL_CLC_QEI_2INP = 4 , # [doc = "5: QEI_3INP"] CTRCTL_CLC_QEI_3INP = 5 , } impl From < CTRCTL_CLC_A > for u8 { # [inline (always)] fn from (variant : CTRCTL_CLC_A) -> Self { variant as _ } } impl crate :: FieldSpec for CTRCTL_CLC_A { type Ux = u8 ; } impl CTRCTL_CLC_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CTRCTL_CLC_A > { match self . bits { 0 => Some (CTRCTL_CLC_A :: CTRCTL_CLC_CCCTL0_LCOND) , 1 => Some (CTRCTL_CLC_A :: CTRCTL_CLC_CCCTL1_LCOND) , 2 => Some (CTRCTL_CLC_A :: CTRCTL_CLC_CCCTL2_LCOND) , 3 => Some (CTRCTL_CLC_A :: CTRCTL_CLC_CCCTL3_LCOND) , 4 => Some (CTRCTL_CLC_A :: CTRCTL_CLC_QEI_2INP) , 5 => Some (CTRCTL_CLC_A :: CTRCTL_CLC_QEI_3INP) , _ => None , } } # [doc = "CCCTL0_LCOND"] # [inline (always)] pub fn is_ctrctl_clc_ccctl0_lcond (& self) -> bool { * self == CTRCTL_CLC_A :: CTRCTL_CLC_CCCTL0_LCOND } # [doc = "CCCTL1_LCOND"] # [inline (always)] pub fn is_ctrctl_clc_ccctl1_lcond (& self) -> bool { * self == CTRCTL_CLC_A :: CTRCTL_CLC_CCCTL1_LCOND } # [doc = "CCCTL2_LCOND"] # [inline (always)] pub fn is_ctrctl_clc_ccctl2_lcond (& self) -> bool { * self == CTRCTL_CLC_A :: CTRCTL_CLC_CCCTL2_LCOND } # [doc = "CCCTL3_LCOND"] # [inline (always)] pub fn is_ctrctl_clc_ccctl3_lcond (& self) -> bool { * self == CTRCTL_CLC_A :: CTRCTL_CLC_CCCTL3_LCOND } # [doc = "QEI_2INP"] # [inline (always)] pub fn is_ctrctl_clc_qei_2inp (& self) -> bool { * self == CTRCTL_CLC_A :: CTRCTL_CLC_QEI_2INP } # [doc = "QEI_3INP"] # [inline (always)] pub fn is_ctrctl_clc_qei_3inp (& self) -> bool { * self == CTRCTL_CLC_A :: CTRCTL_CLC_QEI_3INP } } # [doc = "Field `CTRCTL_CLC` writer - Counter Load Control. This field specifies what controls the counter operation with respect to setting the counter to the LD register value. Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved."] pub type CTRCTL_CLC_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 3 , O , CTRCTL_CLC_A > ; impl < 'a , REG , const O : u8 > CTRCTL_CLC_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "CCCTL0_LCOND"] # [inline (always)] pub fn ctrctl_clc_ccctl0_lcond (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_CLC_A :: CTRCTL_CLC_CCCTL0_LCOND) } # [doc = "CCCTL1_LCOND"] # [inline (always)] pub fn ctrctl_clc_ccctl1_lcond (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_CLC_A :: CTRCTL_CLC_CCCTL1_LCOND) } # [doc = "CCCTL2_LCOND"] # [inline (always)] pub fn ctrctl_clc_ccctl2_lcond (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_CLC_A :: CTRCTL_CLC_CCCTL2_LCOND) } # [doc = "CCCTL3_LCOND"] # [inline (always)] pub fn ctrctl_clc_ccctl3_lcond (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_CLC_A :: CTRCTL_CLC_CCCTL3_LCOND) } # [doc = "QEI_2INP"] # [inline (always)] pub fn ctrctl_clc_qei_2inp (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_CLC_A :: CTRCTL_CLC_QEI_2INP) } # [doc = "QEI_3INP"] # [inline (always)] pub fn ctrctl_clc_qei_3inp (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_CLC_A :: CTRCTL_CLC_QEI_3INP) } } # [doc = "Field `CTRCTL_CAC` reader - Counter Advance Control. This field specifies what controls the counter operation with respect to advancing (incrementing or decrementing) the counter value. Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved."] pub type CTRCTL_CAC_R = crate :: FieldReader < CTRCTL_CAC_A > ; # [doc = "Counter Advance Control. This field specifies what controls the counter operation with respect to advancing (incrementing or decrementing) the counter value. Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved.\n\nValue on reset: 7"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CTRCTL_CAC_A { # [doc = "0: CCCTL0_ACOND"] CTRCTL_CAC_CCCTL0_ACOND = 0 , # [doc = "1: CCCTL1_ACOND"] CTRCTL_CAC_CCCTL1_ACOND = 1 , # [doc = "2: CCCTL2_ACOND"] CTRCTL_CAC_CCCTL2_ACOND = 2 , # [doc = "3: CCCTL3_ACOND"] CTRCTL_CAC_CCCTL3_ACOND = 3 , # [doc = "4: QEI_2INP"] CTRCTL_CAC_QEI_2INP = 4 , # [doc = "5: QEI_3INP"] CTRCTL_CAC_QEI_3INP = 5 , } impl From < CTRCTL_CAC_A > for u8 { # [inline (always)] fn from (variant : CTRCTL_CAC_A) -> Self { variant as _ } } impl crate :: FieldSpec for CTRCTL_CAC_A { type Ux = u8 ; } impl CTRCTL_CAC_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CTRCTL_CAC_A > { match self . bits { 0 => Some (CTRCTL_CAC_A :: CTRCTL_CAC_CCCTL0_ACOND) , 1 => Some (CTRCTL_CAC_A :: CTRCTL_CAC_CCCTL1_ACOND) , 2 => Some (CTRCTL_CAC_A :: CTRCTL_CAC_CCCTL2_ACOND) , 3 => Some (CTRCTL_CAC_A :: CTRCTL_CAC_CCCTL3_ACOND) , 4 => Some (CTRCTL_CAC_A :: CTRCTL_CAC_QEI_2INP) , 5 => Some (CTRCTL_CAC_A :: CTRCTL_CAC_QEI_3INP) , _ => None , } } # [doc = "CCCTL0_ACOND"] # [inline (always)] pub fn is_ctrctl_cac_ccctl0_acond (& self) -> bool { * self == CTRCTL_CAC_A :: CTRCTL_CAC_CCCTL0_ACOND } # [doc = "CCCTL1_ACOND"] # [inline (always)] pub fn is_ctrctl_cac_ccctl1_acond (& self) -> bool { * self == CTRCTL_CAC_A :: CTRCTL_CAC_CCCTL1_ACOND } # [doc = "CCCTL2_ACOND"] # [inline (always)] pub fn is_ctrctl_cac_ccctl2_acond (& self) -> bool { * self == CTRCTL_CAC_A :: CTRCTL_CAC_CCCTL2_ACOND } # [doc = "CCCTL3_ACOND"] # [inline (always)] pub fn is_ctrctl_cac_ccctl3_acond (& self) -> bool { * self == CTRCTL_CAC_A :: CTRCTL_CAC_CCCTL3_ACOND } # [doc = "QEI_2INP"] # [inline (always)] pub fn is_ctrctl_cac_qei_2inp (& self) -> bool { * self == CTRCTL_CAC_A :: CTRCTL_CAC_QEI_2INP } # [doc = "QEI_3INP"] # [inline (always)] pub fn is_ctrctl_cac_qei_3inp (& self) -> bool { * self == CTRCTL_CAC_A :: CTRCTL_CAC_QEI_3INP } } # [doc = "Field `CTRCTL_CAC` writer - Counter Advance Control. This field specifies what controls the counter operation with respect to advancing (incrementing or decrementing) the counter value. Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved."] pub type CTRCTL_CAC_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 3 , O , CTRCTL_CAC_A > ; impl < 'a , REG , const O : u8 > CTRCTL_CAC_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "CCCTL0_ACOND"] # [inline (always)] pub fn ctrctl_cac_ccctl0_acond (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_CAC_A :: CTRCTL_CAC_CCCTL0_ACOND) } # [doc = "CCCTL1_ACOND"] # [inline (always)] pub fn ctrctl_cac_ccctl1_acond (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_CAC_A :: CTRCTL_CAC_CCCTL1_ACOND) } # [doc = "CCCTL2_ACOND"] # [inline (always)] pub fn ctrctl_cac_ccctl2_acond (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_CAC_A :: CTRCTL_CAC_CCCTL2_ACOND) } # [doc = "CCCTL3_ACOND"] # [inline (always)] pub fn ctrctl_cac_ccctl3_acond (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_CAC_A :: CTRCTL_CAC_CCCTL3_ACOND) } # [doc = "QEI_2INP"] # [inline (always)] pub fn ctrctl_cac_qei_2inp (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_CAC_A :: CTRCTL_CAC_QEI_2INP) } # [doc = "QEI_3INP"] # [inline (always)] pub fn ctrctl_cac_qei_3inp (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_CAC_A :: CTRCTL_CAC_QEI_3INP) } } # [doc = "Field `CTRCTL_CZC` reader - Counter Zero Control This field specifies what controls the counter operation with respect to zeroing the counter value. Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved."] pub type CTRCTL_CZC_R = crate :: FieldReader < CTRCTL_CZC_A > ; # [doc = "Counter Zero Control This field specifies what controls the counter operation with respect to zeroing the counter value. Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved.\n\nValue on reset: 7"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CTRCTL_CZC_A { # [doc = "0: CCCTL0_ZCOND"] CTRCTL_CZC_CCCTL0_ZCOND = 0 , # [doc = "1: CCCTL1_ZCOND"] CTRCTL_CZC_CCCTL1_ZCOND = 1 , # [doc = "2: CCCTL2_ZCOND"] CTRCTL_CZC_CCCTL2_ZCOND = 2 , # [doc = "3: CCCTL3_ZCOND"] CTRCTL_CZC_CCCTL3_ZCOND = 3 , # [doc = "4: QEI_2INP"] CTRCTL_CZC_QEI_2INP = 4 , # [doc = "5: QEI_3INP"] CTRCTL_CZC_QEI_3INP = 5 , } impl From < CTRCTL_CZC_A > for u8 { # [inline (always)] fn from (variant : CTRCTL_CZC_A) -> Self { variant as _ } } impl crate :: FieldSpec for CTRCTL_CZC_A { type Ux = u8 ; } impl CTRCTL_CZC_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CTRCTL_CZC_A > { match self . bits { 0 => Some (CTRCTL_CZC_A :: CTRCTL_CZC_CCCTL0_ZCOND) , 1 => Some (CTRCTL_CZC_A :: CTRCTL_CZC_CCCTL1_ZCOND) , 2 => Some (CTRCTL_CZC_A :: CTRCTL_CZC_CCCTL2_ZCOND) , 3 => Some (CTRCTL_CZC_A :: CTRCTL_CZC_CCCTL3_ZCOND) , 4 => Some (CTRCTL_CZC_A :: CTRCTL_CZC_QEI_2INP) , 5 => Some (CTRCTL_CZC_A :: CTRCTL_CZC_QEI_3INP) , _ => None , } } # [doc = "CCCTL0_ZCOND"] # [inline (always)] pub fn is_ctrctl_czc_ccctl0_zcond (& self) -> bool { * self == CTRCTL_CZC_A :: CTRCTL_CZC_CCCTL0_ZCOND } # [doc = "CCCTL1_ZCOND"] # [inline (always)] pub fn is_ctrctl_czc_ccctl1_zcond (& self) -> bool { * self == CTRCTL_CZC_A :: CTRCTL_CZC_CCCTL1_ZCOND } # [doc = "CCCTL2_ZCOND"] # [inline (always)] pub fn is_ctrctl_czc_ccctl2_zcond (& self) -> bool { * self == CTRCTL_CZC_A :: CTRCTL_CZC_CCCTL2_ZCOND } # [doc = "CCCTL3_ZCOND"] # [inline (always)] pub fn is_ctrctl_czc_ccctl3_zcond (& self) -> bool { * self == CTRCTL_CZC_A :: CTRCTL_CZC_CCCTL3_ZCOND } # [doc = "QEI_2INP"] # [inline (always)] pub fn is_ctrctl_czc_qei_2inp (& self) -> bool { * self == CTRCTL_CZC_A :: CTRCTL_CZC_QEI_2INP } # [doc = "QEI_3INP"] # [inline (always)] pub fn is_ctrctl_czc_qei_3inp (& self) -> bool { * self == CTRCTL_CZC_A :: CTRCTL_CZC_QEI_3INP } } # [doc = "Field `CTRCTL_CZC` writer - Counter Zero Control This field specifies what controls the counter operation with respect to zeroing the counter value. Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved."] pub type CTRCTL_CZC_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 3 , O , CTRCTL_CZC_A > ; impl < 'a , REG , const O : u8 > CTRCTL_CZC_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "CCCTL0_ZCOND"] # [inline (always)] pub fn ctrctl_czc_ccctl0_zcond (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_CZC_A :: CTRCTL_CZC_CCCTL0_ZCOND) } # [doc = "CCCTL1_ZCOND"] # [inline (always)] pub fn ctrctl_czc_ccctl1_zcond (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_CZC_A :: CTRCTL_CZC_CCCTL1_ZCOND) } # [doc = "CCCTL2_ZCOND"] # [inline (always)] pub fn ctrctl_czc_ccctl2_zcond (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_CZC_A :: CTRCTL_CZC_CCCTL2_ZCOND) } # [doc = "CCCTL3_ZCOND"] # [inline (always)] pub fn ctrctl_czc_ccctl3_zcond (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_CZC_A :: CTRCTL_CZC_CCCTL3_ZCOND) } # [doc = "QEI_2INP"] # [inline (always)] pub fn ctrctl_czc_qei_2inp (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_CZC_A :: CTRCTL_CZC_QEI_2INP) } # [doc = "QEI_3INP"] # [inline (always)] pub fn ctrctl_czc_qei_3inp (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_CZC_A :: CTRCTL_CZC_QEI_3INP) } } # [doc = "Field `CTRCTL_DRB` reader - Debug Resume Behavior This bit specifies what the device does following the release/exit of debug mode."] pub type CTRCTL_DRB_R = crate :: BitReader < CTRCTL_DRB_A > ; # [doc = "Debug Resume Behavior This bit specifies what the device does following the release/exit of debug mode.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTRCTL_DRB_A { # [doc = "0: RESUME"] CTRCTL_DRB_RESUME = 0 , # [doc = "1: CVAE_ACTION"] CTRCTL_DRB_CVAE_ACTION = 1 , } impl From < CTRCTL_DRB_A > for bool { # [inline (always)] fn from (variant : CTRCTL_DRB_A) -> Self { variant as u8 != 0 } } impl CTRCTL_DRB_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTRCTL_DRB_A { match self . bits { false => CTRCTL_DRB_A :: CTRCTL_DRB_RESUME , true => CTRCTL_DRB_A :: CTRCTL_DRB_CVAE_ACTION , } } # [doc = "RESUME"] # [inline (always)] pub fn is_ctrctl_drb_resume (& self) -> bool { * self == CTRCTL_DRB_A :: CTRCTL_DRB_RESUME } # [doc = "CVAE_ACTION"] # [inline (always)] pub fn is_ctrctl_drb_cvae_action (& self) -> bool { * self == CTRCTL_DRB_A :: CTRCTL_DRB_CVAE_ACTION } } # [doc = "Field `CTRCTL_DRB` writer - Debug Resume Behavior This bit specifies what the device does following the release/exit of debug mode."] pub type CTRCTL_DRB_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTRCTL_DRB_A > ; impl < 'a , REG , const O : u8 > CTRCTL_DRB_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "RESUME"] # [inline (always)] pub fn ctrctl_drb_resume (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_DRB_A :: CTRCTL_DRB_RESUME) } # [doc = "CVAE_ACTION"] # [inline (always)] pub fn ctrctl_drb_cvae_action (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_DRB_A :: CTRCTL_DRB_CVAE_ACTION) } } # [doc = "Field `CTRCTL_CVAE` reader - Counter Value After Enable. This field specifies the initialization condition of the counter when the EN bit is changed from 0 to 1 by a write to the CTRCTL register. Note that an external event can also cause the EN bit to go active."] pub type CTRCTL_CVAE_R = crate :: FieldReader < CTRCTL_CVAE_A > ; # [doc = "Counter Value After Enable. This field specifies the initialization condition of the counter when the EN bit is changed from 0 to 1 by a write to the CTRCTL register. Note that an external event can also cause the EN bit to go active.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CTRCTL_CVAE_A { # [doc = "0: LDVAL"] CTRCTL_CVAE_LDVAL = 0 , # [doc = "1: NOCHANGE"] CTRCTL_CVAE_NOCHANGE = 1 , # [doc = "2: ZEROVAL"] CTRCTL_CVAE_ZEROVAL = 2 , } impl From < CTRCTL_CVAE_A > for u8 { # [inline (always)] fn from (variant : CTRCTL_CVAE_A) -> Self { variant as _ } } impl crate :: FieldSpec for CTRCTL_CVAE_A { type Ux = u8 ; } impl CTRCTL_CVAE_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CTRCTL_CVAE_A > { match self . bits { 0 => Some (CTRCTL_CVAE_A :: CTRCTL_CVAE_LDVAL) , 1 => Some (CTRCTL_CVAE_A :: CTRCTL_CVAE_NOCHANGE) , 2 => Some (CTRCTL_CVAE_A :: CTRCTL_CVAE_ZEROVAL) , _ => None , } } # [doc = "LDVAL"] # [inline (always)] pub fn is_ctrctl_cvae_ldval (& self) -> bool { * self == CTRCTL_CVAE_A :: CTRCTL_CVAE_LDVAL } # [doc = "NOCHANGE"] # [inline (always)] pub fn is_ctrctl_cvae_nochange (& self) -> bool { * self == CTRCTL_CVAE_A :: CTRCTL_CVAE_NOCHANGE } # [doc = "ZEROVAL"] # [inline (always)] pub fn is_ctrctl_cvae_zeroval (& self) -> bool { * self == CTRCTL_CVAE_A :: CTRCTL_CVAE_ZEROVAL } } # [doc = "Field `CTRCTL_CVAE` writer - Counter Value After Enable. This field specifies the initialization condition of the counter when the EN bit is changed from 0 to 1 by a write to the CTRCTL register. Note that an external event can also cause the EN bit to go active."] pub type CTRCTL_CVAE_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 2 , O , CTRCTL_CVAE_A > ; impl < 'a , REG , const O : u8 > CTRCTL_CVAE_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "LDVAL"] # [inline (always)] pub fn ctrctl_cvae_ldval (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_CVAE_A :: CTRCTL_CVAE_LDVAL) } # [doc = "NOCHANGE"] # [inline (always)] pub fn ctrctl_cvae_nochange (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_CVAE_A :: CTRCTL_CVAE_NOCHANGE) } # [doc = "ZEROVAL"] # [inline (always)] pub fn ctrctl_cvae_zeroval (self) -> & 'a mut crate :: W < REG > { self . variant (CTRCTL_CVAE_A :: CTRCTL_CVAE_ZEROVAL) } } impl R { # [doc = "Bit 0 - Counter Enable. This bit allows the timer to advance This bit is automatically cleared if REPEAT=0 (do not automatically reload) and the counter value equals zero. CPU Write: A register write that sets the EN bit, the counter value is set per the CVAE value. Hardware: This bit may also be set as the result of an LCOND or ZCOND condition being met and the counter value changed to the load value or zero value, respectively."] # [inline (always)] pub fn ctrctl_en (& self) -> CTRCTL_EN_R { CTRCTL_EN_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:3 - Repeat. The repeat bit controls whether the counter continues to advance following a zero event, or the exiting of a debug or fault condition. If counting down, a zero event is followed by a load at the next advance condition. If counting up-down, a zero event is followed by an advance event (+1). The intent of encoding 3 is that if the debug condition is in effect, the generation of the load pulse is deferred until the debug condition is over. This allows the counter to reach zero before counting is suspended."] # [inline (always)] pub fn ctrctl_repeat (& self) -> CTRCTL_REPEAT_R { CTRCTL_REPEAT_R :: new (((self . bits >> 1) & 7) as u8) } # [doc = "Bits 4:5 - Count Mode"] # [inline (always)] pub fn ctrctl_cm (& self) -> CTRCTL_CM_R { CTRCTL_CM_R :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bits 7:9 - Counter Load Control. This field specifies what controls the counter operation with respect to setting the counter to the LD register value. Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved."] # [inline (always)] pub fn ctrctl_clc (& self) -> CTRCTL_CLC_R { CTRCTL_CLC_R :: new (((self . bits >> 7) & 7) as u8) } # [doc = "Bits 10:12 - Counter Advance Control. This field specifies what controls the counter operation with respect to advancing (incrementing or decrementing) the counter value. Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved."] # [inline (always)] pub fn ctrctl_cac (& self) -> CTRCTL_CAC_R { CTRCTL_CAC_R :: new (((self . bits >> 10) & 7) as u8) } # [doc = "Bits 13:15 - Counter Zero Control This field specifies what controls the counter operation with respect to zeroing the counter value. Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved."] # [inline (always)] pub fn ctrctl_czc (& self) -> CTRCTL_CZC_R { CTRCTL_CZC_R :: new (((self . bits >> 13) & 7) as u8) } # [doc = "Bit 17 - Debug Resume Behavior This bit specifies what the device does following the release/exit of debug mode."] # [inline (always)] pub fn ctrctl_drb (& self) -> CTRCTL_DRB_R { CTRCTL_DRB_R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bits 28:29 - Counter Value After Enable. This field specifies the initialization condition of the counter when the EN bit is changed from 0 to 1 by a write to the CTRCTL register. Note that an external event can also cause the EN bit to go active."] # [inline (always)] pub fn ctrctl_cvae (& self) -> CTRCTL_CVAE_R { CTRCTL_CVAE_R :: new (((self . bits >> 28) & 3) as u8) } } impl W { # [doc = "Bit 0 - Counter Enable. This bit allows the timer to advance This bit is automatically cleared if REPEAT=0 (do not automatically reload) and the counter value equals zero. CPU Write: A register write that sets the EN bit, the counter value is set per the CVAE value. Hardware: This bit may also be set as the result of an LCOND or ZCOND condition being met and the counter value changed to the load value or zero value, respectively."] # [inline (always)] # [must_use] pub fn ctrctl_en (& mut self) -> CTRCTL_EN_W < CTRCTL_SPEC , 0 > { CTRCTL_EN_W :: new (self) } # [doc = "Bits 1:3 - Repeat. The repeat bit controls whether the counter continues to advance following a zero event, or the exiting of a debug or fault condition. If counting down, a zero event is followed by a load at the next advance condition. If counting up-down, a zero event is followed by an advance event (+1). The intent of encoding 3 is that if the debug condition is in effect, the generation of the load pulse is deferred until the debug condition is over. This allows the counter to reach zero before counting is suspended."] # [inline (always)] # [must_use] pub fn ctrctl_repeat (& mut self) -> CTRCTL_REPEAT_W < CTRCTL_SPEC , 1 > { CTRCTL_REPEAT_W :: new (self) } # [doc = "Bits 4:5 - Count Mode"] # [inline (always)] # [must_use] pub fn ctrctl_cm (& mut self) -> CTRCTL_CM_W < CTRCTL_SPEC , 4 > { CTRCTL_CM_W :: new (self) } # [doc = "Bits 7:9 - Counter Load Control. This field specifies what controls the counter operation with respect to setting the counter to the LD register value. Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved."] # [inline (always)] # [must_use] pub fn ctrctl_clc (& mut self) -> CTRCTL_CLC_W < CTRCTL_SPEC , 7 > { CTRCTL_CLC_W :: new (self) } # [doc = "Bits 10:12 - Counter Advance Control. This field specifies what controls the counter operation with respect to advancing (incrementing or decrementing) the counter value. Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved."] # [inline (always)] # [must_use] pub fn ctrctl_cac (& mut self) -> CTRCTL_CAC_W < CTRCTL_SPEC , 10 > { CTRCTL_CAC_W :: new (self) } # [doc = "Bits 13:15 - Counter Zero Control This field specifies what controls the counter operation with respect to zeroing the counter value. Encodings 1-3 are present based on the CCPC parameter value. Bits 4-5 are present based on the HQEI parameter value. Any encodings not provided are documented as reserved."] # [inline (always)] # [must_use] pub fn ctrctl_czc (& mut self) -> CTRCTL_CZC_W < CTRCTL_SPEC , 13 > { CTRCTL_CZC_W :: new (self) } # [doc = "Bit 17 - Debug Resume Behavior This bit specifies what the device does following the release/exit of debug mode."] # [inline (always)] # [must_use] pub fn ctrctl_drb (& mut self) -> CTRCTL_DRB_W < CTRCTL_SPEC , 17 > { CTRCTL_DRB_W :: new (self) } # [doc = "Bits 28:29 - Counter Value After Enable. This field specifies the initialization condition of the counter when the EN bit is changed from 0 to 1 by a write to the CTRCTL register. Note that an external event can also cause the EN bit to go active."] # [inline (always)] # [must_use] pub fn ctrctl_cvae (& mut self) -> CTRCTL_CVAE_W < CTRCTL_SPEC , 28 > { CTRCTL_CVAE_W :: new (self) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Counter Control Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ctrctl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrctl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CTRCTL_SPEC ; impl crate :: RegisterSpec for CTRCTL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`ctrctl::R`](R) reader structure"] impl crate :: Readable for CTRCTL_SPEC { } # [doc = "`write(|w| ..)` method takes [`ctrctl::W`](W) writer structure"] impl crate :: Writable for CTRCTL_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRCTL to value 0xff80"] impl crate :: Resettable for CTRCTL_SPEC { const RESET_VALUE : Self :: Ux = 0xff80 ; }