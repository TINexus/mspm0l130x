# [doc = "Register `CTTRIGCTL` reader"] pub type R = crate :: R < CTTRIGCTL_SPEC > ; # [doc = "Register `CTTRIGCTL` writer"] pub type W = crate :: W < CTTRIGCTL_SPEC > ; # [doc = "Field `CTTRIGCTL_CTEN` reader - Timer Cross trigger enable. This field is used to enable whether the SW or HW logic can generate a timer cross trigger event in the system. These cross triggers are connected to the respective timer trigger in of the other timer IPs in the SOC power domain. The timer cross trigger is essentially the combined logic of the HW and SW conditions controlling EN bit in the CTRCTL register."] pub type CTTRIGCTL_CTEN_R = crate :: BitReader < CTTRIGCTL_CTEN_A > ; # [doc = "Timer Cross trigger enable. This field is used to enable whether the SW or HW logic can generate a timer cross trigger event in the system. These cross triggers are connected to the respective timer trigger in of the other timer IPs in the SOC power domain. The timer cross trigger is essentially the combined logic of the HW and SW conditions controlling EN bit in the CTRCTL register.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTTRIGCTL_CTEN_A { # [doc = "0: DISABLED"] CTTRIGCTL_CTEN_DISABLED = 0 , # [doc = "1: ENABLE"] CTTRIGCTL_CTEN_ENABLE = 1 , } impl From < CTTRIGCTL_CTEN_A > for bool { # [inline (always)] fn from (variant : CTTRIGCTL_CTEN_A) -> Self { variant as u8 != 0 } } impl CTTRIGCTL_CTEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTTRIGCTL_CTEN_A { match self . bits { false => CTTRIGCTL_CTEN_A :: CTTRIGCTL_CTEN_DISABLED , true => CTTRIGCTL_CTEN_A :: CTTRIGCTL_CTEN_ENABLE , } } # [doc = "DISABLED"] # [inline (always)] pub fn is_cttrigctl_cten_disabled (& self) -> bool { * self == CTTRIGCTL_CTEN_A :: CTTRIGCTL_CTEN_DISABLED } # [doc = "ENABLE"] # [inline (always)] pub fn is_cttrigctl_cten_enable (& self) -> bool { * self == CTTRIGCTL_CTEN_A :: CTTRIGCTL_CTEN_ENABLE } } # [doc = "Field `CTTRIGCTL_CTEN` writer - Timer Cross trigger enable. This field is used to enable whether the SW or HW logic can generate a timer cross trigger event in the system. These cross triggers are connected to the respective timer trigger in of the other timer IPs in the SOC power domain. The timer cross trigger is essentially the combined logic of the HW and SW conditions controlling EN bit in the CTRCTL register."] pub type CTTRIGCTL_CTEN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTTRIGCTL_CTEN_A > ; impl < 'a , REG , const O : u8 > CTTRIGCTL_CTEN_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLED"] # [inline (always)] pub fn cttrigctl_cten_disabled (self) -> & 'a mut crate :: W < REG > { self . variant (CTTRIGCTL_CTEN_A :: CTTRIGCTL_CTEN_DISABLED) } # [doc = "ENABLE"] # [inline (always)] pub fn cttrigctl_cten_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CTTRIGCTL_CTEN_A :: CTTRIGCTL_CTEN_ENABLE) } } # [doc = "Field `CTTRIGCTL_EVTCTEN` reader - Enable the Input Trigger Conditions to the Timer module as a condition for Cross Triggers. Refer Figure 8 Cross Trigger Generation Path"] pub type CTTRIGCTL_EVTCTEN_R = crate :: BitReader < CTTRIGCTL_EVTCTEN_A > ; # [doc = "Enable the Input Trigger Conditions to the Timer module as a condition for Cross Triggers. Refer Figure 8 Cross Trigger Generation Path\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CTTRIGCTL_EVTCTEN_A { # [doc = "0: DISABLED"] CTTRIGCTL_EVTCTEN_DISABLED = 0 , # [doc = "1: ENABLE"] CTTRIGCTL_EVTCTEN_ENABLE = 1 , } impl From < CTTRIGCTL_EVTCTEN_A > for bool { # [inline (always)] fn from (variant : CTTRIGCTL_EVTCTEN_A) -> Self { variant as u8 != 0 } } impl CTTRIGCTL_EVTCTEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CTTRIGCTL_EVTCTEN_A { match self . bits { false => CTTRIGCTL_EVTCTEN_A :: CTTRIGCTL_EVTCTEN_DISABLED , true => CTTRIGCTL_EVTCTEN_A :: CTTRIGCTL_EVTCTEN_ENABLE , } } # [doc = "DISABLED"] # [inline (always)] pub fn is_cttrigctl_evtcten_disabled (& self) -> bool { * self == CTTRIGCTL_EVTCTEN_A :: CTTRIGCTL_EVTCTEN_DISABLED } # [doc = "ENABLE"] # [inline (always)] pub fn is_cttrigctl_evtcten_enable (& self) -> bool { * self == CTTRIGCTL_EVTCTEN_A :: CTTRIGCTL_EVTCTEN_ENABLE } } # [doc = "Field `CTTRIGCTL_EVTCTEN` writer - Enable the Input Trigger Conditions to the Timer module as a condition for Cross Triggers. Refer Figure 8 Cross Trigger Generation Path"] pub type CTTRIGCTL_EVTCTEN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O , CTTRIGCTL_EVTCTEN_A > ; impl < 'a , REG , const O : u8 > CTTRIGCTL_EVTCTEN_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DISABLED"] # [inline (always)] pub fn cttrigctl_evtcten_disabled (self) -> & 'a mut crate :: W < REG > { self . variant (CTTRIGCTL_EVTCTEN_A :: CTTRIGCTL_EVTCTEN_DISABLED) } # [doc = "ENABLE"] # [inline (always)] pub fn cttrigctl_evtcten_enable (self) -> & 'a mut crate :: W < REG > { self . variant (CTTRIGCTL_EVTCTEN_A :: CTTRIGCTL_EVTCTEN_ENABLE) } } # [doc = "Field `CTTRIGCTL_EVTCTTRIGSEL` reader - Used to Select the subscriber port that should be used for input cross trigger. Refer Figure 8 Cross Trigger Generation Path"] pub type CTTRIGCTL_EVTCTTRIGSEL_R = crate :: FieldReader < CTTRIGCTL_EVTCTTRIGSEL_A > ; # [doc = "Used to Select the subscriber port that should be used for input cross trigger. Refer Figure 8 Cross Trigger Generation Path\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum CTTRIGCTL_EVTCTTRIGSEL_A { # [doc = "0: FSUB0"] CTTRIGCTL_EVTCTTRIGSEL_FSUB0 = 0 , # [doc = "1: FSUB1"] CTTRIGCTL_EVTCTTRIGSEL_FSUB1 = 1 , # [doc = "2: Z"] CTTRIGCTL_EVTCTTRIGSEL_Z = 2 , # [doc = "3: L"] CTTRIGCTL_EVTCTTRIGSEL_L = 3 , # [doc = "4: CCD0"] CTTRIGCTL_EVTCTTRIGSEL_CCD0 = 4 , # [doc = "5: CCD1"] CTTRIGCTL_EVTCTTRIGSEL_CCD1 = 5 , # [doc = "6: CCD2"] CTTRIGCTL_EVTCTTRIGSEL_CCD2 = 6 , # [doc = "7: CCD3"] CTTRIGCTL_EVTCTTRIGSEL_CCD3 = 7 , # [doc = "8: CCU0"] CTTRIGCTL_EVTCTTRIGSEL_CCU0 = 8 , # [doc = "9: CCU1"] CTTRIGCTL_EVTCTTRIGSEL_CCU1 = 9 , # [doc = "10: CCU2"] CTTRIGCTL_EVTCTTRIGSEL_CCU2 = 10 , # [doc = "11: CCU3"] CTTRIGCTL_EVTCTTRIGSEL_CCU3 = 11 , } impl From < CTTRIGCTL_EVTCTTRIGSEL_A > for u8 { # [inline (always)] fn from (variant : CTTRIGCTL_EVTCTTRIGSEL_A) -> Self { variant as _ } } impl crate :: FieldSpec for CTTRIGCTL_EVTCTTRIGSEL_A { type Ux = u8 ; } impl CTTRIGCTL_EVTCTTRIGSEL_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < CTTRIGCTL_EVTCTTRIGSEL_A > { match self . bits { 0 => Some (CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_FSUB0) , 1 => Some (CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_FSUB1) , 2 => Some (CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_Z) , 3 => Some (CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_L) , 4 => Some (CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_CCD0) , 5 => Some (CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_CCD1) , 6 => Some (CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_CCD2) , 7 => Some (CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_CCD3) , 8 => Some (CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_CCU0) , 9 => Some (CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_CCU1) , 10 => Some (CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_CCU2) , 11 => Some (CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_CCU3) , _ => None , } } # [doc = "FSUB0"] # [inline (always)] pub fn is_cttrigctl_evtcttrigsel_fsub0 (& self) -> bool { * self == CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_FSUB0 } # [doc = "FSUB1"] # [inline (always)] pub fn is_cttrigctl_evtcttrigsel_fsub1 (& self) -> bool { * self == CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_FSUB1 } # [doc = "Z"] # [inline (always)] pub fn is_cttrigctl_evtcttrigsel_z (& self) -> bool { * self == CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_Z } # [doc = "L"] # [inline (always)] pub fn is_cttrigctl_evtcttrigsel_l (& self) -> bool { * self == CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_L } # [doc = "CCD0"] # [inline (always)] pub fn is_cttrigctl_evtcttrigsel_ccd0 (& self) -> bool { * self == CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_CCD0 } # [doc = "CCD1"] # [inline (always)] pub fn is_cttrigctl_evtcttrigsel_ccd1 (& self) -> bool { * self == CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_CCD1 } # [doc = "CCD2"] # [inline (always)] pub fn is_cttrigctl_evtcttrigsel_ccd2 (& self) -> bool { * self == CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_CCD2 } # [doc = "CCD3"] # [inline (always)] pub fn is_cttrigctl_evtcttrigsel_ccd3 (& self) -> bool { * self == CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_CCD3 } # [doc = "CCU0"] # [inline (always)] pub fn is_cttrigctl_evtcttrigsel_ccu0 (& self) -> bool { * self == CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_CCU0 } # [doc = "CCU1"] # [inline (always)] pub fn is_cttrigctl_evtcttrigsel_ccu1 (& self) -> bool { * self == CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_CCU1 } # [doc = "CCU2"] # [inline (always)] pub fn is_cttrigctl_evtcttrigsel_ccu2 (& self) -> bool { * self == CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_CCU2 } # [doc = "CCU3"] # [inline (always)] pub fn is_cttrigctl_evtcttrigsel_ccu3 (& self) -> bool { * self == CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_CCU3 } } # [doc = "Field `CTTRIGCTL_EVTCTTRIGSEL` writer - Used to Select the subscriber port that should be used for input cross trigger. Refer Figure 8 Cross Trigger Generation Path"] pub type CTTRIGCTL_EVTCTTRIGSEL_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 4 , O , CTTRIGCTL_EVTCTTRIGSEL_A > ; impl < 'a , REG , const O : u8 > CTTRIGCTL_EVTCTTRIGSEL_W < 'a , REG , O > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "FSUB0"] # [inline (always)] pub fn cttrigctl_evtcttrigsel_fsub0 (self) -> & 'a mut crate :: W < REG > { self . variant (CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_FSUB0) } # [doc = "FSUB1"] # [inline (always)] pub fn cttrigctl_evtcttrigsel_fsub1 (self) -> & 'a mut crate :: W < REG > { self . variant (CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_FSUB1) } # [doc = "Z"] # [inline (always)] pub fn cttrigctl_evtcttrigsel_z (self) -> & 'a mut crate :: W < REG > { self . variant (CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_Z) } # [doc = "L"] # [inline (always)] pub fn cttrigctl_evtcttrigsel_l (self) -> & 'a mut crate :: W < REG > { self . variant (CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_L) } # [doc = "CCD0"] # [inline (always)] pub fn cttrigctl_evtcttrigsel_ccd0 (self) -> & 'a mut crate :: W < REG > { self . variant (CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_CCD0) } # [doc = "CCD1"] # [inline (always)] pub fn cttrigctl_evtcttrigsel_ccd1 (self) -> & 'a mut crate :: W < REG > { self . variant (CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_CCD1) } # [doc = "CCD2"] # [inline (always)] pub fn cttrigctl_evtcttrigsel_ccd2 (self) -> & 'a mut crate :: W < REG > { self . variant (CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_CCD2) } # [doc = "CCD3"] # [inline (always)] pub fn cttrigctl_evtcttrigsel_ccd3 (self) -> & 'a mut crate :: W < REG > { self . variant (CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_CCD3) } # [doc = "CCU0"] # [inline (always)] pub fn cttrigctl_evtcttrigsel_ccu0 (self) -> & 'a mut crate :: W < REG > { self . variant (CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_CCU0) } # [doc = "CCU1"] # [inline (always)] pub fn cttrigctl_evtcttrigsel_ccu1 (self) -> & 'a mut crate :: W < REG > { self . variant (CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_CCU1) } # [doc = "CCU2"] # [inline (always)] pub fn cttrigctl_evtcttrigsel_ccu2 (self) -> & 'a mut crate :: W < REG > { self . variant (CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_CCU2) } # [doc = "CCU3"] # [inline (always)] pub fn cttrigctl_evtcttrigsel_ccu3 (self) -> & 'a mut crate :: W < REG > { self . variant (CTTRIGCTL_EVTCTTRIGSEL_A :: CTTRIGCTL_EVTCTTRIGSEL_CCU3) } } impl R { # [doc = "Bit 0 - Timer Cross trigger enable. This field is used to enable whether the SW or HW logic can generate a timer cross trigger event in the system. These cross triggers are connected to the respective timer trigger in of the other timer IPs in the SOC power domain. The timer cross trigger is essentially the combined logic of the HW and SW conditions controlling EN bit in the CTRCTL register."] # [inline (always)] pub fn cttrigctl_cten (& self) -> CTTRIGCTL_CTEN_R { CTTRIGCTL_CTEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Enable the Input Trigger Conditions to the Timer module as a condition for Cross Triggers. Refer Figure 8 Cross Trigger Generation Path"] # [inline (always)] pub fn cttrigctl_evtcten (& self) -> CTTRIGCTL_EVTCTEN_R { CTTRIGCTL_EVTCTEN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 16:19 - Used to Select the subscriber port that should be used for input cross trigger. Refer Figure 8 Cross Trigger Generation Path"] # [inline (always)] pub fn cttrigctl_evtcttrigsel (& self) -> CTTRIGCTL_EVTCTTRIGSEL_R { CTTRIGCTL_EVTCTTRIGSEL_R :: new (((self . bits >> 16) & 0x0f) as u8) } } impl W { # [doc = "Bit 0 - Timer Cross trigger enable. This field is used to enable whether the SW or HW logic can generate a timer cross trigger event in the system. These cross triggers are connected to the respective timer trigger in of the other timer IPs in the SOC power domain. The timer cross trigger is essentially the combined logic of the HW and SW conditions controlling EN bit in the CTRCTL register."] # [inline (always)] # [must_use] pub fn cttrigctl_cten (& mut self) -> CTTRIGCTL_CTEN_W < CTTRIGCTL_SPEC , 0 > { CTTRIGCTL_CTEN_W :: new (self) } # [doc = "Bit 1 - Enable the Input Trigger Conditions to the Timer module as a condition for Cross Triggers. Refer Figure 8 Cross Trigger Generation Path"] # [inline (always)] # [must_use] pub fn cttrigctl_evtcten (& mut self) -> CTTRIGCTL_EVTCTEN_W < CTTRIGCTL_SPEC , 1 > { CTTRIGCTL_EVTCTEN_W :: new (self) } # [doc = "Bits 16:19 - Used to Select the subscriber port that should be used for input cross trigger. Refer Figure 8 Cross Trigger Generation Path"] # [inline (always)] # [must_use] pub fn cttrigctl_evtcttrigsel (& mut self) -> CTTRIGCTL_EVTCTTRIGSEL_W < CTTRIGCTL_SPEC , 16 > { CTTRIGCTL_EVTCTTRIGSEL_W :: new (self) } # [doc = r" Writes raw bits to the register."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"] # [inline (always)] pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Timer Cross Trigger Control Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cttrigctl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cttrigctl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CTTRIGCTL_SPEC ; impl crate :: RegisterSpec for CTTRIGCTL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cttrigctl::R`](R) reader structure"] impl crate :: Readable for CTTRIGCTL_SPEC { } # [doc = "`write(|w| ..)` method takes [`cttrigctl::W`](W) writer structure"] impl crate :: Writable for CTTRIGCTL_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTTRIGCTL to value 0"] impl crate :: Resettable for CTTRIGCTL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; }