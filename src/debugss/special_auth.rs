# [doc = "Register `SPECIAL_AUTH` reader"] pub type R = crate :: R < SPECIAL_AUTH_SPEC > ; # [doc = "Field `SPECIAL_AUTH_SECAPEN` reader - An active high input. When asserted (and SWD access is also permitted), the debug tools can use the Security-AP to communicate with security control logic. When deasserted, a DAPBUS firewall will isolate the AP and prevent access to the Security-AP."] pub type SPECIAL_AUTH_SECAPEN_R = crate :: BitReader < SPECIAL_AUTH_SECAPEN_A > ; # [doc = "An active high input. When asserted (and SWD access is also permitted), the debug tools can use the Security-AP to communicate with security control logic. When deasserted, a DAPBUS firewall will isolate the AP and prevent access to the Security-AP.\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SPECIAL_AUTH_SECAPEN_A { # [doc = "0: DISABLE"] SPECIAL_AUTH_SECAPEN_DISABLE = 0 , # [doc = "1: ENABLE"] SPECIAL_AUTH_SECAPEN_ENABLE = 1 , } impl From < SPECIAL_AUTH_SECAPEN_A > for bool { # [inline (always)] fn from (variant : SPECIAL_AUTH_SECAPEN_A) -> Self { variant as u8 != 0 } } impl SPECIAL_AUTH_SECAPEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SPECIAL_AUTH_SECAPEN_A { match self . bits { false => SPECIAL_AUTH_SECAPEN_A :: SPECIAL_AUTH_SECAPEN_DISABLE , true => SPECIAL_AUTH_SECAPEN_A :: SPECIAL_AUTH_SECAPEN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_special_auth_secapen_disable (& self) -> bool { * self == SPECIAL_AUTH_SECAPEN_A :: SPECIAL_AUTH_SECAPEN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_special_auth_secapen_enable (& self) -> bool { * self == SPECIAL_AUTH_SECAPEN_A :: SPECIAL_AUTH_SECAPEN_ENABLE } } # [doc = "Field `SPECIAL_AUTH_SWDPORTEN` reader - When asserted, the SW-DP functions normally. When deasserted, the SW-DP effectively disables all external debug access."] pub type SPECIAL_AUTH_SWDPORTEN_R = crate :: BitReader < SPECIAL_AUTH_SWDPORTEN_A > ; # [doc = "When asserted, the SW-DP functions normally. When deasserted, the SW-DP effectively disables all external debug access.\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SPECIAL_AUTH_SWDPORTEN_A { # [doc = "0: DISABLE"] SPECIAL_AUTH_SWDPORTEN_DISABLE = 0 , # [doc = "1: ENABLE"] SPECIAL_AUTH_SWDPORTEN_ENABLE = 1 , } impl From < SPECIAL_AUTH_SWDPORTEN_A > for bool { # [inline (always)] fn from (variant : SPECIAL_AUTH_SWDPORTEN_A) -> Self { variant as u8 != 0 } } impl SPECIAL_AUTH_SWDPORTEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SPECIAL_AUTH_SWDPORTEN_A { match self . bits { false => SPECIAL_AUTH_SWDPORTEN_A :: SPECIAL_AUTH_SWDPORTEN_DISABLE , true => SPECIAL_AUTH_SWDPORTEN_A :: SPECIAL_AUTH_SWDPORTEN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_special_auth_swdporten_disable (& self) -> bool { * self == SPECIAL_AUTH_SWDPORTEN_A :: SPECIAL_AUTH_SWDPORTEN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_special_auth_swdporten_enable (& self) -> bool { * self == SPECIAL_AUTH_SWDPORTEN_A :: SPECIAL_AUTH_SWDPORTEN_ENABLE } } # [doc = "Field `SPECIAL_AUTH_DFTAPEN` reader - An active high input. When asserted (and SWD access is also permitted), the debug tools can then access the DFT-AP external to the DebugSS lite. When deasserted, a DAPBUS firewall will isolate the AP and prevent access."] pub type SPECIAL_AUTH_DFTAPEN_R = crate :: BitReader < SPECIAL_AUTH_DFTAPEN_A > ; # [doc = "An active high input. When asserted (and SWD access is also permitted), the debug tools can then access the DFT-AP external to the DebugSS lite. When deasserted, a DAPBUS firewall will isolate the AP and prevent access.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SPECIAL_AUTH_DFTAPEN_A { # [doc = "0: DISABLE"] SPECIAL_AUTH_DFTAPEN_DISABLE = 0 , # [doc = "1: ENABLE"] SPECIAL_AUTH_DFTAPEN_ENABLE = 1 , } impl From < SPECIAL_AUTH_DFTAPEN_A > for bool { # [inline (always)] fn from (variant : SPECIAL_AUTH_DFTAPEN_A) -> Self { variant as u8 != 0 } } impl SPECIAL_AUTH_DFTAPEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SPECIAL_AUTH_DFTAPEN_A { match self . bits { false => SPECIAL_AUTH_DFTAPEN_A :: SPECIAL_AUTH_DFTAPEN_DISABLE , true => SPECIAL_AUTH_DFTAPEN_A :: SPECIAL_AUTH_DFTAPEN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_special_auth_dftapen_disable (& self) -> bool { * self == SPECIAL_AUTH_DFTAPEN_A :: SPECIAL_AUTH_DFTAPEN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_special_auth_dftapen_enable (& self) -> bool { * self == SPECIAL_AUTH_DFTAPEN_A :: SPECIAL_AUTH_DFTAPEN_ENABLE } } # [doc = "Field `SPECIAL_AUTH_ETAPEN` reader - An active high input. When asserted (and SWD access is also permitted), the debug tools can then access an ET-AP external to the DebugSS lite. When deasserted, a DAPBUS firewall will isolate the AP and prevent access."] pub type SPECIAL_AUTH_ETAPEN_R = crate :: BitReader < SPECIAL_AUTH_ETAPEN_A > ; # [doc = "An active high input. When asserted (and SWD access is also permitted), the debug tools can then access an ET-AP external to the DebugSS lite. When deasserted, a DAPBUS firewall will isolate the AP and prevent access.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SPECIAL_AUTH_ETAPEN_A { # [doc = "0: DISABLE"] SPECIAL_AUTH_ETAPEN_DISABLE = 0 , # [doc = "1: ENABLE"] SPECIAL_AUTH_ETAPEN_ENABLE = 1 , } impl From < SPECIAL_AUTH_ETAPEN_A > for bool { # [inline (always)] fn from (variant : SPECIAL_AUTH_ETAPEN_A) -> Self { variant as u8 != 0 } } impl SPECIAL_AUTH_ETAPEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SPECIAL_AUTH_ETAPEN_A { match self . bits { false => SPECIAL_AUTH_ETAPEN_A :: SPECIAL_AUTH_ETAPEN_DISABLE , true => SPECIAL_AUTH_ETAPEN_A :: SPECIAL_AUTH_ETAPEN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_special_auth_etapen_disable (& self) -> bool { * self == SPECIAL_AUTH_ETAPEN_A :: SPECIAL_AUTH_ETAPEN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_special_auth_etapen_enable (& self) -> bool { * self == SPECIAL_AUTH_ETAPEN_A :: SPECIAL_AUTH_ETAPEN_ENABLE } } # [doc = "Field `SPECIAL_AUTH_CFGAPEN` reader - An active high input. When asserted (and SWD access is also permitted), the debug tools can use the Config-AP to read device configuration information. When deasserted, a DAPBUS firewall will isolate the AP and prevent access to the Config-AP."] pub type SPECIAL_AUTH_CFGAPEN_R = crate :: BitReader < SPECIAL_AUTH_CFGAPEN_A > ; # [doc = "An active high input. When asserted (and SWD access is also permitted), the debug tools can use the Config-AP to read device configuration information. When deasserted, a DAPBUS firewall will isolate the AP and prevent access to the Config-AP.\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SPECIAL_AUTH_CFGAPEN_A { # [doc = "0: DISABLE"] SPECIAL_AUTH_CFGAPEN_DISABLE = 0 , # [doc = "1: ENABLE"] SPECIAL_AUTH_CFGAPEN_ENABLE = 1 , } impl From < SPECIAL_AUTH_CFGAPEN_A > for bool { # [inline (always)] fn from (variant : SPECIAL_AUTH_CFGAPEN_A) -> Self { variant as u8 != 0 } } impl SPECIAL_AUTH_CFGAPEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SPECIAL_AUTH_CFGAPEN_A { match self . bits { false => SPECIAL_AUTH_CFGAPEN_A :: SPECIAL_AUTH_CFGAPEN_DISABLE , true => SPECIAL_AUTH_CFGAPEN_A :: SPECIAL_AUTH_CFGAPEN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_special_auth_cfgapen_disable (& self) -> bool { * self == SPECIAL_AUTH_CFGAPEN_A :: SPECIAL_AUTH_CFGAPEN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_special_auth_cfgapen_enable (& self) -> bool { * self == SPECIAL_AUTH_CFGAPEN_A :: SPECIAL_AUTH_CFGAPEN_ENABLE } } # [doc = "Field `SPECIAL_AUTH_AHBAPEN` reader - Disabling / enabling debug access to the M0+ Core via the AHB-AP DAP bus isolation."] pub type SPECIAL_AUTH_AHBAPEN_R = crate :: BitReader < SPECIAL_AUTH_AHBAPEN_A > ; # [doc = "Disabling / enabling debug access to the M0+ Core via the AHB-AP DAP bus isolation.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SPECIAL_AUTH_AHBAPEN_A { # [doc = "0: DISABLE"] SPECIAL_AUTH_AHBAPEN_DISABLE = 0 , # [doc = "1: ENABLE"] SPECIAL_AUTH_AHBAPEN_ENABLE = 1 , } impl From < SPECIAL_AUTH_AHBAPEN_A > for bool { # [inline (always)] fn from (variant : SPECIAL_AUTH_AHBAPEN_A) -> Self { variant as u8 != 0 } } impl SPECIAL_AUTH_AHBAPEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SPECIAL_AUTH_AHBAPEN_A { match self . bits { false => SPECIAL_AUTH_AHBAPEN_A :: SPECIAL_AUTH_AHBAPEN_DISABLE , true => SPECIAL_AUTH_AHBAPEN_A :: SPECIAL_AUTH_AHBAPEN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_special_auth_ahbapen_disable (& self) -> bool { * self == SPECIAL_AUTH_AHBAPEN_A :: SPECIAL_AUTH_AHBAPEN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_special_auth_ahbapen_enable (& self) -> bool { * self == SPECIAL_AUTH_AHBAPEN_A :: SPECIAL_AUTH_AHBAPEN_ENABLE } } # [doc = "Field `SPECIAL_AUTH_PWRAPEN` reader - An active high input. When asserted (and SWD access is also permitted), the debug tools can then access the PWR-AP to power and reset state of the CPU. When deasserted, a DAPBUS firewall will isolate the AP and prevent access."] pub type SPECIAL_AUTH_PWRAPEN_R = crate :: BitReader < SPECIAL_AUTH_PWRAPEN_A > ; # [doc = "An active high input. When asserted (and SWD access is also permitted), the debug tools can then access the PWR-AP to power and reset state of the CPU. When deasserted, a DAPBUS firewall will isolate the AP and prevent access.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SPECIAL_AUTH_PWRAPEN_A { # [doc = "0: DISABLE"] SPECIAL_AUTH_PWRAPEN_DISABLE = 0 , # [doc = "1: ENABLE"] SPECIAL_AUTH_PWRAPEN_ENABLE = 1 , } impl From < SPECIAL_AUTH_PWRAPEN_A > for bool { # [inline (always)] fn from (variant : SPECIAL_AUTH_PWRAPEN_A) -> Self { variant as u8 != 0 } } impl SPECIAL_AUTH_PWRAPEN_R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> SPECIAL_AUTH_PWRAPEN_A { match self . bits { false => SPECIAL_AUTH_PWRAPEN_A :: SPECIAL_AUTH_PWRAPEN_DISABLE , true => SPECIAL_AUTH_PWRAPEN_A :: SPECIAL_AUTH_PWRAPEN_ENABLE , } } # [doc = "DISABLE"] # [inline (always)] pub fn is_special_auth_pwrapen_disable (& self) -> bool { * self == SPECIAL_AUTH_PWRAPEN_A :: SPECIAL_AUTH_PWRAPEN_DISABLE } # [doc = "ENABLE"] # [inline (always)] pub fn is_special_auth_pwrapen_enable (& self) -> bool { * self == SPECIAL_AUTH_PWRAPEN_A :: SPECIAL_AUTH_PWRAPEN_ENABLE } } impl R { # [doc = "Bit 0 - An active high input. When asserted (and SWD access is also permitted), the debug tools can use the Security-AP to communicate with security control logic. When deasserted, a DAPBUS firewall will isolate the AP and prevent access to the Security-AP."] # [inline (always)] pub fn special_auth_secapen (& self) -> SPECIAL_AUTH_SECAPEN_R { SPECIAL_AUTH_SECAPEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - When asserted, the SW-DP functions normally. When deasserted, the SW-DP effectively disables all external debug access."] # [inline (always)] pub fn special_auth_swdporten (& self) -> SPECIAL_AUTH_SWDPORTEN_R { SPECIAL_AUTH_SWDPORTEN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - An active high input. When asserted (and SWD access is also permitted), the debug tools can then access the DFT-AP external to the DebugSS lite. When deasserted, a DAPBUS firewall will isolate the AP and prevent access."] # [inline (always)] pub fn special_auth_dftapen (& self) -> SPECIAL_AUTH_DFTAPEN_R { SPECIAL_AUTH_DFTAPEN_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - An active high input. When asserted (and SWD access is also permitted), the debug tools can then access an ET-AP external to the DebugSS lite. When deasserted, a DAPBUS firewall will isolate the AP and prevent access."] # [inline (always)] pub fn special_auth_etapen (& self) -> SPECIAL_AUTH_ETAPEN_R { SPECIAL_AUTH_ETAPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - An active high input. When asserted (and SWD access is also permitted), the debug tools can use the Config-AP to read device configuration information. When deasserted, a DAPBUS firewall will isolate the AP and prevent access to the Config-AP."] # [inline (always)] pub fn special_auth_cfgapen (& self) -> SPECIAL_AUTH_CFGAPEN_R { SPECIAL_AUTH_CFGAPEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Disabling / enabling debug access to the M0+ Core via the AHB-AP DAP bus isolation."] # [inline (always)] pub fn special_auth_ahbapen (& self) -> SPECIAL_AUTH_AHBAPEN_R { SPECIAL_AUTH_AHBAPEN_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - An active high input. When asserted (and SWD access is also permitted), the debug tools can then access the PWR-AP to power and reset state of the CPU. When deasserted, a DAPBUS firewall will isolate the AP and prevent access."] # [inline (always)] pub fn special_auth_pwrapen (& self) -> SPECIAL_AUTH_PWRAPEN_R { SPECIAL_AUTH_PWRAPEN_R :: new (((self . bits >> 6) & 1) != 0) } } # [doc = "Special enable authorization register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`special_auth::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SPECIAL_AUTH_SPEC ; impl crate :: RegisterSpec for SPECIAL_AUTH_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`special_auth::R`](R) reader structure"] impl crate :: Readable for SPECIAL_AUTH_SPEC { } # [doc = "`reset()` method sets SPECIAL_AUTH to value 0x13"] impl crate :: Resettable for SPECIAL_AUTH_SPEC { const RESET_VALUE : Self :: Ux = 0x13 ; }